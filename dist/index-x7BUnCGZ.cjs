"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const o=require("./graph_model-BLJCkqkS.cjs");/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lf=.001,nc=.1;function cf(n,e,t){return t==null&&(t=gr()),Ko(n,e,(s,r)=>xr(s,r,t))}function gr(){return o.ENGINE.backend.floatPrecision()===32?lf:nc}function Ko(n,e,t){let s=!0;if((o.isTypedArray(n)||o.isTypedArray(e))&&(s=!1),o.isTypedArray(n)&&o.isTypedArray(e)&&(s=!0),s){const a=n.constructor.name,l=e.constructor.name;if(a!==l)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${l}`)}if(Array.isArray(n)&&Array.isArray(e)){const a=o.inferShape(n),l=o.inferShape(e);if(!o.arraysEqual(a,l))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${l}]`)}const r=o.isTypedArray(n)?n:o.flatten(n),i=o.isTypedArray(e)?e:o.flatten(e);if(r.length!==i.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${i.length}.
Actual:   ${r}.
Expected: ${i}.`);for(let a=0;a<i.length;++a){const l=r[a],c=i[a];if(!t(l,c))throw new Error(`Arrays differ: actual[${a}] = ${l}, expected[${a}] = ${c}.
Actual:   ${r}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function uf(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function df(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return o.isString(n)||o.isString(n[0])||o.isString(e)||o.isString(e[0])?Ko(n,t,(s,r)=>s==r):Ko(n,e,(s,r)=>xr(s,r,0))}function hf(n,e,t){if(t==null&&(t=gr()),!xr(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function xr(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function pf(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function ff(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function sc(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?sc(t):n[e]=o.encodeString(t)}return n}function mf(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function gf(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const xf=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:nc,createVideoElement:mf,encodeStrings:sc,expectArrayBuffersEqual:ff,expectArraysClose:cf,expectArraysEqual:df,expectNumbersClose:hf,expectPromiseToFail:uf,expectValuesInRange:pf,play:gf,testEpsilon:gr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bf(n,e,t){const s=o.convertToTensor(n,"labels","confusionMatrix"),r=o.convertToTensor(e,"predictions","confusionMatrix");o.assert(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),o.assert(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),o.assert(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),o.assert(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),o.assert(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const i=o.oneHot(o.cast(s,"int32"),t),a=o.oneHot(o.cast(r,"int32"),t),l=o.transpose(i),c=o.matMul(l,a);return o.cast(c,"int32")}const yf=o.op({confusionMatrix_:bf});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cf=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:yf},Symbol.toStringTag,{value:"Module"}));function io(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(o.sizeFromShape(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let a=1;for(let h=0;h<r.length-1;++h)a*=r[h];const l=n.shape,c=r.slice();c.pop();let u=1;for(let h=i;h<t;++h)u*=l[h],c.push(l[h]);const d=[...o.computeStrides(n.shape).map(h=>h/u),1].slice(0,i);return[c,a,u,d]}const wf=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:io},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yo=-2,vf=-1;function br(n,e,t){const s=n.shape.length;o.assert(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),o.assert(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)o.assert(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function Sf(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function yr(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function oc(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function rc(n,e,t){return t<=n?t:t-(e-1)}function ic(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function If(n,e,t,s,r,i,a,l,c){const u=n.length;let d=new Array(u),h=new Array(u),p=new Array(u);if(e.length&&t>0){const f=e[0],m=t+1;d=ac(a,f,m,s,n),h=lc(l,f,m,r,n),p=oc(i,f,m,n)}else for(let f=0;f<u;f++)d[f]=uc(a,s,i,n,f,c),h[f]=dc(l,r,i,n,f,c),p[f]=cc(i,f,c);return{begin:d,end:h,strides:p}}function ac(n,e,t,s,r){const i=[...r],a=ic(t,e);for(let l=0;l<i.length;l++)if(a.indexOf(l)>-1)i[l]=0;else{const c=rc(e,t,l);let u=s[c];n&1<<c&&(u=0),i[l]=u}return i}function lc(n,e,t,s,r){const i=[...r],a=ic(t,e);for(let l=0;l<i.length;l++)if(a.indexOf(l)>-1)i[l]=Number.MAX_SAFE_INTEGER;else{const c=rc(e,t,l);let u=s[c];n&1<<c&&(u=Number.MAX_SAFE_INTEGER),i[l]=u}for(let l=0;l<i.length;l++){const c=r[l];i[l]<0&&(i[l]+=c),i[l]=o.clamp(0,i[l],r[l])}return i}function cc(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function uc(n,e,t,s,r,i){let a=e[r];const l=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(l>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const c=s[r];return a<0&&(a+=c),a=o.clamp(0,a,c-1),a}function dc(n,e,t,s,r,i){let a=e[r];const l=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(l>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const c=s[r];return a<0&&(a+=c),l>0?a=o.clamp(0,a,c):a=o.clamp(-1,a,c-1),a}function Cr(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function wr(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function ao(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{o.assert(a!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((a,l)=>a>=0?a:(o.assert(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${l}.`),n.shape[l]-s[l])),[s,i]}function vr(n,e,t,s,r,i,a,l,c){let u;if(s==null?(u=new Array(e.length),u.fill(1)):u=s,a!=null&&a&a-1)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:l,shrinkAxisMask:c};for(let w=0;w<h.dims;w++)d&&1<<w&l&&h.numAddAxisAfterEllipsis++,1<<w&a&&(d=!0);d||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};kf(h,p);let f=!0,m=!0,g=!0;const x=[],b=[];for(let w=0;w<n.length;++w){if(p.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);const C=!!(p.shrinkAxisMask&1<<w),v=n[w];if(v===-1){x.push(C?1:-1);continue}const S=[p.beginMask&1<<w,p.endMask&1<<w],I=[p.strides[w]>0?0:-1,p.strides[w]>0?v:v-1];if(C&&p.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[w]===1;const k=!!(p.beginMask&1<<w&&p.endMask&1<<w);if(p.beginValid&&p.endValid){if(C){const F=p.begin[w]<0?v+p.begin[w]:p.begin[w];if(p.begin[w]=F,p.end[w]=p.begin[w]+1,F<0||F>=v)throw Error(`slice index ${p.begin[w]} of dimension ${w} out of bounds.`)}else p.begin[w]=Ha(p.begin[w],0,p.strides[w],v,S,I),p.end[w]=Ha(p.end[w],1,p.strides[w],v,S,I);const R=p.strides[w]===1&&p.begin[w]===0&&p.end[w]===v;f=f&&R,m=m&&(w===0&&p.strides[w]===1||R)}else f=f&&p.strides[w]===1&&k,m=m&&(w===0&&p.strides[w]===1||k);let $,N=!1;if(p.beginValid&&p.endValid?($=p.end[w]-p.begin[w],N=!0):C?($=1,N=!0):k&&v>=0&&(p.strides[w]<0?$=-v:$=v,N=!0),N){let R;$===0||$<0!=p.strides[w]<0?R=0:R=Math.trunc($/p.strides[w])+($%p.strides[w]!==0?1:0),x.push(R)}else x.push(-1)}for(let w=0;w<p.finalShapeGatherIndices.length;++w){const C=p.finalShapeGatherIndices[w];C>=0?b.push(x[C]):C===Yo&&b.push(1)}return{finalShapeSparse:b.filter((w,C)=>p.finalShapeGatherIndices[C]!==Yo),finalShape:b,isIdentity:f,sliceDim0:m,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function kf(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(Yo),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(vf),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function Ha(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const a=n<0?s+n:n;return a<i[0]?i[0]:a>i[1]?i[1]:a}}const hc=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:br,computeFlatOffset:wr,computeOutShape:yr,getNormalizedAxes:If,isSliceContinous:Cr,maskToAxes:Sf,parseSliceParams:ao,sliceInfo:vr,startForAxis:uc,startIndicesWithElidedDims:ac,stopForAxis:dc,stopIndicesWithElidedDims:lc,stridesForAxis:cc,stridesWithElidedDims:oc},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const pc="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fc{static sgd(e){return new o.SGDOptimizer(e)}static momentum(e,t,s=!1){return new o.MomentumOptimizer(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new o.RMSPropOptimizer(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new o.AdamOptimizer(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new o.AdadeltaOptimizer(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new o.AdamaxOptimizer(e,t,s,r,i)}static adagrad(e,t=.1){return new o.AdagradOptimizer(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xt=fc;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tf=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function Sr(){return new Promise(n=>Tf(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(n,e){const t=n[0].length;n.forEach((r,i)=>{o.assert(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),o.assert(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let a=0;a<t;a++)o.assert(a===e||r[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function mt(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var nt;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(nt||(nt={}));function mc(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],a=s[s.length-t.length+r],l=s[a];if(i>=0)if(l>=0){if(l!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${l}`)}else s[a]=i}return s}function gc(n){const e={FIRST_DIM_SIZE:nt.FIRST_DIM_SIZE,VALUE_ROWIDS:nt.VALUE_ROWIDS,ROW_LENGTHS:nt.ROW_LENGTHS,ROW_SPLITS:nt.ROW_SPLITS,ROW_LIMITS:nt.ROW_LIMITS,ROW_STARTS:nt.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function xc(n){return n.length===0?0:n[0]===nt.FIRST_DIM_SIZE?n.length-1:n.length}function bc(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],a=e[r+1];if(i>=0&&a>=0&&i!==1&&i!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kr=30;function lo(n){return n<=kr?n:o.nearestDivisor(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tr(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function os(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let a=0;a<i;++a)r=r.concat([n[a+1]/e[a],e[a]]);r=r.concat(n.slice(i+1))}return r}function rs(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?i.push(a):r.push(a);s.push(...r),s.push(0),s.push(...i)}return s}function is(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function $r(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Nr(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const co=1.7580993408473768,uo=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rr=.3275911,Ar=.254829592,Dr=-.284496736,Er=1.421413741,Fr=-1.453152027,Or=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function It(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function yc(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function Cc(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function wc(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function Lr(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function vc(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function Sc(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function Ic(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bo="->",$f=/->/g,qa=",",Xa="...";function Pr(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace($f,"").length)/Bo.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Bo}").`);const[s,r]=n.split(Bo);o.assert(s.indexOf(Xa)===-1,()=>`The ellipsis notation ("${Xa}") is not supported yet.`);const i=s.split(qa),a=i.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let p=0;p<r.length;++p){const f=r[p];if(!i.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);l.indexOf(f)===-1&&l.push(f)}for(let p=0;p<s.length;++p){const f=s[p];l.indexOf(f)===-1&&f!==qa&&l.push(f)}const c=new Array(i.length);for(let p=0;p<a;++p){if(new Set(i[p].split("")).size!==i[p].length)throw new Error(`Found duplicate axes in input component ${i[p]}. Support for duplicate axes in input is not implemented yet.`);c[p]=[];for(let f=0;f<i[p].length;++f)c[p].push(l.indexOf(i[p][f]))}const u=l.length,d=r.length,h=[];for(let p=d;p<u;++p)h.push(p);return{allDims:l,summedDims:h,idDims:c}}function Mr(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function zr(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=i[a]:o.assert(s[e[r][a]]===i[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(i)}, but got dimension ${i[a]}`)}}function _r(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const i=[];for(let a=0;a<t.length;++a){const l=t[a],c=Nf(e,l);for(const u of c)i.indexOf(u)===-1&&(s[a].push(u),i.push(u))}return{path:t,steps:s}}function Br(n){return n.every((e,t)=>e===t)}function Nf(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Vr(n,e,t=0){let s=[];if(typeof e=="number")o.assert(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((a,l)=>(l===-1&&(a+=1),a),0);o.assert(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const a=e.reduce((l,c)=>c>0?l+c:l);e[i]=n.shape[t]-a}o.assert(n.shape[t]===e.reduce((a,l)=>a+l),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kc(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Tc(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function $c(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nc(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function Rc(n,e){return`size ${n} must be non-negative, not ${e}`}function Ac(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Dc(n,e){const t=o.sizeFromShape(n),s=o.sizeFromShape(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function Ec(n,e){const t=o.sizeFromShape(n),s=o.sizeFromShape(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zo(){return"segment ids must be >= 0"}function Fc(){return"segment ids are not increasing"}function Oc(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Lc(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pc(n,e){let t=!1,s;for(n<=kr?(s=n,t=!0):s=o.nearestDivisor(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=o.nearestDivisor(n,s+1);return s}function Mc(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function Wr(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const a=n.shape[t],l=[];let c=1,u=1,d=1;for(let h=0;h<s;++h)l.push(n.shape[h]),c*=n.shape[h];for(let h=s;h<t;h++)l.push(n.shape[h]),u*=n.shape[h];for(let h=s;h<r;h++)l.push(e.shape[h]);for(let h=t+1;h<i;h++)l.push(n.shape[h]),d*=n.shape[h];return{batchSize:c,sliceSize:d,outerSize:u,dimSize:a,outputShape:l}}const Rf=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Wr,computeOutShape:Mc,segOpComputeOptimalWindowSize:Pc},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kt(n){try{return n.map(e=>o.decodeString(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function zc(n){return n.map(e=>o.encodeString(e))}const _c=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Ar,ERF_A2:Dr,ERF_A3:Er,ERF_A4:Fr,ERF_A5:Or,ERF_P:Rr,PARALLELIZE_THRESHOLD:kr,get RowPartitionType(){return nt},SELU_SCALE:uo,SELU_SCALEALPHA:co,applyActivation:o.applyActivation,assertAndGetBroadcastShape:o.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:o.assertAxesAreInnerMostDims,assertParamsConsistent:Ir,assignToTypedArray:vc,axesAreInnerMostDims:o.axesAreInnerMostDims,calculateShapes:o.calculateShapes,checkEinsumDimSizes:zr,checkPadOnDimRoundingMode:o.checkPadOnDimRoundingMode,combineLocations:o.combineLocations,combineRaggedTensorToTensorShapes:mc,complexWithEvenIndex:Cc,complexWithOddIndex:wc,computeConv2DInfo:o.computeConv2DInfo,computeConv3DInfo:o.computeConv3DInfo,computeDefaultPad:o.computeDefaultPad,computeDilation2DInfo:o.computeDilation2DInfo,computeOptimalWindowSize:lo,computeOutAndReduceShapes:o.computeOutAndReduceShapes,computeOutShape:mt,computePool2DInfo:o.computePool2DInfo,computePool3DInfo:o.computePool3DInfo,convertConv2DDataFormat:o.convertConv2DDataFormat,decodeEinsumEquation:Pr,eitherStridesOrDilationsAreOne:o.eitherStridesOrDilationsAreOne,expandShapeToKeepDim:o.expandShapeToKeepDim,exponent:Ic,exponents:Sc,fromStringArrayToUint8:zc,fromUint8ToStringArray:kt,getAxesPermutation:o.getAxesPermutation,getBroadcastDims:o.getBroadcastDims,getComplexWithIndex:Lr,getEinsumComputePath:_r,getEinsumPermutation:Mr,getFusedBiasGradient:o.getFusedBiasGradient,getFusedDyActivation:o.getFusedDyActivation,getImageCenter:Tr,getInnerMostAxes:o.getInnerMostAxes,getPermuted:rs,getRaggedRank:xc,getReductionAxes:o.getReductionAxes,getReshaped:os,getReshapedPermuted:is,getRowPartitionTypesHelper:gc,getSliceBeginCoords:$r,getSliceSize:Nr,getSparseFillEmptyRowsIndicesDenseShapeMismatch:kc,getSparseFillEmptyRowsNegativeIndexErrorMessage:Tc,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:$c,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Ac,getSparseReshapeInputOutputMismatchErrorMessage:Ec,getSparseReshapeInputOutputMultipleErrorMessage:Dc,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Nc,getSparseReshapeNegativeOutputDimErrorMessage:Rc,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Lc,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Zo,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Fc,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Oc,getUndoAxesPermutation:o.getUndoAxesPermutation,isIdentityPermutation:Br,log:o.log,mergeRealAndImagArrays:It,prepareAndValidate:io,prepareSplitSize:Vr,segment_util:Rf,shouldFuse:o.shouldFuse,slice_util:hc,splitRealAndImagArrays:yc,stridesOrDilationsArePositive:o.stridesOrDilationsArePositive,tupleValuesAreOne:o.tupleValuesAreOne,upcastType:o.upcastType,validateDefaultValueShape:bc,validateInput:o.validateInput,validateUpdateShape:o.validateUpdateShape,warn:o.warn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Af=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:o.nonMaxSuppressionV3Impl,nonMaxSuppressionV4Impl:o.nonMaxSuppressionV4Impl,nonMaxSuppressionV5Impl:o.nonMaxSuppressionV5Impl,whereImpl:o.whereImpl},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const Bc="4.22.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vc={kernelName:o.Abs,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(n,o.step(o.cast(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Df={kernelName:o.Acos,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=o.square(o.cast(t,"float32")),r=o.sqrt(o.sub(o.scalar(1),s));return o.neg(o.div(n,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ef={kernelName:o.Acosh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=o.sqrt(o.sub(o.square(o.cast(t,"float32")),1));return o.div(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ff={kernelName:o.Add,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=o.assertAndGetBroadcastShape(t.shape,s.shape);return{a:()=>{let l=n;const c=o.getReductionAxes(t.shape,r);return c.length>0&&(l=o.sum(l,c)),o.reshape(l,t.shape)},b:()=>{let l=n;const c=o.getReductionAxes(s.shape,r);return c.length>0&&(l=o.sum(l,c)),o.reshape(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Of={kernelName:o.AddN,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lf={kernelName:o.ArgMax,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.zerosLike(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pf={kernelName:o.ArgMin,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.zerosLike(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mf={kernelName:o.Asin,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.div(n,o.sqrt(o.sub(o.scalar(1),o.square(o.cast(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zf={kernelName:o.Asinh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=o.sqrt(o.add(o.scalar(1),o.square(o.cast(t,"float32"))));return o.div(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _f={kernelName:o.Atan2,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=o.assertAndGetBroadcastShape(t.shape,s.shape);return{a:()=>{const l=o.add(o.square(t),o.square(s));let c=o.mul(n,o.div(s,l));const u=o.getReductionAxes(t.shape,r);return u.length>0&&(c=o.sum(c,u)),o.reshape(c,t.shape)},b:()=>{const l=o.add(o.square(t),o.square(s));let c=o.neg(o.mul(n,o.div(t,l)));const u=o.getReductionAxes(s.shape,r);return u.length>0&&(c=o.sum(c,u)),o.reshape(c,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bf={kernelName:o.Atan,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.div(n,o.add(o.square(o.cast(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vf={kernelName:o.Atanh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.div(n,o.sub(o.scalar(1),o.square(o.cast(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wf(n,e,t,s,r,i){const a=o.convertToTensor(n,"dy","avgPool3dGrad"),l=o.convertToTensor(e,"input","avgPool3dGrad");let c=a,u=l,d=!1;l.rank===4&&(d=!0,c=o.reshape(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=o.reshape(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),o.assert(c.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),o.assert(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),o.checkPadOnDimRoundingMode("avgPool3dGrad",r,i);const h={dy:c,input:u},p={filterSize:t,strides:s,pad:r,dimRoundingMode:i},f=o.ENGINE.runKernel(o.AvgPool3DGrad,h,p);return d?o.reshape(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const Gf=o.op({avgPool3dGrad_:Wf});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uf={kernelName:o.AvgPool3D,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a,dimRoundingMode:l}=t;return{x:()=>Gf(n,s,r,i,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hf(n,e,t,s,r){const i=o.convertToTensor(n,"dy","avgPoolGrad"),a=o.convertToTensor(e,"input","avgPoolGrad");o.assert(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let l=a,c=i,u=!1;a.rank===3&&(u=!0,l=o.reshape(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=o.reshape(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o.assert(c.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),o.assert(l.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${l.rank}.`);const d={dy:c,input:l},h={filterSize:t,strides:s,pad:r},p=o.ENGINE.runKernel(o.AvgPoolGrad,d,h);return u?o.reshape(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const qf=o.op({avgPoolGrad_:Hf});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xf={kernelName:o.AvgPool,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a}=t;return{x:()=>qf(n,s,r,i,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jf={kernelName:o.BatchMatMul,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:a}=t;return!i&&!a?{a:()=>o.matMul(n,r,!1,!0),b:()=>o.matMul(s,n,!0,!1)}:!i&&a?{a:()=>o.matMul(n,r,!1,!1),b:()=>o.matMul(n,s,!0,!1)}:i&&!a?{a:()=>o.matMul(r,n,!1,!0),b:()=>o.matMul(s,n,!1,!1)}:{a:()=>o.matMul(r,n,!0,!0),b:()=>o.matMul(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kf={kernelName:o.BatchToSpaceND,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>o.spaceToBatchND(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yf={kernelName:o.BroadcastTo,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,a=Array.from(i);for(let c=r.length-1;c>=0;c--)if(r[c]===i[c])a[c]=1;else if(r[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const l=[];for(let c=0;c<a.length;c++)a[c]>1&&l.push(c);return{x:()=>o.sum(n,l,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zf={kernelName:o.Cast,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qf={kernelName:o.Ceil,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jf={kernelName:o.ClipByValue,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>o.where(o.logicalAnd(o.greaterEqual(s,r),o.lessEqual(s,i)),n,o.zerosLike(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const em={kernelName:o.ComplexAbs,inputsToSave:["x"],gradFunc:Vc.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tm={kernelName:o.Concat,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(c=>c.shape),{axis:r}=t,i=o.parseAxisParam(r,e[0].shape)[0],a=s.map(c=>c[i]);return o.split(n,a,i).map(c=>()=>c)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nm={kernelName:o.Conv2D,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:a,pad:l,dataFormat:c}=t;return o.assert(o.tupleValuesAreOne(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>o.conv2DBackpropInput(s.shape,n,r,a,l,c),filter:()=>o.conv2DBackpropFilter(s,n,r.shape,a,l,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sm={kernelName:o.Conv2DBackpropInput,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=t;return{dy:()=>o.conv2d(n,r,i,a,l,1,c),filter:()=>o.conv2DBackpropFilter(n,s,r.shape,i,a,l,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function om(n,e,t,s,r){let i=n;n.rank===4&&(i=o.reshape(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=e;a.rank===4&&(a=o.reshape(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),o.assert(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),o.assert(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),o.assert(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),o.assert(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),o.assert(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const l={x:i,dy:a},c={strides:s,pad:r,filterShape:t};return o.ENGINE.runKernel(o.Conv3DBackpropFilterV2,l,c)}const rm=o.op({conv3DBackpropFilter_:om});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const im={kernelName:o.Conv3D,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;o.assert(o.tupleValuesAreOne(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,l]=e;return{x:()=>o.conv3DBackpropInput(a.shape,n,l,r,i),filter:()=>rm(a,n,l.shape,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const am={kernelName:o.Cos,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(o.neg(o.sin(o.cast(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lm={kernelName:o.Cosh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(o.sinh(o.cast(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cm={kernelName:o.Cumsum,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:a}=t;return{x:()=>{const l=o.getAxesPermutation([r],s.rank);let c=o.cumsum(n,r,i,!a);return l!=null&&(c=o.transpose(c,l)),c}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const um={kernelName:o.DepthwiseConv2dNative,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=t,l=s??[1,1];o.assert(o.tupleValuesAreOne(l),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${l}'`);const[c,u]=e;return o.assert(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),o.assert(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),o.assert(c.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),o.assert(o.eitherStridesOrDilationsAreOne(r,l),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${l}'.`),o.checkPadOnDimRoundingMode("depthwiseConv2d",i,a),{x:()=>o.depthwiseConv2dNativeBackpropInput(c.shape,n,u,r,i,l,a),filter:()=>o.depthwiseConv2dNativeBackpropFilter(c,n,u.shape,r,i,l,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dm={kernelName:o.Dilation2D,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},a={x:s,filter:r,dy:n};return{x:()=>o.ENGINE.runKernel(o.Dilation2DBackpropInput,i,t),filter:()=>o.ENGINE.runKernel(o.Dilation2DBackpropFilter,a,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hm={kernelName:o.Elu,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>o.ENGINE.runKernel(o.EluGrad,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pm={kernelName:o.Erf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=o.mul(o.exp(o.neg(o.square(t))),2/Math.sqrt(Math.PI));return{x:()=>o.mul(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fm={kernelName:o.Exp,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mm={kernelName:o.ExpandDims,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>o.reshape(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gm={kernelName:o.Expm1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(n,o.exp(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xm={kernelName:o.Floor,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bm={kernelName:o.FloorDiv,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=o.assertAndGetBroadcastShape(t.shape,s.shape);return{a:()=>{const l=o.div(n,o.cast(s,"float32")),c=o.getReductionAxes(t.shape,r);return c.length>0?o.reshape(o.sum(l,c),t.shape):l},b:()=>{let l=o.mul(n,o.cast(t,"float32"));const c=o.getReductionAxes(s.shape,r);c.length>0&&(l=o.reshape(o.sum(l,c),s.shape));const u=o.square(s);return o.neg(o.div(l,o.cast(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ym={kernelName:o.FusedBatchNorm,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,a,l]=e,c=l??o.scalar(1),u=o.getReductionAxes(i.shape,r.shape),d=[];if(i.rank===1){for(let C=0;C<r.shape.length-1;++C)d.push(r.shape[C]);d.push(1)}const h=o.sub(r,i),p=o.mul(n,c),f=o.rsqrt(o.add(a,o.scalar(s))),m=o.mul(o.mul(o.mul(f,f),f),o.scalar(-.5));return{x:()=>i.rank===1?o.reshape(o.mul(o.mul(n,o.tile(o.reshape(f,[1,1,1,i.shape[0]]),d)),c),r.shape):o.reshape(o.mul(o.mul(n,f),c),r.shape),mean:()=>{let C=o.mul(o.mul(f,o.scalar(-1)),p);return i.rank===1&&(C=o.sum(C,u)),o.reshape(C,i.shape)},variance:()=>{let C=o.mul(o.mul(m,h),p);return i.rank===1&&(C=o.sum(C,u)),o.reshape(C,i.shape)},scale:()=>{const C=o.mul(h,f);let v=o.mul(n,C);return i.rank===1&&(v=o.sum(v,u)),o.reshape(v,i.shape)},offset:()=>{let C=n;return i.rank===1&&(C=o.sum(C,u)),o.reshape(C,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cm={kernelName:o.GatherV2,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:a}=t,l=o.parseAxisParam(i,s.shape)[0],c=(u,d,h)=>()=>{const p=u.shape,f=d.size,m=p.slice(0,l),g=m.length,x=p.slice(i,p.length).slice(1),b=x.length,y=ja(0,g),w=ja(g+1,g+1+b),C=Ka([m,[f],x]),v=o.reshape(h,C),S=o.reshape(d,[f]),I=Ka([[g],y,w]),k=o.transpose(v,I);let $=o.unsortedSegmentSum(k,S,u.shape[l]);const N=o.getUndoAxesPermutation(I);return $=o.transpose($,N),$};if(a===1){const u=s.shape[0],d=s.split(u,0);return{x:()=>o.stack(d.map((f,m)=>c(f,r.slice(m,1),n.slice(m,1))())).reshape(s.shape),indices:()=>r}}else return{x:c(s,r,n),indices:()=>r}}};function ja(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function Ka(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wm={kernelName:o.GreaterEqual,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>o.zerosLike(t),b:()=>o.zerosLike(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vm={kernelName:o.Identity,gradFunc:n=>({x:()=>o.cast(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sm={kernelName:o.IsFinite,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Im={kernelName:o.IsInf,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const km={kernelName:o.IsNan,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tm={kernelName:o.LeakyRelu,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=o.greater(s,0);return{x:()=>o.where(i,n,o.mul(n,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $m={kernelName:o.Log1p,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.div(n,o.add(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nm={kernelName:o.Log,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.div(n,o.cast(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rm={kernelName:o.LogSoftmax,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const a=o.exp(s);return o.sub(n,o.mul(o.sum(n,r,!0),a))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Am(n,e,t,s=5,r=1,i=1,a=.5){const l={x:n,y:e,dy:t},c={depthRadius:s,bias:r,alpha:i,beta:a};return o.ENGINE.runKernel(o.LRNGrad,l,c)}const Dm=o.op({localResponseNormalizationBackprop_:Am});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Em={kernelName:o.LRN,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:a,alpha:l,beta:c}=t;return{x:()=>Dm(s,r,n,i,a,l,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wc(n,e,t,s){return e.rank<t.rank&&(e=o.reshape(e,o.expandShapeToKeepDim(e.shape,s))),n.rank<t.rank&&(n=o.reshape(n,o.expandShapeToKeepDim(n.shape,s))),{x:()=>o.mul(n,o.cast(o.equal(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ya={kernelName:o.Max,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],a=e[1],l=o.parseAxisParam(r,i.shape),c=Wc(n,a,i,l);return{x:()=>c.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fm={kernelName:o.Maximum,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>o.mul(n,o.cast(o.greaterEqual(t,s),"float32")),b:()=>o.mul(n,o.cast(o.less(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Om(n,e,t,s,r,i,a){const l=o.convertToTensor(n,"dy","maxPool3dGrad"),c=o.convertToTensor(e,"input","maxPool3dGrad"),u=o.convertToTensor(t,"output","maxPool3dGrad");let d=l,h=c,p=u,f=!1;c.rank===4&&(f=!0,d=o.reshape(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=o.reshape(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),p=o.reshape(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),o.assert(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),o.assert(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),o.assert(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),o.checkPadOnDimRoundingMode("maxPool3dGrad",i,a);const m={dy:d,input:h,output:p},g={filterSize:s,strides:r,pad:i,dimRoundingMode:a},x=o.ENGINE.runKernel(o.MaxPool3DGrad,m,g);return f?o.reshape(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}const Lm=o.op({maxPool3dGrad_:Om});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pm={kernelName:o.MaxPool3D,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=t;return{x:()=>Lm(n,s,r,i,a,l,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mm(n,e,t,s,r,i,a){const l=o.convertToTensor(n,"dy","maxPoolGrad"),c=o.convertToTensor(e,"input","maxPoolGrad"),u=o.convertToTensor(t,"output","maxPoolGrad");o.assert(c.rank===l.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${l.rank})`),o.assert(l.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),o.assert(c.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),o.checkPadOnDimRoundingMode("maxPoolGrad",i,a);const d={dy:l,input:c,output:u},h={filterSize:s,strides:r,pad:i,dimRoundingMode:a};return o.ENGINE.runKernel(o.MaxPoolGrad,d,h)}const zm=o.op({maxPoolGrad_:Mm});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _m={kernelName:o.MaxPool,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:l}=t;return{x:()=>zm(n,s,r,i,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bm={kernelName:o.Mean,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=o.parseAxisParam(r,s.shape),l=o.computeOutAndReduceShapes(s.shape,i)[1],c=o.sizeFromShape(l);return{x:()=>{const d=s.shape.slice();i.forEach(f=>{d[f]=1});const h=o.reshape(n,d);return o.div(o.mul(h,o.ones(s.shape,"float32")),c)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vm={kernelName:o.Min,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,a]=e,l=o.parseAxisParam(r,i.shape),c=Wc(n,a,i,l);return{x:()=>c.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wm={kernelName:o.Minimum,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>o.mul(n,o.cast(o.lessEqual(t,s),"float32")),b:()=>o.mul(n,o.cast(o.greater(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gm={kernelName:o.MirrorPad,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>o.slice(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Um={kernelName:o.Mod,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=o.assertAndGetBroadcastShape(t.shape,s.shape);return{a:()=>{const l=o.getReductionAxes(t.shape,r);return l.length>0?o.reshape(o.sum(n,l),t.shape):n},b:()=>{const l=o.mul(n,o.neg(o.floor(o.div(t,s)))),c=o.getReductionAxes(s.shape,r);return c.length>0?o.reshape(o.sum(l,c),s.shape):l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hm={kernelName:o.Multiply,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=o.assertAndGetBroadcastShape(t.shape,s.shape);return{a:()=>{const l=o.mul(n,o.cast(s,"float32")),c=o.getReductionAxes(t.shape,r);return c.length>0?o.reshape(o.sum(l,c),t.shape):l},b:()=>{const l=o.mul(n,o.cast(t,"float32")),c=o.getReductionAxes(s.shape,r);return c.length>0?o.reshape(o.sum(l,c),s.shape):l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qm={kernelName:o.Neg,gradFunc:n=>({x:()=>o.neg(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xm={kernelName:o.OneHot,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>o.zeros(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jm={kernelName:o.OnesLike,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Km={kernelName:o.Pack,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return o.unstack(n,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Za={kernelName:o.PadV2,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>o.slice(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ym={kernelName:o.Pow,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,a=s,l=o.assertAndGetBroadcastShape(i.shape,a.shape);return{a:()=>{const d=o.cast(a,"float32");let h=o.mul(n,o.mul(d,o.pow(i,o.sub(d,o.scalar(1)))));const p=o.getReductionAxes(i.shape,l);return p.length>0&&(h=o.sum(h,p)),o.reshape(h,i.shape)},b:()=>{const d=o.greater(i,0),h=o.where(d,o.log$1(i),o.zerosLike(i));let p=o.mul(n,o.mul(r,h));const f=o.getReductionAxes(a.shape,l);return f.length>0&&(p=o.sum(p,f)),o.reshape(p,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zm={kernelName:o.Prelu,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=o.greater(t,0);return{x:()=>o.where(r,n,o.mul(n,s)),alpha:()=>{let i=o.where(r,o.zerosLike(n),o.mul(n,t));const a=o.getReductionAxes(s.shape,n.shape);return a.length>0&&(i=o.sum(i,a)),o.reshape(i,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qm(n,e,t){const s=n.shape.slice();s[t]=1;const r=o.reshape(e,s),i=o.cumprod(n,t,!0,!1),a=o.cumprod(n,t,!0,!0),l=o.mul(i,a);return o.mul(r,l)}function Jm(n,e,t){const s=n.shape.length,r=s-t.length,i=o.getAxesPermutation(t,s);let a=n;i!=null&&(a=o.transpose(n,i));const l=a.shape.slice(),u=l.splice(s-t.length,t.length).reduce((p,f)=>p*f,1);l.push(u);const d=a.reshape(l);let h=Qm(d,e,r);if(h=h.reshape(a.shape),i!=null){const p=o.getUndoAxesPermutation(i);h=o.transpose(h,p)}return h}const eg={kernelName:o.Prod,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((a,l)=>l):typeof r=="number"?i=[r]:i=r,{x:()=>Jm(s,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tg={kernelName:o.RealDiv,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=o.assertAndGetBroadcastShape(t.shape,s.shape);return{a:()=>{const l=o.div(n,o.cast(s,"float32")),c=o.getReductionAxes(t.shape,r);return c.length>0?o.reshape(o.sum(l,c),t.shape):l},b:()=>{let l=o.mul(n,o.cast(t,"float32"));const c=o.getReductionAxes(s.shape,r);c.length>0&&(l=o.reshape(o.sum(l,c),s.shape));const u=o.square(s);return o.neg(o.div(l,o.cast(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ng={kernelName:o.Reciprocal,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.div(n,o.neg(o.square(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sg={kernelName:o.Relu6,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=o.mul(o.lessEqual(t,6),o.step(t));return{x:()=>o.mul(n,o.cast(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const og={kernelName:o.Relu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(n,o.cast(o.step(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rg={kernelName:o.Reshape,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.reshape(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ig={kernelName:o.ResizeBilinear,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>o.ENGINE.runKernel(o.ResizeBilinearGrad,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ag={kernelName:o.ResizeNearestNeighbor,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>o.ENGINE.runKernel(o.ResizeNearestNeighborGrad,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lg={kernelName:o.Reverse,gradFunc:(n,e,t)=>{const{dims:s}=t,r=o.parseAxisParam(s,n.shape);return{x:()=>o.reverse(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cg={kernelName:o.Round,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ug={kernelName:o.Rsqrt,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.neg(o.div(n,o.mul(o.pow(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dg={kernelName:o.Select,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>o.cast(o.zerosLike(t),"float32"),t:()=>o.mul(n,o.cast(t,n.dtype)),e:()=>o.mul(n,o.cast(o.logicalNot(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hg={kernelName:o.Selu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=o.greater(t,o.scalar(0)),r=o.scalar(co),i=o.scalar(uo),a=o.mul(n,i),l=o.mul(o.mul(n,r),o.exp(o.cast(t,"float32")));return o.where(s,a,l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pg={kernelName:o.Sigmoid,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(n,o.mul(t,o.sub(o.scalar(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fg={kernelName:o.Sign,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mg={kernelName:o.Sin,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(o.cos(o.cast(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gg={kernelName:o.Sinh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(o.cosh(o.cast(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xg={kernelName:o.Slice,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,a=s.shape,[l,c]=ao(s,r,i),u=[];for(let d=0;d<n.rank;d++)u.push([l[d],a[d]-l[d]-c[d]]);return{x:()=>o.pad(n,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bg={kernelName:o.Softmax,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,a=o.mul(n,s);return{logits:()=>o.sub(a,o.mul(o.sum(a,[r],i),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yg={kernelName:o.Softplus,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(n,o.sigmoid(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qa={kernelName:o.SpaceToBatchND,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>o.batchToSpaceND(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ja={kernelName:o.SplitV,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>o.concat(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cg={kernelName:o.Sqrt,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.div(n,o.mul(o.sqrt(o.cast(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wg={kernelName:o.Square,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(n,o.mul(o.cast(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vg={kernelName:o.SquaredDifference,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=o.scalar(2);return{a:()=>o.mul(n,o.mul(r,o.sub(t,s))),b:()=>o.mul(n,o.mul(r,o.sub(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sg={kernelName:o.Step,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ig={kernelName:o.Sub,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=o.assertAndGetBroadcastShape(t.shape,s.shape);return{a:()=>{let l=n;const c=o.getReductionAxes(t.shape,r);return c.length>0&&(l=o.sum(l,c)),o.reshape(l,t.shape)},b:()=>{let l=n;const c=o.getReductionAxes(s.shape,r);return c.length>0&&(l=o.sum(l,c)),o.reshape(o.neg(l),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kg={kernelName:o.Sum,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;o.parseAxisParam(i,s.shape).forEach(u=>{r[u]=1});const l=o.reshape(n,r),c=o.mul(l,o.ones(s.shape,"float32"));return{x:()=>c}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tg={kernelName:o.Tan,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.div(n,o.square(o.cos(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $g={kernelName:o.Tanh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o.mul(o.sub(o.scalar(1),o.square(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ng={kernelName:o.Tile,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let a=o.zerosLike(s);if(s.rank===1)for(let l=0;l<r[0];++l)a=o.add(a,o.slice(n,[l*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)a=o.add(a,o.slice(n,[l*s.shape[0],c*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)for(let u=0;u<r[2];++u)a=o.add(a,o.slice(n,[l*s.shape[0],c*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)for(let u=0;u<r[2];++u)for(let d=0;d<r[3];++d)a=o.add(a,o.slice(n,[l*s.shape[0],c*s.shape[1],u*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rg={kernelName:o.Transpose,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=o.getUndoAxesPermutation(r);return{x:()=>o.transpose(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ag={kernelName:o.Unpack,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>o.stack(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dg={kernelName:o.UnsortedSegmentSum,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Eg(n,t)}}};function Eg(n,e){const t=o.maximum(e,o.zerosLike(e)),s=o.gather(n,t);let r=o.greaterEqual(e,o.scalar(0,"int32"));const i=s.rank-r.rank;for(let l=0;l<i;++l)r=o.expandDims(r,l+1);r=o.logicalAnd(r,o.ones(s.shape,"bool"));const a=o.zerosLike(s);return o.where(r,s,a)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fg={kernelName:o.ZerosLike,gradFunc:n=>({x:()=>o.zerosLike(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Og=[Vc,Df,Ef,Ff,Of,Lf,Pf,Mf,zf,_f,Bf,Vf,Uf,Xf,jf,Kf,Yf,Zf,Qf,Jf,em,tm,sm,nm,im,am,lm,cm,um,dm,tg,hm,pm,fm,mm,gm,bm,xm,ym,Cm,wm,vm,Sm,Im,km,Tm,$m,Nm,Rm,Em,Ya,Ya,Fm,Pm,_m,Bm,Vm,Wm,Gm,Um,Hm,qm,Xm,jm,Km,Za,Za,Ym,Zm,eg,ng,sg,og,rg,ig,ag,lg,cg,ug,dg,hg,pg,fg,mg,gg,xg,bg,yg,Qa,Qa,Ja,Ja,Cg,vg,wg,Sg,Ig,kg,Tg,$g,Ng,Rg,Ag,Dg,Fg];for(const n of Og)o.registerGradient(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.abs=function(){return this.throwIfDisposed(),o.abs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.acos=function(){return this.throwIfDisposed(),o.acos(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.acosh=function(){return this.throwIfDisposed(),o.acosh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.add=function(n){return this.throwIfDisposed(),o.add(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.all=function(n,e){return this.throwIfDisposed(),o.all(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.any=function(n,e){return this.throwIfDisposed(),o.any(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.argMax=function(n){return this.throwIfDisposed(),o.argMax(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.argMin=function(n){return this.throwIfDisposed(),o.argMin(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.asScalar=function(){return this.throwIfDisposed(),o.assert(this.size===1,()=>"The array must have only 1 element."),o.reshape(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.asType=function(n){return this.throwIfDisposed(),o.cast(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.as1D=function(){return this.throwIfDisposed(),o.reshape(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.as2D=function(n,e){return this.throwIfDisposed(),o.reshape(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),o.reshape(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),o.reshape(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),o.reshape(this,[n,e,t,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.asin=function(){return this.throwIfDisposed(),o.asin(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.asinh=function(){return this.throwIfDisposed(),o.asinh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.atan=function(){return this.throwIfDisposed(),o.atan(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.atan2=function(n){return this.throwIfDisposed(),o.atan2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.atanh=function(){return this.throwIfDisposed(),o.atanh(this)};o.getGlobalTensorClass().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),o.avgPool(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),o.batchToSpaceND(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),o.batchNorm(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.broadcastTo=function(n){return this.throwIfDisposed(),o.broadcastTo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.cast=function(n){return this.throwIfDisposed(),o.cast(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.ceil=function(){return this.throwIfDisposed(),o.ceil(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),o.clipByValue(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof o.Tensor&&(n=[n]),o.concat([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),o.conv1d(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),o.conv2dTranspose(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),o.conv2d(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.cos=function(){return this.throwIfDisposed(),o.cos(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.cosh=function(){return this.throwIfDisposed(),o.cosh(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),o.cumprod(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),o.cumsum(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),o.depthToSpace(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),o.depthwiseConv2d(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),o.dilation2d(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.divNoNan=function(n){return this.throwIfDisposed(),o.divNoNan(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.div=function(n){return this.throwIfDisposed(),o.div(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.dot=function(n){return this.throwIfDisposed(),o.dot(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.elu=function(){return this.throwIfDisposed(),o.elu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.equal=function(n){return this.throwIfDisposed(),o.equal(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.erf=function(){return this.throwIfDisposed(),o.erf(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),o.euclideanNorm(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.exp=function(){return this.throwIfDisposed(),o.exp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.expandDims=function(n){return this.throwIfDisposed(),o.expandDims(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.expm1=function(){return this.throwIfDisposed(),o.expm1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.fft=function(){return this.throwIfDisposed(),o.fft(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.flatten=function(){return this.throwIfDisposed(),o.reshape(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.floor=function(){return this.throwIfDisposed(),o.floor(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.floorDiv=function(n){return this.throwIfDisposed(),o.floorDiv(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.gather=function(n,e,t){return this.throwIfDisposed(),o.gather(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.greaterEqual=function(n){return this.throwIfDisposed(),o.greaterEqual(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.greater=function(n){return this.throwIfDisposed(),o.greater(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.ifft=function(){return this.throwIfDisposed(),o.ifft(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.irfft=function(){return this.throwIfDisposed(),o.irfft(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.isFinite=function(){return this.throwIfDisposed(),o.isFinite(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.isInf=function(){return this.throwIfDisposed(),o.isInf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.isNaN=function(){return this.throwIfDisposed(),o.isNaN(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.leakyRelu=function(n){return this.throwIfDisposed(),o.leakyRelu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.lessEqual=function(n){return this.throwIfDisposed(),o.lessEqual(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.less=function(n){return this.throwIfDisposed(),o.less(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),o.localResponseNormalization(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.logSigmoid=function(){return this.throwIfDisposed(),o.logSigmoid(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.logSoftmax=function(n){return this.throwIfDisposed(),o.logSoftmax(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),o.logSumExp(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.log=function(){return this.throwIfDisposed(),o.log$1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.log1p=function(){return this.throwIfDisposed(),o.log1p(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.logicalAnd=function(n){return this.throwIfDisposed(),o.logicalAnd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.logicalNot=function(){return this.throwIfDisposed(),o.logicalNot(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.logicalOr=function(n){return this.throwIfDisposed(),o.logicalOr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.logicalXor=function(n){return this.throwIfDisposed(),o.logicalXor(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),o.matMul(this,n,e,t)};o.getGlobalTensorClass().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),o.maxPool(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.max=function(n,e){return this.throwIfDisposed(),o.max(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.maximum=function(n){return this.throwIfDisposed(),o.maximum(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.mean=function(n,e){return this.throwIfDisposed(),o.mean(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.min=function(n,e){return this.throwIfDisposed(),o.min(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.minimum=function(n){return this.throwIfDisposed(),o.minimum(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),o.mirrorPad(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.mod=function(n){return this.throwIfDisposed(),o.mod(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.mul=function(n){return this.throwIfDisposed(),o.mul(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.neg=function(){return this.throwIfDisposed(),o.neg(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.norm=function(n,e,t){return this.throwIfDisposed(),o.norm(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.notEqual=function(n){return this.throwIfDisposed(),o.notEqual(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),o.oneHot(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.onesLike=function(){return this.throwIfDisposed(),o.onesLike(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.pad=function(n,e){return this.throwIfDisposed(),o.pad(this,n,e)};o.getGlobalTensorClass().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),o.pool(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.pow=function(n){return this.throwIfDisposed(),o.pow(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.prelu=function(n){return this.throwIfDisposed(),o.prelu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.prod=function(n,e){return this.throwIfDisposed(),o.prod(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.reciprocal=function(){return this.throwIfDisposed(),o.reciprocal(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.relu=function(){return this.throwIfDisposed(),o.relu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.relu6=function(){return this.throwIfDisposed(),o.relu6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.reshapeAs=function(n){return this.throwIfDisposed(),o.reshape(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.reshape=function(n){return this.throwIfDisposed(),o.reshape(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),o.resizeBilinear(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),o.resizeNearestNeighbor(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.reverse=function(n){return this.throwIfDisposed(),o.reverse(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.rfft=function(){return this.throwIfDisposed(),o.rfft(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.round=function(){return this.throwIfDisposed(),o.round(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.rsqrt=function(){return this.throwIfDisposed(),o.rsqrt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.selu=function(){return this.throwIfDisposed(),o.selu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),o.separableConv2d(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.sigmoid=function(){return this.throwIfDisposed(),o.sigmoid(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.sign=function(){return this.throwIfDisposed(),o.sign(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.sin=function(){return this.throwIfDisposed(),o.sin(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.sinh=function(){return this.throwIfDisposed(),o.sinh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.slice=function(n,e){return this.throwIfDisposed(),o.slice(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.softmax=function(n){return this.throwIfDisposed(),o.softmax(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.softplus=function(){return this.throwIfDisposed(),o.softplus(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),o.spaceToBatchND(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.split=function(n,e){return this.throwIfDisposed(),o.split(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.sqrt=function(){return this.throwIfDisposed(),o.sqrt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.square=function(){return this.throwIfDisposed(),o.square(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.squaredDifference=function(n){return this.throwIfDisposed(),o.squaredDifference(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.squeeze=function(n){return this.throwIfDisposed(),o.squeeze(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof o.Tensor?[this,n]:[this,...n];return o.stack(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.step=function(n){return this.throwIfDisposed(),o.step(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.stridedSlice=function(n,e,t,s,r,i,a,l){return this.throwIfDisposed(),o.stridedSlice(this,n,e,t,s,r,i,a,l)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.sub=function(n){return this.throwIfDisposed(),o.sub(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.sum=function(n,e){return this.throwIfDisposed(),o.sum(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.tan=function(){return this.throwIfDisposed(),o.tan(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.tanh=function(){return this.throwIfDisposed(),o.tanh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.tile=function(n){return this.throwIfDisposed(),o.tile(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.toBool=function(){return this.throwIfDisposed(),o.cast(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.toFloat=function(){return this.throwIfDisposed(),o.cast(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.toInt=function(){return this.throwIfDisposed(),o.cast(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.topk=function(n,e){return this.throwIfDisposed(),o.topk(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.transpose=function(n){return this.throwIfDisposed(),o.transpose(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.unique=function(n){return this.throwIfDisposed(),o.unique(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),o.unsortedSegmentSum(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.unstack=function(n){return this.throwIfDisposed(),o.unstack(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.where=function(n,e){return this.throwIfDisposed(),o.where(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.getGlobalTensorClass().prototype.zerosLike=function(){return this.throwIfDisposed(),o.zerosLike(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class dt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,dt.prototype)}}class Ye extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ye.prototype)}}class T extends Error{constructor(e){super(e),Object.setPrototypeOf(this,T.prototype)}}class J extends Error{constructor(e){super(e),Object.setPrototypeOf(this,J.prototype)}}class Gr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Gr.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Gc{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jt(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function ht(n,e){if(!n)throw new Gr(e)}function el(n,e){let t=0;for(const s of n)s===e&&t++;return t}function Me(n){return n.length===1?n[0]:n}function ie(n){return Array.isArray(n)?n:[n]}function vt(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function jt(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let je={};function Ur(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function Qo(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>Qo(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:Qo(s))}}}function as(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let a;if(i in t)a=t[i];else if(i in je)a=je[i];else if(a=e[i],a==null)throw new T(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const i=n;if(i.className==null||i.config==null)throw new T(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const a=i.className;let l,c;if(a in t?[l,c]=t[a]:a in je?[l,c]=je.className:a in e&&([l,c]=e[a]),l==null)throw new T(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(c!=null){const u={};for(const f of Object.keys(je))u[f]=je[f];for(const f of Object.keys(t))u[f]=t[f];const d=i.config;d.customObjects=u;const h=Object.assign({},je);for(const f of Object.keys(t))je[f]=t[f];Qo(i.config);const p=c(l,i.config,t,r);return je=Object.assign({},h),p}else{const u=Object.assign({},je);for(const h of Object.keys(t))je[h]=t[h];const d=new l(i.config);return je=Object.assign({},u),d}}}function Lg(n,e){return n<e?-1:n>e?1:0}function Is(n,e){return-1*Lg(n,e)}function Pt(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function Pg(n){if(n==null)throw new T(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function an(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new T(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function Hr(n,e,t=0,s=1/0){return ht(t>=0),ht(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function $e(n,e){Array.isArray(n)?(o.assert(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>$e(t,`element ${s+1} of ${e}`))):o.assert(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${Uc(n)}.`)}function Uc(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>Uc(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function Mg(n,e,t){let s=t!=null?t():o.now(),r;return(...a)=>{const l=t!=null?t():o.now();return l-s<e||(s=l,r=n(...a)),r}}function Hc(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let zg=0;function qc(){return zg++}const ks={};function ho(n=""){return n in ks||(ks[n]=0),ks[n]+=1,n+ks[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const _g=["channelsFirst","channelsLast"],Bg=["nearest","bilinear"],Vg=["valid","same","causal"],Wg=["max","avg"],Gg=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const fn=new Map;function Ce(n){an(_g,"DataFormat",n)}function Ug(n){an(Bg,"InterpolationFormat",n)}function Xe(n){an(Vg,"PaddingMode",n)}function Xc(n){an(Wg,"PoolMode",n)}const Kn=[],tl="/";function Zt(n,e){Kn.push(n);try{const t=e();return Kn.pop(),t}catch(t){throw Kn.pop(),t}}function Hg(){return Kn.length===0?"":Kn.join(tl)+tl}function jc(n){if(!Yc(n))throw new Error("Not a valid tensor name: '"+n+"'");return Hg()+n}function Kc(n){if(!Yc(n))throw new Error("Not a valid tensor name: '"+n+"'");fn.has(n)||fn.set(n,0);const e=fn.get(n);if(fn.set(n,fn.get(n)+1),e>0){const t=`${n}_${e}`;return fn.set(t,1),t}else return n}const qg=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Yc(n){return!!n.match(qg)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Xg(n){return n===parseInt(n.toString(),10)}function Mt(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function xn(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function zt(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function rt(n,e){if(e<n)throw new T(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Vo;function Se(){return Vo==null&&(Vo=o.backend().epsilon()),Vo}function it(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gt(n,e){return o.cast(n,e)}function ls(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),o.reshape(n,t)}function jg(n,e){return o.tidy(()=>{if(n.shape.length!==2)throw new T(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=ls(n,1);return Jo(t,[1,e,1])})}function Kg(n){const e=[Mt(n.shape)];return o.reshape(n,e)}function Yg(n){if(n.rank<=1)throw new T(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Mt(n.shape,1)];return o.reshape(n,e)}function Qt(n,e,t){return o.tidy(()=>{switch(n.rank){case 1:return o.slice1d(n,e,t);case 2:return o.slice2d(n,[e,0],[t,n.shape[1]]);case 3:return o.slice3d(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return o.slice4d(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return o.slice(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return o.slice(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new T(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Wo(n,e,t){return o.tidy(()=>{switch(n.rank){case 1:return o.slice1d(n,e,t);case 2:return o.slice2d(n,[0,e],[n.shape[0],t]);case 3:return o.slice3d(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return o.slice4d(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new T(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ts(n,e,t,s){return o.tidy(()=>{switch(n.rank){case 1:return o.slice1d(n,e,t);case 2:switch(s){case 1:return Qt(n,e,t);case 2:return Wo(n,e,t);default:throw new T(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Qt(n,e,t);case 2:return o.slice3d(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Wo(n,e,t);default:throw new T(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Qt(n,e,t);case 2:return o.slice4d(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return o.slice4d(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Wo(n,e,t);default:throw new T(`The axis is not within the rank of the tensor ${s}`)}default:throw new T(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function qr(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),o.concat(n,e)}function nl(n,e){switch(n.rank){case 1:return o.concat1d([n,e]);case 2:return o.concat2d([n,e],0);case 3:return o.concat3d([n,e],0);case 4:return o.concat4d([n,e],0);default:throw new T(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Jo(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new T(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return o.tile(n,e)}function po(n,e=0,t=1,s,r){return o.randomNormal(n,e,t,s,r)}function xt(n,e,t,s){if(n.rank<2||e.rank<2)throw new J(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new J(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return o.matMul$1({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?er(n.rank,s,it()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=o.reshape(n,[-1,i]);const a=e.shape.slice(),l=a.pop(),c=a.pop(),u=[...a,l],d=Array.from({length:e.rank},(m,g)=>g===0?e.rank-2:g<=e.rank-2?g-1:g);e=o.reshape(o.transpose(e,d),[c,-1]);const h=[...r,...u];return o.reshape(o.matMul$1({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?er(n.rank,s,it()):null,activation:t}),h)}}function Zc(n,e,t){return o.tidy(()=>(Array.isArray(e)?e=o.tensor1d(e,"int32"):e=o.cast(e,"int32"),o.gather(n,e,t)))}function cs(n){return o.mul(n,n)}function er(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new T(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?o.reshape(e,[1,s[0],1,1,1]):o.reshape(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?o.reshape(e,[1,1,1,1,s[0]]):o.reshape(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?o.reshape(e,[1,s[0],1,1]):o.reshape(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?o.reshape(e,[1,1,1,s[0]]):o.reshape(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?o.reshape(e,[1,s[0],1]):o.reshape(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?o.reshape(e,[1,1,s[0]]):o.reshape(e,[1].concat(s))}else if(n<3)return e;throw new T(`Unsupported input rank by biasAdd: ${e.rank}`)}function ct(n,e,t){return o.tidy(()=>(t==null&&(t=it()),Ce(t),o.add(n,er(n.rank,e,t))))}function Zg(n,e=1){if(e!==1)throw new J(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return o.elu(n)}function Qg(n){return o.tidy(()=>o.div(n,o.add(o.abs(n),1)))}function Qc(n,e,t,s){return o.tidy(()=>o.dropout(n,e,t,s))}function Jg(n){return o.tidy(()=>{const e=o.add(.5,o.mul(.2,n));return o.clipByValue(e,0,1)})}function us(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ex=["fanIn","fanOut","fanAvg"],tx=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nx(n){an(ex,"FanMode",n)}function sx(n){an(tx,"Distribution",n)}class Ze extends o.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Xr extends Ze{apply(e,t){return o.zeros(e,t)}}Xr.className="Zeros";o.registerClass(Xr);class fo extends Ze{apply(e,t){return o.ones(e,t)}}fo.className="Ones";o.registerClass(fo);class jr extends Ze{constructor(e){if(super(),typeof e!="object")throw new T(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new T(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return o.tidy(()=>o.mul(o.scalar(this.value),o.ones(e,t)))}getConfig(){return{value:this.value}}}jr.className="Constant";o.registerClass(jr);class Kr extends Ze{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return o.randomUniform(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Kr.className="RandomUniform";o.registerClass(Kr);class Yr extends Ze{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new J(`randomNormal does not support dType ${t}.`);return po(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Yr.className="RandomNormal";o.registerClass(Yr);class Zr extends Ze{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new J(`truncatedNormal does not support dType ${t}.`);return o.truncatedNormal(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Zr.className="TruncatedNormal";o.registerClass(Zr);class Qr extends Ze{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return o.tidy(()=>{if(e.length!==2||e[0]!==e[1])throw new T("Identity matrix initializer can only be used for 2D square matrices.");return o.mul(this.gain,o.eye(e[0]))})}getConfig(){return{gain:this.gain}}}Qr.className="Identity";o.registerClass(Qr);function ox(n,e="channelsLast"){let t,s;if(Ce(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=Mt(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=Mt(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Mt(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class ze extends Ze{constructor(e){if(super(),e.scale<0)throw new T(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,nx(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,sx(this.distribution),this.seed=e.seed}apply(e,t){const s=ox(e),r=s[0],i=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),this.distribution==="normal"){const l=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new J(`${this.getClassName()} does not support dType ${t}.`);return o.truncatedNormal(e,0,l,t,this.seed)}else{const l=Math.sqrt(3*a);return o.randomUniform(e,-l,l,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}ze.className="VarianceScaling";o.registerClass(ze);class mo extends ze{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ze.className}}mo.className="GlorotUniform";o.registerClass(mo);class go extends ze{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ze.className}}go.className="GlorotNormal";o.registerClass(go);class xo extends ze{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ze.className}}xo.className="HeNormal";o.registerClass(xo);class bo extends ze{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ze.className}}bo.className="HeUniform";o.registerClass(bo);class yo extends ze{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ze.className}}yo.className="LeCunNormal";o.registerClass(yo);class Co extends ze{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ze.className}}Co.className="LeCunUniform";o.registerClass(Co);class Jr extends Ze{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return o.tidy(()=>{if(e.length<2)throw new J("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=o.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const a=[Math.max(r,s),Math.min(r,s)],l=po(a,0,1,t,this.seed),c=o.linalg.qr(l,!1);let u=c[0];const h=c[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return u=o.mul(u,h.sign()),s<r&&(u=u.transpose()),o.mul(o.scalar(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Jr.className="Orthogonal";o.registerClass(Jr);const sl={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function ol(n,e={}){return as(n,o.SerializationMap.getMap().classNameMap,e,"initializer")}function be(n){return Ur(n)}function me(n){if(typeof n=="string"){const e=n in sl?sl[n]:n;if(e==="GlorotNormal")return new go;if(e==="GlorotUniform")return new mo;if(e==="HeNormal")return new xo;if(e==="HeUniform")return new bo;if(e==="LeCunNormal")return new yo;if(e==="LeCunUniform")return new Co;{const t={};return t.className=e,t.config={},ol(t)}}else return n instanceof Ze?n:ol(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tr(n){return Array.isArray(n)&&Array.isArray(n[0])}function Ws(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Q(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new T(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function oe(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new T(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gs(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const rl="Variable";class Jc{constructor(e,t="float32",s=rl,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=qc(),s=s??rl,this.originalName=jc(s),this.name=Kc(this.originalName),this.trainable_=r,this.constraint=i,this.val=o.variable(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),rx(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function rx(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function nr(n){return n.map(e=>e.read())}function ei(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ve{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class at{constructor(e,t,s,r,i,a,l){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=l,this.id=qc(),a!=null&&(this.originalName=jc(a),this.name=Kc(this.originalName)),this.rank=t.length}}let ix=0;class wo{constructor(e,t){this.callArgs=t,this.id=ix++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ax=0;class ne extends o.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ax++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=vt(s)+"_"+ho(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Ye(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new T(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Me(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Me(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new dt(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new dt(`Layer ${this.name} is not connected, no input to return.`);return Me(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new dt(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new dt(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Me(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=ie(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=ie(this.inputSpec);if(t.length!==s.length)throw new T(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],a=s[r];if(a==null)continue;const l=i.rank;if(a.ndim!=null&&l!==a.ndim)throw new T(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${l}`);if(a.maxNDim!=null&&l>a.maxNDim)throw new T(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${l}`);if(a.minNDim!=null&&l<a.minNDim)throw new T(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${l}.`);if(a.dtype!=null&&i.dtype!==a.dtype)throw new T(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${i.dtype}.`);if(a.axes){const c=i.shape;for(const u in a.axes){const d=Number(u),h=a.axes[u],p=d>=0?c[d]:c[c.length+d];if(h!=null&&[h,null].indexOf(p)===-1)throw new T(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${h} but got shape ${c}.`)}}if(a.shape!=null)for(let c=0;c<a.shape.length;++c){const u=a.shape[c],d=i.shape[c];if(u!=null&&d!=null&&u!==d)throw new T(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=ie(e),r=ux(e),i=dx(e);if(r===i)throw new T("Arguments to apply() must be all SymbolicTensors or all Tensors");return Zt(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const l of ie(e))a.push(l.shape);this.build(Me(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const l=ie(a),c=[];for(let u of l)s.indexOf(u)!==-1&&(u=u.clone()),c.push(u);if(a=Me(c),this.activityRegularizer!=null)throw new J("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=lx(e),l=this.computeOutputShape(a);let c;const u=cx(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),l!=null&&l.length>0&&Array.isArray(l[0])?c=l.map((d,h)=>new at(u,d,this,ie(e),t,this.name,h)):c=new at(u,l,this,ie(e),t,this.name),this.addInboundNode(e,c,null,null,a,l,t),this._refCount++,this.activityRegularizer!=null)throw new J("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new dt(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new dt(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ye(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Gs(this.weights)}build(e){this.built=!0}getWeights(e=!1){return nr(e?this.trainableWeights:this.weights)}setWeights(e){o.tidy(()=>{const t=this.weights;if(t.length!==e.length)throw new T(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=nr(t);for(let i=0;i<r.length;++i){const a=r[i],l=t[i],c=e[i];if(!o.arraysEqual(a.shape,c.shape))throw new T(`Layer weight shape ${a.shape} not compatible with provided weight shape ${c.shape}`);s.push([l,c])}ei(s)})}addWeight(e,t,s,r,i,a,l,c){if(this._addedWeightNames.indexOf(e)!==-1)throw new T(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=c!=null?c():me("zeros"));const u=r.apply(t,s),d=new Jc(u,s,e,a,l);return u.dispose(),i!=null&&this.addLoss(()=>i.apply(d.read())),a==null&&(a=!0),a?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=ie(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=ie(t),a=ie(r);if(i.length!==a.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let l=0;l<i.length;l++)i[l].kerasMask=a[l]}addInboundNode(e,t,s,r,i,a,l=null){const c=ie(e);t=ie(t),s=ie(s),r=ie(r),i=Ws(i),a=Ws(a);const u=[],d=[],h=[];for(const p of c)u.push(p.sourceLayer),d.push(p.nodeIndex),h.push(p.tensorIndex);new wo({outboundLayer:this,inboundLayers:u,nodeIndices:d,tensorIndices:h,inputTensors:c,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:a},l);for(let p=0;p<t.length;p++)t[p].sourceLayer=this,t[p].nodeIndex=this.inboundNodes.length-1,t[p].tensorIndex=p}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function lx(n){n=ie(n);const e=[];for(const t of n)e.push(t.shape);return Me(e)}function cx(n){return"float32"}function eu(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const a=s.inputTensors[i],l=s.inboundLayers[i],c=s.nodeIndices[i],u=eu(a,l,c);for(const d of u)r.indexOf(d)===-1&&r.push(d)}return r}}}function ux(n){let e=!0;for(const t of ie(n))if(!(t instanceof at)){e=!1;break}return e}function dx(n){let e=!0;for(const t of ie(n))if(t instanceof at){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Sn extends ne{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:ho("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new T("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new T("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new T("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new at(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new wo({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new T(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Sn.className="InputLayer";o.registerClass(Sn);function tu(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new T("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new Sn({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hx(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return o.cast(e,n.dtype)}catch{throw new T(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Ft{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Ft)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=hx(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new T(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof at){if(this.id2Value[e.id]==null)throw new T(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new T(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof at){if(this.id2Value[e.id]==null)throw new T(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new T(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&o.dispose(this.id2Mask)}}const Us=new Gc,Hs=new Gc;function px(n){Us?.setMaxEntries(n),Hs?.setMaxEntries(n)}function Wn(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),a=i?n:[n],l=a.map(m=>m.name),c=[],u=e.names();for(const m of l)u.indexOf(m)!==-1?c.push(e.getValue(m)):c.push(null);const d=l.join(",")+"|"+e.names().sort().join(",");let h=Us.get(d),p;if(h==null){const m=fx(a,e);h=m.sorted,p=m.recipientCounts,Us.put(d,h),Hs.put(d,p)}p={},r||Object.assign(p,Hs.get(d));const f=new Ft(e);for(let m=0;m<h.length;++m){const g=h[m],x=g.sourceLayer;if(x instanceof Sn)continue;const b=[],y=[],w=[];let C=!1;for(const $ of g.inputs){const N=f.getValue($),R=f.getMask($);b.push(N),y.push(R),R!=null&&(C=!0),r||(p[$.name]--,p[$.name]===0&&!e.hasKey($)&&l.indexOf($.name)===-1&&!N.isDisposed&&$.sourceLayer.stateful!==!0&&w.push(N))}C&&(t=t||{},t.mask=y[0]);const v=ie(x.apply(b,t));let S=null;x.supportsMasking&&(S=x.computeMask(b,y));const I=gx(g),k=Array.isArray(I)?I:[I];for(let $=0;$<k.length;++$){f.hasKey(k[$])||f.add(k[$],v[$],Array.isArray(S)?S[0]:S);const N=l.indexOf(k[$].name);N!==-1&&(c[N]=v[$])}r||o.dispose(w)}return f.disposeMasks(),i?c:c[0]}function fx(n,e){o.assert(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=il(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:a,recipientMap:l}=il(i,e);for(const c of a)r.has(c.name)||(t.push(c),r.add(c.name));for(const c in l)s[c]==null&&(s[c]=new Set),l[c].forEach(u=>s[c].add(u))}}return{sorted:t,recipientCounts:mx(s)}}function mx(n){const e={};for(const t in n)e[t]=n[t].size;return e}function il(n,e){const t=new Set,s=[],r={};for(const l of e.names())t.add(l);const i=[],a=[];for(i.push(n);i.length>0;){const l=i[i.length-1];if(t.has(l.name)){i.pop();continue}const c=a[a.length-1]===i.length-1;if(l.inputs.length===0||c)i.pop(),s.push(l),t.add(l.name),c&&a.pop();else{a.push(i.length-1);for(const u of l.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(l.name),!t.has(u.name)&&i.push(u)}}return{sorted:s,recipientMap:r}}function gx(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xx=o.env();xx.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,px);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ti(n,e){return o.tidy(()=>o.sqrt(o.sum(o.mul(n,n),e,!0)))}class ds extends o.Serializable{getConfig(){return{}}}class ni extends ds{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return o.tidy(()=>{const t=ti(e,this.axis),s=o.clipByValue(t,0,this.maxValue);return o.mul(e,o.div(s,o.add(Se(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}ni.className="MaxNorm";o.registerClass(ni);class si extends ds{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return o.tidy(()=>o.div(e,o.add(Se(),ti(e,this.axis))))}getConfig(){return{axis:this.axis}}}si.className="UnitNorm";o.registerClass(si);class oi extends ds{apply(e){return o.relu(e)}}oi.className="NonNeg";o.registerClass(oi);class ri extends ds{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return o.tidy(()=>{const t=ti(e,this.axis),s=o.add(o.mul(this.rate,o.clipByValue(t,this.minValue,this.maxValue)),o.mul(1-this.rate,t));return o.mul(e,o.div(s,o.add(Se(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}ri.className="MinMaxNorm";o.registerClass(ri);const al={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ie(n){return Ur(n)}function ll(n,e={}){return as(n,o.SerializationMap.getMap().classNameMap,e,"constraint")}function ke(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in al?al[n]:n,config:{}};return ll(t)}else return n instanceof ds?n:ll(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bx(n){return new ni(n)}function yx(n){return new si(n)}function Cx(){return new oi}function wx(n){return new ri(n)}const vx=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:bx,minMaxNorm:wx,nonNeg:Cx,unitNorm:yx},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Sx(){return new Xr}function Ix(){return new fo}function kx(n){return new jr(n)}function Tx(n){return new Kr(n)}function $x(n){return new Yr(n)}function Nx(n){return new Zr(n)}function Rx(n){return new Qr(n)}function Ax(n){return new ze(n)}function Dx(n){return new mo(n)}function Ex(n){return new go(n)}function Fx(n){return new xo(n)}function Ox(n){return new bo(n)}function Lx(n){return new yo(n)}function Px(n){return new Co(n)}function Mx(n){return new Jr(n)}const zx=Object.freeze(Object.defineProperty({__proto__:null,constant:kx,glorotNormal:Ex,glorotUniform:Dx,heNormal:Fx,heUniform:Ox,identity:Rx,leCunNormal:Lx,leCunUniform:Px,ones:Ix,orthogonal:Mx,randomNormal:$x,randomUniform:Tx,truncatedNormal:Nx,varianceScaling:Ax,zeros:Sx},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Dt(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const a=i;e.push(a.data()),t.push(r),s.push(a)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];o.dispose(s)}}function nu(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var cl;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(cl||(cl={}));const _x=125;class bn{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class su{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Bx extends bn{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;const l=o.tidy(()=>o.add(this.totals[r],o.mul(i,s)));this.totals[r]=l,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:o.tidy(()=>{const r=o.mul(o.div(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),o.keep(t[s])}))}}class ou extends bn{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const a=this.history[i];for(let l=0;l<a.length;++l)if(typeof a[l]!="number"){const c=a[l];e.push(c.data()),t.push(i),s.push(l)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class ru extends bn{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Sr,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=_x),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");o.isNumber(this.yieldEvery)&&(this.maybeWait=Mg(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await Dt(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Dt(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await Dt(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Dt(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await Dt(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):o.isNumber(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Dt(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Dt(e),await this.trainEnd(e))}}function iu(n,e){return n==null&&(n={}),n instanceof bn?[n]:Array.isArray(n)&&n[0]instanceof bn?n:ie(n).map(s=>new ru(s,e))}class Ue{constructor(){}static registerCallbackConstructor(e,t){o.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Ue.checkForDuplicate(t),Ue.constructors[e]==null&&(Ue.constructors[e]=[]),Ue.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Ue.constructors)Ue.constructors[+t].forEach(r=>{if(r===e)throw new T("Duplicate callback constructor.")})}static clear(){Ue.constructors={}}static createCallbacks(e){const t=[];for(const s in Ue.constructors){const r=+s;e>=r&&t.push(...Ue.constructors[r])}return t.map(s=>new s)}}Ue.constructors={};function au(n,e,t,s,r,i,a,l,c){const u=new ou,d=[new Bx,...Ue.createCallbacks(e)];n!=null&&d.push(...n),d.push(u);const h=new su(d);return h.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:e,doValidation:l,metrics:c}),{callbackList:h,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function st(n,e={},t=!1){return as(n,o.SerializationMap.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qs(n,e){return o.tidy(()=>{n.dtype!=="float32"&&(n=o.cast(n,"float32"));const t=o.sum(cs(n),e,!0),s=o.fill(t.shape,Se()),r=o.sqrt(o.maximum(t,s));return o.div(n,r)})}function ln(n,e){return o.tidy(()=>o.mean(cs(o.sub(e,n)),-1))}function vo(n,e){return o.tidy(()=>o.mean(o.abs(o.sub(e,n)),-1))}function In(n,e){return o.tidy(()=>{const t=o.sub(n,e),s=o.clipByValue(o.abs(n),Se(),Number.MAX_VALUE),r=o.abs(o.div(t,s));return o.mul(100,o.mean(r,-1))})}function Vx(n,e){return o.tidy(()=>{const t=o.clipByValue(e,Se(),Number.MAX_VALUE),s=o.log$1(o.add(1,t)),r=o.clipByValue(n,Se(),Number.MAX_VALUE),i=o.log$1(o.add(1,r));return o.mean(cs(o.sub(s,i)),-1)})}function Wx(n,e){return o.tidy(()=>{const t=o.maximum(0,o.sub(1,o.mul(n,e)));return o.mean(cs(t),-1)})}function Gx(n,e){return o.tidy(()=>{const t=o.maximum(0,o.sub(1,o.mul(n,e)));return o.mean(t,-1)})}function Ux(n,e){return o.tidy(()=>{const t=o.sum(o.mul(n,e),-1),s=o.max(o.mul(o.sub(1,n),e),-1);return o.maximum(0,o.add(1,o.sub(s,t)))})}function Hx(n,e){return o.tidy(()=>{const t=Math.log(2),s=o.sub(e,n),r=o.sub(o.add(s,o.softplus(o.mul(-2,s))),t);return o.mean(r,-1)})}function Yn(n,e,t=!1){return o.tidy(()=>{if(t)e=o.softmax(e);else{const s=o.sum(e,e.shape.length-1,!0);e=o.div(e,s)}return e=o.clipByValue(e,Se(),1-Se()),o.neg(o.sum(o.mul(o.cast(n,"float32"),o.log$1(e)),e.shape.length-1))})}function Xs(n,e,t=!1){return o.tidy(()=>{const s=o.cast(o.floor(Kg(n)),"int32");e=o.clipByValue(e,Se(),1-Se());const r=e.shape,i=o.reshape(o.oneHot(s,r[r.length-1]),r);return Yn(i,e,t)})}function qx(n,e){if(!o.arraysEqual(n.shape,e.shape))throw new T(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return o.tidy(()=>{const t=o.relu(e),s=o.neg(o.abs(e));return o.add(o.sub(t,o.mul(e,n)),o.log1p(o.exp(s)))})}function So(n,e){return o.tidy(()=>{let t;return t=o.clipByValue(e,Se(),1-Se()),t=o.log$1(o.div(t,o.sub(1,t))),o.mean(qx(n,t),-1)})}function Xx(n,e){return o.tidy(()=>{const t=o.clipByValue(n,Se(),1),s=o.clipByValue(e,Se(),1);return o.sum(o.mul(n,o.log$1(o.div(t,s))),-1)})}function jx(n,e){return o.tidy(()=>{const t=o.log$1(o.add(Se(),e));return o.mean(o.sub(e,o.mul(n,t)),-1)})}function ii(n,e){return o.tidy(()=>{const t=qs(n,-1),s=qs(e,-1),r=o.mul(t,s);return o.neg(o.sum(r,-1))})}const js={meanSquaredError:ln,meanAbsoluteError:vo,meanAbsolutePercentageError:In,meanSquaredLogarithmicError:Vx,squaredHinge:Wx,hinge:Gx,categoricalHinge:Ux,logcosh:Hx,categoricalCrossentropy:Yn,sparseCategoricalCrossentropy:Xs,binaryCrossentropy:So,kullbackLeiblerDivergence:Xx,poisson:jx,cosineProximity:ii};function Go(n){if(typeof n=="string"){if(n in js)return js[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new T(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ai(n,e){return o.tidy(()=>{const t=o.mul(.5,o.onesLike(e)),s=gt(o.greater(e,t),n.dtype);return o.mean(o.equal(n,s),-1)})}function li(n,e){return o.tidy(()=>gt(o.equal(o.argMax(n,-1),o.argMax(e,-1)),"float32"))}function lu(n,e){return o.tidy(()=>o.cast(o.sum(o.logicalAnd(o.equal(n,1),o.equal(e,1))),"float32"))}function Kx(n,e){return o.tidy(()=>o.cast(o.sum(o.logicalAnd(o.equal(n,1),o.equal(e,0))),"float32"))}function Yx(n,e){return o.tidy(()=>o.cast(o.sum(o.logicalAnd(o.equal(n,0),o.equal(e,1))),"float32"))}function cu(n,e){return o.tidy(()=>{const t=lu(n,e),s=Yx(n,e),r=o.add(t,s);return o.cast(o.where(o.greater(r,0),o.div(t,r),0),"float32")})}function Zx(n,e){return o.tidy(()=>{const t=lu(n,e),s=Kx(n,e),r=o.add(t,s);return o.cast(o.where(o.greater(r,0),o.div(t,r),0),"float32")})}function uu(n,e){return So(n,e)}function du(n,e){return n.rank===e.rank&&(n=o.squeeze(n,[n.rank-1])),e=o.argMax(e,-1),e.dtype!==n.dtype&&(e=o.cast(e,n.dtype)),o.cast(o.equal(n,e),"float32")}function Qx(n,e){return o.tidy(()=>{const t=n.sub(e).square().sum(),s=n.sub(n.mean()).square().sum();return o.scalar(1).sub(t.div(s))})}const Jx=ln,eb=ln,tb=vo,nb=vo,sb=In,ob=In,ci=Yn,rb=ii,hu=Xs,Ks={binaryAccuracy:ai,categoricalAccuracy:li,precision:cu,categoricalCrossentropy:ci,sparseCategoricalCrossentropy:hu,mse:Jx,MSE:eb,mae:tb,MAE:nb,mape:sb,MAPE:ob,cosine:rb};function ib(n){if(typeof n=="string"&&n in Ks)return Ks[n];if(typeof n!="string"&&n!=null)return n;throw new T(`Unknown metric ${n}`)}function $s(n){if(ht(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(js))if(js[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Ks))if(Ks[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ab(n){const e={Adagrad:()=>Xt.adagrad(.01),Adadelta:()=>Xt.adadelta(1,.95,Se()),Adam:()=>Xt.adam(.001,.9,.999,Se()),Adamax:()=>Xt.adamax(.002,.9,.999,Se(),0),RMSProp:()=>Xt.rmsprop(.001,.9,0,Se()),SGD:()=>Xt.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new T(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ul=1*1024*1024;function dl(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!sr(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>ul&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${ul}.`)}}function sr(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!sr(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!sr(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lb(n,e,t,s=console.log){const r=ub(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(d=>Math.floor(e*d)));let a;if(!r){i.push("Receives inputs"),a=[];for(const d in n.nodesByDepth)a.push(...n.nodesByDepth[d])}s("_".repeat(e)),Ys(i,t,s),s("=".repeat(e));const l=n.layers;for(let d=0;d<l.length;++d)r?db(l[d],t,s):hb(l[d],t,a,s),s((d===l.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const c=cb(n),u=Gs(n.nonTrainableWeights);s(`Total params: ${c+u}`),s(`Trainable params: ${c}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}function cb(n){let e;return n.collectedTrainableWeights!=null?e=Gs(n.collectedTrainableWeights):e=Gs(n.trainableWeights),e}function ub(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const a of r.inboundNodes)if(s.indexOf(a)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function Ys(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function db(n,e,t){let s,r;try{r=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,a=n.getClassName(),l=[`${i} (${a})`,r,s,n.countParams().toString()];Ys(l,e,t)}function hb(n,e,t,s){let r,i;try{i=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const a=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let p=0;p<h.inboundLayers.length;++p){const f=h.inboundLayers[p].name,m=h.nodeIndices[p],g=h.tensorIndices[p];a.push(`${f}[${m}][${g}]`)}const l=n.name,c=n.getClassName(),u=a.length===0?"":a[0],d=[`${l} (${c})`,i,r,n.countParams().toString(),u];Ys(d,e,s);for(let h=1;h<a.length;++h)Ys(["","","","",a[h]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pu(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Zn(n,e){if(n===null)return null;if(typeof n=="string")return jt(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];pu(e,r,i)?t.push(i):t.push(Zn(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=jt(s);t[i]=Zn(r,i)}}return t}}function or(n,e){if(n==null)return null;if(typeof n=="string")return vt(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];pu(e,r,i)?t.push(i):t.push(or(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=vt(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=or(r,s)}return t}}/** @license See the LICENSE file. */const Io="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const pb=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class tt extends ne{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const y=this.getClassName().toLowerCase();this.name=ho(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Pt(this.inputs).length!==this.inputs.length)throw new T(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);Pt(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const w=y.sourceLayer,C=y.nodeIndex,v=y.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(v)}for(const y of this.inputs){const w=y.sourceLayer,C=y.nodeIndex,v=y.tensorIndex;ht(C===0,"input layer has >1 nodes"),ht(v===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const w=this.inputLayers[y];if(!(w instanceof Sn))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);const t={},s={},r={},i={},a={},l=[],c=(y,w,C,v,S,I)=>{(v==null||S==null||I==null)&&(v=y.sourceLayer,S=y.nodeIndex,I=y.tensorIndex);const k=v.inboundNodes[S];if(C.indexOf(k)!==-1)throw new Ye(`The tensor ${y.name} at layer "${v.name}" is part of a cycle.`);if(w.indexOf(k)!==-1)return;this.containerNodes.add(tt.nodeKey(v,S)),v.id in a||(a[v.id]=Object.keys(a).length),C.indexOf(k)===-1&&C.push(k);const $=k.inboundLayers.length;for(let N=0;N<$;N++){const R=k.inputTensors[N],F=k.inboundLayers[N],O=k.nodeIndices[N],L=k.tensorIndices[N];c(R,w,C,F,O,L)}for(w.push(k);C.indexOf(k)>=0;)C.splice(C.indexOf(k),1);l.push(k)},u=[],d=[];for(const y of this.outputs)c(y,u,d);const h=l.slice().reverse();for(const y of h){s[y.id]=y,y.id in t||(t[y.id]=0);let w=t[y.id];const C=r[y.outboundLayer.id]==null?0:r[y.outboundLayer.id];w=Math.max(w,C),r[y.outboundLayer.id]=w,i[y.outboundLayer.id]=y.outboundLayer,t[y.id]=w;for(let v=0;v<y.inboundLayers.length;v++){const S=y.inboundLayers[v],I=y.nodeIndices[v],k=S.inboundNodes[I],$=t[k.id]==null?0:t[k.id];t[k.id]=Math.max(w+1,$),s[k.id]=k}}const p={};for(const y in t){const w=t[y];w in p||(p[w]=[]),p[w].push(s[y])}const f={};for(const y in r){const w=r[y];w in f||(f[w]=[]),f[w].push(i[y])}let m=Object.keys(f).map(y=>parseInt(y,10)).sort(Is);this.layers=[];for(const y of m){const w=f[y];w.sort((C,v)=>{const S=a[C.id],I=a[v.id];return S<I?-1:S>I?1:0});for(const C of w)C instanceof tt&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=f,m=Object.keys(p).map(y=>parseInt(y,10)).sort(Is);const g=this.inputs.slice(),x=[];for(const y of m)for(const w of p[y]){const C=w.outboundLayer;if(C!=null){for(const v of w.inputTensors)if(g.indexOf(v)===-1)throw new Ye(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${C.name}". The following previous layers were accessed without issue: ${x}`);for(const v of w.outputTensors)g.push(v);x.push(C.name)}}this.nodesByDepth=p;const b=this.layers.map(y=>y.name);for(const y of b){const w=b.filter(C=>C===y).length;if(w!==1)throw new Ye(`The name "${y}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new wo({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new T("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=pb(e);i&&this.parseWeights(e);for(const l of this.layers)for(const[c,u]of l.weights.entries()){const d=i?`${u.name.split("/").slice(0,-1).join("/")+"/"}${c}`:u.originalName;if(s[d]!=null)throw new T(`Duplicate weight name: ${d}`);s[d]=u,r++}const a=[];for(const l in e){let c=l;if(s[l]==null){const u=l.split("/");c=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(s[c]!=null)a.push([s[c],e[l]]);else if(t)throw new T(`Provided weight data has no target variable: ${l}`);delete s[c]}if(t){const l=[];for(const c in s)l.push(c);if(l.length>0)throw new T(`${l.length} of ${r} weights are not set: ${l}`)}ei(a)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!r.includes(a)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Io}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=or(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return o.tidy(()=>{e=ie(e);const s=new Ft;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Wn(this.outputs,s,t)})}computeMask(e,t){return o.tidy(()=>{e=ie(e);let s;return t==null?s=Jt(null,e.length):s=ie(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=Ws(e);if(t.length!==this.inputLayers.length)throw new T(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let l=0;l<t.length;l++){const c=this.inputLayers[l],u=t[l],d=c.name+"_0_0";s[d]=u}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Is);if(r.length>1)for(const l of r){const c=this.nodesByDepth[l];for(const u of c){const d=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(d.id)!==-1)continue;const h=[];for(let g=0;g<u.inboundLayers.length;g++){const x=u.inboundLayers[g],b=u.nodeIndices[g],y=u.tensorIndices[g],w=`${x.name}_${b}_${y}`,C=s[w];h.push(C)}const p=d.computeOutputShape(Me(h)),f=Ws(p),m=d.inboundNodes.indexOf(u);for(let g=0;g<f.length;g++){const x=`${d.name}_${m}_${g}`;s[x]=f[g]}}}const i=[],a=[];for(let l=0;l<this.outputLayers.length;l++){const c=this.outputLayers[l],u=this.outputLayersNodeIndices[l],d=this.outputLayersTensorIndices[l],h=`${c.name}_${u}_${d}`;a.push(h)}for(let l=0;l<a.length;l++){const c=a[l];ht(c in s),i.push(s[c])}return Me(i)}runInternalGraph(e,t){t==null&&(t=Jt(null,e.length));const s={};for(let c=0;c<this.inputs.length;++c){const u=this.inputs[c],d=e[c],h=t[c];s[u.id]=[d,h]}const r=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(Is);for(const c of r){const u=this.nodesByDepth[c];for(const d of u){const h=d.outboundLayer,p=d.inputTensors,f=d.outputTensors,m=new Array;for(const g of p)g.id in s&&m.push(s[g.id]);if(m.length===p.length){let g={},x,b,y,w;if(d.callArgs!=null&&(g=d.callArgs),m.length===1){const[C,v]=m[0];g.mask==null&&(g.mask=v),y=ie(h.call(C,g)),w=ie(h.computeMask(C,v)),x=[C],b=[v]}else x=m.map(C=>C[0]),b=m.map(C=>C[1]),g.mask==null&&(g.mask=b),y=ie(h.call(x,g)),w=ie(h.computeMask(x,b));if(h.activityRegularizer)throw new J("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<f.length;++C){const v=f[C],S=y[C],I=w[C];s[v.id]=[S,I]}}}}const i=[],a=[],l=[];for(const c of this.outputs){ht(c.id in s,`Could not compute output ${c.name} : ${c.id}`);const[u,d]=s[c.id];l.push(u.shape),i.push(u),a.push(d)}return[i,a,l]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof tt?1:0;for(let i=0;i<r.inboundNodes.length;i++){const a=tt.nodeKey(r,i);this.containerNodes.has(a)&&(t[a]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new T("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new T(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new T(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return o.tidy(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=tt.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const l=a.getClassName(),c=a.getConfig(),u=[];for(let h=0;h<a.inboundNodes.length;h++){const p=a.inboundNodes[h],f=tt.nodeKey(a,h);let m={};if(this.containerNodes.has(f)){if(p.callArgs)try{JSON.stringify(p.callArgs),m=p.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(p.inboundLayers.length>0){const g=[];for(let x=0;x<p.inboundLayers.length;x++){const b=p.inboundLayers[x],y=p.nodeIndices[x],w=p.tensorIndices[x],C=tt.nodeKey(b,y);let v=t[C];v==null&&(v=0),g.push([b.name,v,w,m])}u.push(g)}}}const d={};d.name=a.name,d.className=l,d.config=c,d.inboundNodes=u,s.push(d)}e.layers=s;const r=[];for(let a=0;a<this.inputLayers.length;a++){const l=this.inputLayers[a],c=this.inputLayersNodeIndices[a],u=tt.nodeKey(l,c);if(!this.containerNodes.has(u))continue;let d=t[u];d==null&&(d=0);const h=this.inputLayersTensorIndices[a];r.push([l.name,d,h])}e.inputLayers=r;const i=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=tt.nodeKey(l,c);if(!this.containerNodes.has(u))continue;let d=t[u];d==null&&(d=0);const h=this.outputLayersTensorIndices[a];i.push([l.name,d,h])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},a={};function l(x,b){x.name in a?a[x.name].push(b):a[x.name]=[b]}function c(x,b){const y=[];let w;for(const C of b){const v=C[0],S=C[1],I=C[2];if(w=C[3]==null?{}:C[3],!(v in i)){l(x,b);return}const k=i[v];if(k.inboundNodes.length<=S){l(x,b);return}const $=k.inboundNodes[S];y.push($.outputTensors[I])}y.length>0&&x.apply(Me(y),w)}function u(x){const b=x.name,y=st(x,t.customObjects!=null?t.customObjects:{});y.setFastWeightInitDuringBuild(r),i[b]=y,x.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new T(`Corrupted configuration, expected array for nodeData: ${C}`);l(y,C)})}const d=t.name,h=t.layers;for(const x of h)u(x);for(;!Pg(a);)for(const x of h){const b=i[x.name];if(b.name in a){const y=a[b.name];delete a[b.name];for(const w of y)c(b,w)}}const p=[],f=[],m=t.inputLayers;for(const x of m){const b=x[0],y=x[1],w=x[2];ht(b in i);const v=i[b].inboundNodes[y].outputTensors;p.push(v[w])}const g=t.outputLayers;for(const x of g){const b=x[0],y=x[1],w=x[2];ht(b in i);const v=i[b].inboundNodes[y].outputTensors;f.push(v[w])}return new e({inputs:p,outputs:f,name:d})}get stateful(){if(this._stateful)throw new T("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){o.tidy(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fb(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function fu(n,e){return fb(n,e,"classWeight")}async function mu(n,e,t,s){if(t!=null){const r=o.tidy(()=>{if(n.shape.length===1)return o.clone(n);if(n.shape.length===2){if(n.shape[1]>1)return o.argMax(n,1);if(n.shape[1]===1)return o.reshape(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());o.dispose(r);const a=[];return i.forEach(l=>{if(t[l]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${l} exists in the data but not in classWeight`);a.push(t[l])}),o.tensor1d(a,"float32")}else return null}function mb(n,e){return o.mul(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const gb=32;function gu(n,e){let t,s;const r=e;t=r.xs,s=r.ys,o.assert(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=hl("input",n.inputNames,t),a=hl("output",n.outputNames,s),l=i[0].shape[0];o.assert(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),o.assert(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let c=0;c<i.length;c++)o.assert(i[c].shape[0]===l,()=>`Batch size mismatch: input ${n.inputNames[c]} has ${i[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);for(let c=0;c<a.length;c++)o.assert(a[c].shape[0]===l,()=>`Batch size mismatch: output ${n.outputNames[c]} has ${a[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);return{xs:i,ys:a}}function hl(n,e,t){if(t instanceof o.Tensor)return[t];if(Array.isArray(t))return o.assert(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new T(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function xb(n){if(n.length===3)throw new J("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function bb(n,e,t){const s=t.batchesPerEpoch!=null;if(o.assert(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),o.assert(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),o.assert(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),o.assert(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),o.assert(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,a;if(r)if(pl(t.validationData))o.assert(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const x=xb(t.validationData);i=x.xs,a=x.ys}const l=n.makeTrainFunction(),c=n.getDedupedMetricsNames();let u;r?u=c.slice().concat(c.map(x=>"val_"+x)):u=c.slice();const d=iu(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:p,history:f}=au(d,h,t.epochs,null,null,yb(e,t),null,r,u);p.setModel(n),n.history=f,await p.onTrainBegin(),n.stopTraining_=!1;let m=t.initialEpoch==null?0:t.initialEpoch,g=await e.iterator();for(;m<t.epochs;){const x={};await p.onEpochBegin(m);let b=0,y=0;for(s||(g=await e.iterator());!s||b<t.batchesPerEpoch;){const w=await g.next();if(s&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){const{xs:C,ys:v}=gu(n,w.value),S={};S.batch=y,S.size=C[0].shape[0],await p.onBatchBegin(y,S);const I=[];if(t.classWeight!=null){const N=fu(t.classWeight,n.outputNames);for(let R=0;R<N.length;++R)I.push(await mu(v[R],null,N[R]))}const k=C.concat(v).concat(I),$=l(k);o.dispose(k);for(let N=0;N<c.length;++N){const R=c[N],F=$[N];S[R]=F,o.keep(F)}await p.onBatchEnd(y,S),nu(S),y++,b++}if(s?b>=t.batchesPerEpoch:w.done){if(r){let C;pl(t.validationData)?C=ie(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):C=ie(n.evaluate(i,a,{batchSize:t.validationBatchSize==null?gb:t.validationBatchSize,verbose:0}));for(let v=0;v<n.metricsNames.length;++v)x[`val_${n.metricsNames[v]}`]=C[v]}break}if(n.stopTraining_)break}if(await p.onEpochEnd(m,x),m++,n.stopTraining_)break}return await p.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function yb(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function pl(n){return typeof n.iterator=="function"}function Cb(n){return typeof n.next=="function"}async function wb(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new J("Verbose mode is not implemented yet.");o.assert(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=Cb(e)?e:await e.iterator();let l=0,c=0;for(;!s||c<t.batches;){const u=await a.next();if(i=o.tidy(()=>{if(u.value){const{xs:d,ys:h}=gu(n,u.value),p=d.concat(h),f=o.tidy(()=>r(p));if(o.dispose(p),c===0)for(let g=0;g<f.length;++g)i.push(o.scalar(0));const m=p[0].shape[0];for(let g=0;g<f.length;++g){const x=f[g],b=i[g];i[g]=o.tidy(()=>o.add(i[g],o.mul(m,x))),c>0&&o.dispose(b)}o.dispose(f),l+=m,++c}return i}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const d=i[u];i[u]=o.div(i[u],l),o.dispose(d)}return Me(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Uo(n){o.assert(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function _n(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Qt(s,e,t-e)):Qt(n,e,t-e)}function rr(n,e){return o.tidy(()=>n==null?null:Array.isArray(n)?n.map(t=>rr(t,e)):Zc(n,e.dtype==="int32"?e:o.cast(e,"int32")))}function Ho(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function xu(n){const e=[];n instanceof o.Tensor&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(ls(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function et(n,e){if(n==null)return;const t=[];if(e instanceof o.Tensor)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof o.Tensor)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vb(n){return n instanceof o.Tensor}function ir(n){return Array.isArray(n)}function fl(n){return!vb(n)&&!ir(n)}function ml(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let a=!1;if(ir(n)&&n.length>0)a=!0;else if(fl(n)){for(const l in n)if(n.hasOwnProperty(l)){a=!0;break}}else a=!0;if(a)throw new T(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(a=>null);let i;if(fl(n)){n=n,i=[];for(const a of e){if(n[a]==null)throw new T(`No data provided for "${a}". Need data for each key in: ${e}`);i.push(n[a])}}else if(ir(n)){if(n=n,n.length!==e.length)throw new T(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new T(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=xu(i),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const l=i[a];if(l.shape.length!==t[a].length)throw new T(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${l.shape}`);for(let c=0;c<t[a].length;++c){if(c===0&&!s)continue;const u=l.shape[c],d=t[a][c];if(d!=null&&d>=0&&u!==d)throw new T(`${r} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${r} received an input with ${l.shape[0]} examples, each with shape [${l.shape.slice(1,l.shape.length)}] (tensor shape [${l.shape}])`)}}return i}function Sb(n,e,t){const s=Pt(n.map(i=>i.shape[0]));s.sort();const r=Pt(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new T(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new T(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!o.arraysEqual(s,r))throw new T(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function Ib(n,e,t){const s=[ln,So,Yn];for(let r=0;r<n.length;++r){const i=n[r],a=e[r],l=t[r];if(a!=null){if(a===Yn&&i.shape[i.shape.length-1]===1)throw new T(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const c=i.shape.slice(1),u=l.slice(1);for(let d=0;d<c.length;++d){const h=c[d],p=u[d];if(p!=null&&h!==p)throw new T(`A target Tensor with shape ${i.shape} was passed for an output of shape ${l}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function gl(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new T(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new T(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const l=i[a];if(l.shape.length!==t[a].length)throw new T(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(l.shape)}`);for(let c=0;c<t[a].length;++c){if(c===0&&!s)continue;const u=l.shape[c],d=t[a][c];if(d!=null&&d!==u)throw new T(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(l.shape)}.`)}}}function kb(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const Tb="layers-model";class St extends tt{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new T("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");lb(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=ab(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof o.Optimizer))throw new T("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new T(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(Go(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new T(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(l=>Go(l))}else{const a=Go(e.loss);this.outputs.forEach(l=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a],c=this.outputNames[a];this.feedOutputNames.push(c),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Zt("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const r=kb(e.metrics,this.outputNames),i=(a,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,a])};Zt("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const l=r[a];(u=>{const d="";let h,p,f;for(const m of u){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){const x=this.internalOutputShapes[a];x[x.length-1]===1||this.lossFunctions[a]===So?["accuracy","acc"].indexOf(m)!==-1?p=ai:["crossentropy","ce"].indexOf(m)!==-1&&(p=uu):this.lossFunctions[a]===Xs?["accuracy","acc"].indexOf(m)!==-1?p=du:["crossentropy","ce"].indexOf(m)!==-1&&(p=hu):["accuracy","acc"].indexOf(m)!==-1?p=li:["crossentropy","ce"].indexOf(m)!==-1&&(p=ci);let b;["accuracy","acc"].indexOf(m)!==-1?b="acc":["crossentropy","ce"].indexOf(m)!==-1&&(b="ce"),f=p,h=d+b}else f=ib(m),h=d+$s(m);let g;Zt(h,()=>{g=f}),i(a,h,g)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;Uo(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const l=a[0].concat(a[1]);this.makeTestFunction();const c=this.testFunction,u=this.testLoop(c,l,r,s.verbose,s.steps);return Me(u)}finally{et(a[0],e),et(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),wb(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new T(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new T(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new T("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),a=new Ft;if(e instanceof o.Tensor&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new T(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const u=e[c.name];if(u==null)throw new T(`No value is provided for the model's input ${c.name}`);a.add(c,u)}const l=Wn(i,a);return s?l:l[0]}retrieveSymbolicTensors(e){const t=Jt(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){const c=a.indexOf(e[l]);if(c!==-1&&(t[l]=i[c],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,a)=>{i==null&&r.push(e[a])}),new T(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return o.tidy(()=>{const r=this.checkNumSamples(e);if(s)throw new J("Verbose predictLoop() is not implemented yet.");const i=Ho(r,t),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)o.tidy(()=>{const u=i[l][0],d=i[l][1],h=_n(e,u,d),p=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)p.push({key:this.inputs[m],value:h[m]});else p.push({key:this.inputs[0],value:h});const f=new Ft(p);return Wn(this.outputs,f)}).forEach((u,d)=>a[d].push(u));return Me(a.map(l=>o.concat(l,0)))})}predict(e,t={}){const s=xu(e);gl(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return Uo(r),this.predictLoop(s,r)}finally{et(s,e)}}predictOnBatch(e){gl(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new Ye("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];this.feedLossFns[a]===Xs?i.push(l.slice(0,l.length-1).concat([1])):i.push(l)}if(e=ml(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=ml(t,this.feedOutputNames,i,!1,"target"),Sb(e,t),Ib(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new T(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,a){const[l,c]=this.standardizeUserDataXY(e,t,i,a);if(s!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const d=fu(r,this.outputNames);u=[];for(let h=0;h<d.length;++h)u.push(await mu(c[h],null,d[h]))}return[l,c,u]}testLoop(e,t,s,r=0,i){return o.tidy(()=>{const a=this.checkNumSamples(t,s,i,"steps"),l=[];if(r>0)throw new J("Verbose mode is not implemented yet.");if(i!=null)throw new J("steps mode in testLoop() is not implemented yet");{const c=Ho(a,s),u=o.tensor1d(rt(0,a));for(let d=0;d<c.length;++d){const h=c[d][0],p=c[d][1],f=Qt(u,h,p-h),m=rr(t,f),g=e(m);if(d===0)for(let x=0;x<g.length;++x)l.push(o.scalar(0));for(let x=0;x<g.length;++x){const b=g[x];l[x]=o.add(l[x],o.mul(p-h,b))}}for(let d=0;d<l.length;++d)l[d]=o.div(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(el(e,r)>1){const a=el(e.slice(0,s),r);i+=`_${a}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],l=()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const p=new Ft(h),f=Wn(this.outputs,p,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){const x=this.lossFunctions[g];let b=x(r[g],f[g]);i[g]!=null&&(b=mb(b,i[g]));const y=o.mean(b);t.push(y),g===0?m=b:m=o.add(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let x;if(this.outputs.length>1&&g<this.outputs.length)x=t[g];else{const b=this.metricsTensors[g][0],y=this.metricsTensors[g][1];x=o.mean(b(r[y],f[y]))}o.keep(x),a.push(x)}return m=o.mean(m),this.calculateLosses().forEach(g=>{m=o.add(m,g)}),m},c=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(l,!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>o.tidy(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:r[u]});const l=new Ft(a),c=Wn(this.outputs,l);for(let u=0;u<this.lossFunctions.length;++u){const d=this.lossFunctions[u],h=o.mean(d(i[u],c[u]));u===0?s=h:s=o.add(s,h),t.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const d=this.metricsTensors[u][0],h=this.metricsTensors[u][1],p=o.mean(d(i[h],c[h]));t.push(p)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,a,l,c,u,d,h,p;try{const f=s.batchSize==null?32:s.batchSize;Uo(f);const g=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,f);r=g[0],i=g[1],p=g[2];let x=!1,b;if(s.validationData!=null&&s.validationData.length>0){if(x=!0,s.validationData.length===2)c=s.validationData[0],u=s.validationData[1];else throw s.validationData.length===3?new J("validationData including sample weights is not supported yet."):new T(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const N=await this.standardizeUserData(c,u,null,null,!0,f);d=N[0],h=N[1],b=d.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){x=!0;const $=Math.floor(r[0].shape[0]*(1-s.validationSplit)),N=r[0].shape[0];d=_n(r,$,N),a=r,r=_n(r,0,$),h=_n(i,$,N),l=i,i=_n(i,0,$),b=d.concat(h)}else s.validationSteps!=null&&(x=!0);const y=r.concat(i).concat(p);this.checkTrainableWeightsConsistency();const w=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let v,S;x?(this.makeTestFunction(),v=this.testFunction,S=C.slice().concat(C.map($=>"val_"+$))):(v=null,b=[],S=C.slice());const I=iu(s.callbacks,s.yieldEvery);return await this.fitLoop(w,y,C,f,s.epochs,s.verbose,I,v,b,s.shuffle,S,s.initialEpoch,null,null)}finally{this.isTraining=!1,et(r,e),et(i,t),et(a,e),et(l,t),et(d,c),et(h,u),p!=null&&o.dispose(p)}}async fitLoop(e,t,s,r,i,a,l,c,u,d,h,p,f,m){r==null&&(r=32),i==null&&(i=1),d==null&&(d=!0),p==null&&(p=0);let g=!1;if(c!=null&&u!=null&&(g=!0),m!=null&&(g=!0,f==null))throw new T("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const x=this.checkNumSamples(t,r,f,"steps_per_epoch");let b;x!=null&&(b=rt(0,x)),a==null&&(a=1);const{callbackList:y,history:w}=au(l,a,i,p,x,f,r,g,h);y.setModel(this),this.history=w,await y.onTrainBegin(),this.stopTraining_=!1;for(let C=p;C<i;++C){await y.onEpochBegin(C);const v={};if(f!=null)throw new J("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new J("batch shuffling is not implemneted yet");d&&o.shuffle(b);const S=o.tensor1d(b),I=Ho(x,r);for(let k=0;k<I.length;++k){const $={};if(await y.onBatchBegin(k,$),o.tidy(()=>{const N=I[k][0],R=I[k][1],F=Qt(S,N,R-N);$.batch=k,$.size=R-N;const O=rr(t,F),L=e(O);for(let A=0;A<s.length;++A){const E=s[A],P=L[A];$[E]=P,o.keep(P)}if(k===I.length-1&&g){const A=this.testLoop(c,u,r);for(let E=0;E<s.length;++E){const P=s[E],D=A[E];o.keep(D),v["val_"+P]=D}}}),await y.onBatchEnd(k,$),nu($),this.stopTraining_)break}S.dispose()}if(await y.onEpochEnd(C,v),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return bb(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],l=this.makeTrainFunction()(r.concat(i)),c=[];for(const u of l){const d=await u.data();c.push(d[0])}return o.dispose(l),et(s[0],e),et(s[1],t),Me(c)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<r.length;++a)s&&!r[a].trainable||t.push({name:r[a].originalName,tensor:i[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=o.memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-o.memory().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=vt(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>vt(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=vt(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[vt($s(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>vt($s(e)));{const e={};for(const t in this.metrics)e[t]=vt($s(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Zn(e.optimizer_config),s=st(t);let r;if(typeof e.loss=="string")r=jt(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>jt(a));else if(e.loss!=null){r={};for(const a in e.loss)r[a]=jt(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>jt(a));else if(e.metrics!=null){i={};for(const a in e.metrics)i[a]=jt(e.metrics[a])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const u=o.getSaveHandlers(e);if(u.length===0)throw new T(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new T(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new T("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await o.encodeWeights(this.getNamedWeights(t)),l={modelTopology:this.toJSON(null,!1),format:Tb,generatedBy:`TensorFlow.js tfjs-layers v${Io}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:d,specs:h}=await o.encodeWeights(await this.optimizer.getWeights(),u);s.specs.push(...h),s.data=o.concatenateArrayBuffers([s.data,d])}return this.userDefinedMetadata!=null&&(dl(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=s.data,l.weightSpecs=s.specs,e.save(l)}setUserDefinedMetadata(e){dl(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}St.className="Model";o.registerClass(St);class bu extends St{}bu.className="Functional";o.registerClass(bu);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function $b(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const s=Zn(t),r=st(s,e);if(n.weightsManifest!=null){const i=await o.loadWeights(n.weightsManifest,n.pathPrefix,r.weights.map(l=>l.originalName)),a={};for(const l of r.weights)a[l.originalName]=i[l.originalName];r.loadWeights(a),o.dispose(i)}return r}async function Nb(n,e){if(e==null&&(e={}),typeof n=="string"){const t=o.getLoadHandlers(n,e);if(t.length===0)t.push(o.browserHTTPRequest(n,e));else if(t.length>1)throw new T(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return Rb(n,void 0,e)}async function Rb(n,e,t){if(t==null&&(t={}),n.load==null)throw new T("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const i=t.strict==null?!0:t.strict,a=s.weightData!=null&&s.weightSpecs!=null&&i,l=st(Zn(r),e,a),c=s.trainingConfig;if(c!=null&&l.loadTrainingConfig(c),s.userDefinedMetadata!=null&&l.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new T("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:d}=Ab(s.weightData,s.weightSpecs);l.loadWeights(u,i),l.optimizer!=null&&d.length>0&&await l.optimizer.setWeights(d),o.dispose(u),o.dispose(d.map(h=>h.tensor))}return l}function Ab(n,e){const t=o.decodeWeights(n,e),s={},r=[];return e.forEach(i=>{i.group==="optimizer"?r.push({name:i.name,tensor:t[i.name]}):s[i.name]=t[i.name]}),{modelWeights:s,optimizerWeights:r}}class en extends St{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:ho("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new T(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof en||e instanceof St;let s;if(t){if(s=e,s.outputs.length!==1)throw new T("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new T("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new T("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=tu({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new T(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new T("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=eu(this.outputs[0])}this.inboundNodes=[],new wo({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Jt(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(oe(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new St({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new Ye("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new Ye("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new Ye("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new Ye("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new T("Legacy serialization format not supported yet.");i=t}else o.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,a=t;const l=new e(a);if(!(l instanceof en))throw new J(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of i){const d=st(c,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(this.model==null)throw new T("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new T("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}en.className="Sequential";o.registerClass(en);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Db(n){return new St(n)}function Eb(n){return new en(n)}function yu(n){return tu(n)}function Fb(n,e){Ue.registerCallbackConstructor(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Ee=class extends o.Serializable{getConfig(){return{}}};class Cu extends Ee{apply(e,t=1){return Zg(e,t)}}Cu.className="elu";o.registerClass(Cu);class wu extends Ee{apply(e){return o.selu(e)}}wu.className="selu";o.registerClass(wu);class vu extends Ee{apply(e){return o.relu(e)}}vu.className="relu";o.registerClass(vu);class Su extends Ee{apply(e){return o.tidy(()=>o.minimum(6,o.relu(e)))}}Su.className="relu6";o.registerClass(Su);class Iu extends Ee{apply(e){return e}}Iu.className="linear";o.registerClass(Iu);class ku extends Ee{apply(e){return o.sigmoid(e)}}ku.className="sigmoid";o.registerClass(ku);class Tu extends Ee{apply(e){return Jg(e)}}Tu.className="hardSigmoid";o.registerClass(Tu);class $u extends Ee{apply(e){return o.softplus(e)}}$u.className="softplus";o.registerClass($u);class Nu extends Ee{apply(e){return Qg(e)}}Nu.className="softsign";o.registerClass(Nu);class Ru extends Ee{apply(e){return o.tanh(e)}}Ru.className="tanh";o.registerClass(Ru);let ui=class extends Ee{apply(e,t=-1){return o.softmax(e,t)}};ui.className="softmax";o.registerClass(ui);class Au extends Ee{apply(e,t=-1){return o.logSoftmax(e,t)}}Au.className="logSoftmax";o.registerClass(Au);class Du extends Ee{apply(e){return o.tidy(()=>o.tidy(()=>{const t=Math.sqrt(2),s=o.mul(.5,o.add(1,o.erf(o.div(e,t))));return o.mul(e,s)}))}}Du.className="gelu";o.registerClass(Du);class Eu extends Ee{apply(e){return o.tidy(()=>o.mul(.5,o.mul(e,o.add(1,o.tanh(o.mul(o.sqrt(o.div(2,Math.PI)),o.add(e,o.mul(.044715,o.pow(e,3)))))))))}}Eu.className="gelu_new";o.registerClass(Eu);class Fu extends Ee{apply(e){return o.tidy(()=>o.mul(e,o.tanh(o.softplus(e))))}}Fu.className="mish";o.registerClass(Fu);class Ou extends Ee{apply(e,t=1){return o.tidy(()=>o.mul(o.sigmoid(o.mul(e,t)),e))}}Ou.className="swish";o.registerClass(Ou);function _t(n){return n.getClassName()}function qo(n,e={}){return as(n,o.SerializationMap.getMap().classNameMap,e,"activation")}function Bt(n){if(n==null){const e={};return e.className="linear",e.config={},qo(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},qo(e)}else return n instanceof Ee?n:qo(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function di(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class Lu extends o.Serializable{}class hs extends Lu{constructor(e){super(),di(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return o.tidy(()=>{let t=o.zeros([1]);return this.hasL1&&(t=o.add(t,o.sum(o.mul(this.l1,o.abs(e))))),this.hasL2&&(t=o.add(t,o.sum(o.mul(this.l2,cs(e))))),o.reshape(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}hs.className="L1L2";o.registerClass(hs);function Ob(n){return di(n),new hs({l1:n!=null?n.l1:null,l2:0})}function Lb(n){return di(n),new hs({l2:n!=null?n.l2:null,l1:0})}const xl={l1l2:"L1L2"};function ue(n){return Ur(n)}function bl(n,e={}){return as(n,o.SerializationMap.getMap().classNameMap,e,"regularizer")}function ge(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in xl?xl[n]:n,config:{}};return bl(t)}else return n instanceof Lu?n:bl(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hi extends ne{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Q(e);let s=o.relu(e);return this.maxValue!=null&&(s=o.clipByValue(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}hi.className="ReLU";o.registerClass(hi);class pi extends ne{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Q(e);return o.leakyRelu(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}pi.className="LeakyReLU";o.registerClass(pi);class fi extends ne{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=me(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ge(e.alphaRegularizer),this.alphaConstraint=ke(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new T(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=oe(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new ve({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=Q(e),o.prelu(e,this.alpha.read())}getConfig(){const e={alphaInitializer:be(this.alphaInitializer),alphaRegularizer:ue(this.alphaRegularizer),alphaConstraint:Ie(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}fi.className="PReLU";o.registerClass(fi);let mi=class extends ne{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new J(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Q(e);return o.elu(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};mi.className="ELU";o.registerClass(mi);class gi extends ne{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=Q(e);return o.mul(s,o.cast(o.greater(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}gi.className="ThresholdedReLU";o.registerClass(gi);class xi extends ne{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new ui().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return o.tidy(()=>{let s=Q(e);const r=t.mask;if(r!=null){const i=o.mul(o.sub(o.ones(s.shape),o.cast(r,s.dtype)),o.scalar(-1e9));s=o.add(s,i)}return this.axis instanceof Array?this.axis.length>1?o.exp(o.sub(s,o.logSumExp(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}xi.className="Softmax";o.registerClass(xi);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gn(n,e,t){if(typeof n=="number")return Jt(n,e);if(n.length!==e)throw new T(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!Xg(r))throw new T(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function ot(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let a;return t==="same"?a=n:a=n-i+1,Math.floor((a+s-1)/s)}function pt(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+zt([t-e,0]);else if(s==="same")n=n*e;else throw new T(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bi(n,e){return o.tidy(()=>(Ce(e),e==="channelsFirst"?o.transpose(n,[0,2,3,1]):n))}function Pu(n,e){return o.tidy(()=>(Ce(e),e==="channelsFirst"?o.transpose(n,[0,2,3,4,1]):n))}function Pb(n,e,t,s=1,r="valid",i,a=1){return o.tidy(()=>{if(i==null&&(i=it()),Ce(i),n.shape.length!==3)throw new T(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new T(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new T(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=o.transpose(n,[0,2,1])),r==="causal")throw new J("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let l=o.conv1d(n,e,s,r==="same"?"same":"valid","NWC",a);return t!=null&&(l=ct(l,t)),l})}function yl(n,e,t,s=[1,1],r="valid",i,a,l=null){return o.tidy(()=>{if(i==null&&(i=it()),Ce(i),n.rank!==3&&n.rank!==4)throw new T(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new T(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let c=bi(n,i);if(r==="causal")throw new J("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=o.conv2d$1({x:c,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:l}),i==="channelsFirst"&&(c=o.transpose(c,[0,3,1,2])),c})}function Mb(n,e,t,s=[1,1,1],r="valid",i,a){return o.tidy(()=>{if(i==null&&(i=it()),Ce(i),n.rank!==4&&n.rank!==5)throw new T(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new T(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let l=Pu(n,i);if(r==="causal")throw new J("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return l=o.conv3d(l,e,s,r==="same"?"same":"valid","NDHWC",a),t!=null&&(l=ct(l,t)),i==="channelsFirst"&&(l=o.transpose(l,[0,4,1,2,3])),l})}class ko extends ne{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",ko.verifyArgs(t),this.rank=e,$e(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new J(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=gn(t.kernelSize,e,"kernelSize"),this.strides=gn(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Xe(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ce(this.dataFormat),this.activation=Bt(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=me(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ke(t.biasConstraint),this.biasRegularizer=ge(t.biasRegularizer),this.activityRegularizer=ge(t.activityRegularizer),this.dilationRate=gn(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new T(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new T(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new T(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ht("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Hr(e.kernelSize,"number",1,3))throw new T(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:_t(this.activation),useBias:this.useBias,biasInitializer:be(this.biasInitializer),biasRegularizer:ue(this.biasRegularizer),activityRegularizer:ue(this.activityRegularizer),biasConstraint:Ie(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class kn extends ko{constructor(e,t){super(e,t),this.kernel=null,kn.verifyArgs(t),this.filters=t.filters,$e(this.filters,"filters"),this.kernelInitializer=me(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ke(t.kernelConstraint),this.kernelRegularizer=ge(t.kernelRegularizer)}build(e){e=oe(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new T(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return o.tidy(()=>{e=Q(e);let s;const r=this.bias==null?null:this.bias.read(),i=Hc(this.activation.getClassName());if(i!=null&&this.rank===2)s=yl(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=Pb(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=yl(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=Mb(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new J("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=oe(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const a=ot(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:be(this.kernelInitializer),kernelRegularizer:ue(this.kernelRegularizer),kernelConstraint:Ie(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new T(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Tn extends kn{constructor(e){super(2,e),Tn.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Hr(e.kernelSize,"number",1,2))throw new T(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Tn.className="Conv2D";o.registerClass(Tn);class $n extends kn{constructor(e){super(3,e),$n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new T(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}$n.className="Conv3D";o.registerClass($n);class yi extends Tn{constructor(e){if(super(e),this.inputSpec=[new ve({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new T(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=oe(e),e.length!==4)throw new T("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new T("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ve({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return o.tidy(()=>{let s=Q(e);if(s.shape.length!==4)throw new T(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,l;this.dataFormat==="channelsFirst"?(a=2,l=3):(a=1,l=2);const c=r[a],u=r[l],d=this.kernelSize[0],h=this.kernelSize[1],p=this.strides[0],f=this.strides[1],m=pt(c,p,d,this.padding),g=pt(u,f,h,this.padding),x=[i,m,g,this.filters];this.dataFormat!=="channelsLast"&&(s=o.transpose(s,[0,2,3,1]));let b=o.conv2dTranspose(s,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=o.transpose(b,[0,3,1,2])),this.bias!=null&&(b=ct(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=oe(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],u=this.strides[1];return t[s]=this.filters,t[r]=pt(t[r],c,a,this.padding),t[i]=pt(t[i],u,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}yi.className="Conv2DTranspose";o.registerClass(yi);class Ci extends $n{constructor(e){if(super(e),this.inputSpec=[new ve({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new T(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=oe(e),e.length!==5)throw new T("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new T("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ve({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return o.tidy(()=>{let s=Q(e);if(s.shape.length!==5)throw new T(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,l,c;this.dataFormat==="channelsFirst"?(c=2,a=3,l=4):(c=1,a=2,l=3);const u=r[c],d=r[a],h=r[l],p=this.kernelSize[0],f=this.kernelSize[1],m=this.kernelSize[2],g=this.strides[0],x=this.strides[1],b=this.strides[2],y=pt(u,g,p,this.padding),w=pt(d,x,f,this.padding),C=pt(h,b,m,this.padding),v=[i,y,w,C,this.filters];this.dataFormat!=="channelsLast"&&(s=o.transpose(s,[0,2,3,4,1]));let S=o.conv3dTranspose(s,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=o.transpose(S,[0,4,1,2,3])),this.bias!==null&&(S=ct(S,this.bias.read(),this.dataFormat)),this.activation!==null&&(S=this.activation.apply(S)),S})}computeOutputShape(e){e=oe(e);const t=e.slice();let s,r,i,a;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,a=4):(s=4,r=1,i=2,a=3);const l=this.kernelSize[0],c=this.kernelSize[1],u=this.kernelSize[2],d=this.strides[0],h=this.strides[1],p=this.strides[2];return t[s]=this.filters,t[r]=pt(t[r],d,l,this.padding),t[i]=pt(t[i],h,c,this.padding),t[a]=pt(t[a],p,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Ci.className="Conv3DTranspose";o.registerClass(Ci);class Mu extends kn{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new T("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new T("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new T(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=me(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ge(t.depthwiseRegularizer),this.depthwiseConstraint=ke(t.depthwiseConstraint),this.pointwiseInitializer=me(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ge(t.pointwiseRegularizer),this.pointwiseConstraint=ke(t.pointwiseConstraint)}build(e){if(e=oe(e),e.length<this.rank+2)throw new T(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new T(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new ve({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return o.tidy(()=>{e=Q(e);let s;if(this.rank===1)throw new J("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=o.transpose(e,[0,2,3,1])),s=o.separableConv2d(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=ct(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=o.transpose(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=be(this.depthwiseInitializer),e.pointwiseInitializer=be(this.pointwiseInitializer),e.depthwiseRegularizer=ue(this.depthwiseRegularizer),e.pointwiseRegularizer=ue(this.pointwiseRegularizer),e.depthwiseConstraint=Ie(this.depthwiseConstraint),e.pointwiseConstraint=Ie(this.pointwiseConstraint),e}}Mu.className="SeparableConv";class wi extends Mu{constructor(e){super(2,e)}}wi.className="SeparableConv2D";o.registerClass(wi);class ps extends kn{constructor(e){super(1,e),ps.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Hr(e.kernelSize,"number",1,1))throw new T(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}ps.className="Conv1D";o.registerClass(ps);class vi extends ne{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return o.tidy(()=>{if(e=Q(e),this.dataFormat==="channelsLast"){const s=Ts(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ts(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Ts(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ts(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}vi.className="Cropping2D";o.registerClass(vi);class Si extends ne{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ce(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Ug(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return o.tidy(()=>{let s=Q(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=o.transpose(s,[0,2,3,1]);const i=this.size[0]*r[2],a=this.size[1]*r[3],l=this.interpolation==="nearest"?o.image.resizeNearestNeighbor(s,[i,a]):o.image.resizeBilinear(s,[i,a]);return o.transpose(l,[0,3,1,2])}else{const i=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?o.image.resizeNearestNeighbor(s,[i,a]):o.image.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Si.className="UpSampling2D";o.registerClass(Si);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zb(n,e,t=[1,1],s="valid",r,i){return o.tidy(()=>{r==null&&(r=it()),Ce(r);let a=bi(n,r);if(n.rank!==4)throw new T(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new T(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=o.depthwiseConv2d(a,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(a=o.transpose(a,[0,3,1,2])),a})}class Ii extends ko{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=me(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ke(e.depthwiseConstraint),this.depthwiseRegularizer=ge(e.depthwiseRegularizer)}build(e){if(e=oe(e),e.length<4)throw new T(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new T(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return o.tidy(()=>{e=Q(e);let s=zb(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=ct(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=oe(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=ot(t,this.kernelSize[0],this.padding,this.strides[0]),a=ot(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,a]:[e[0],i,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=be(this.depthwiseInitializer),e.depthwiseRegularizer=ue(this.depthwiseRegularizer),e.depthwiseConstraint=Ie(this.depthwiseRegularizer),e}}Ii.className="DepthwiseConv2D";o.registerClass(Ii);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zu(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new T("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function _u(n,e,t,s=!1,r,i,a=!1,l=!1){return o.tidy(()=>{const c=e.shape.length;if(c<3)throw new T(`Input should be at least 3D, but is ${c}D.`);const u=[1,0].concat(rt(2,c));e=o.transpose(e,u),a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=o.cast(o.cast(r,"bool"),"float32"),r.rank===c-1&&(r=o.expandDims(r,-1)),r=o.transpose(r,u)),s&&(e=o.reverse(e,0),r!=null&&(r=o.reverse(r,0)));const d=[];let h,p=t;const f=e.shape[0],m=o.unstack(e);let g;r!=null&&(g=o.unstack(r));for(let b=0;b<f;++b){const y=m[b],w=o.tidy(()=>n(y,p));if(r==null)h=w[0],p=w[1];else{const C=o.tidy(()=>{const v=g[b],S=o.sub(o.onesLike(v),v),I=o.add(o.mul(w[0],v),o.mul(p[0],S)),k=p.map(($,N)=>o.add(o.mul(w[1][N],v),o.mul($,S)));return{output:I,newStates:k}});h=C.output,p=C.newStates}l&&d.push(h)}let x;return l&&(x=o.stack(d,1)),[h,x,p]})}class ut extends ne{constructor(e){super(e);let t;if(e.cell==null)throw new T("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new No({cells:e.cell}):t=e.cell,t.stateSize==null)throw new T("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new ve({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return rt(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){tr(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const a of t)i.push([e[0],a]);return[r].concat(i)}else return r}computeMask(e,t){return o.tidy(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new J("Constants support is not implemented in RNN yet.");tr(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new ve({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!o.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new T(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new ve({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){o.tidy(()=>{if(!this.stateful)throw new dt("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new T("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>o.zeros([s,r])):this.states_=[o.zeros([s,this.cell.stateSize])];else if(e==null)o.dispose(this.states_),this.keptStates!=null&&(o.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>o.zeros([s,r])):this.states_[0]=o.zeros([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new T(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):o.dispose(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,l=[s,a];if(!o.arraysEqual(i.shape,l))throw new T(`State ${r} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>o.keep(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=zu(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let a=[],l=[];if(s!=null){t.initialState=s,a=a.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new ve({shape:u.shape}));l=l.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof at){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(u,t);return this.inputSpec=h,p}else return super.apply(e,t)}call(e,t){return o.tidy(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=Q(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new T(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:r},u=_u((m,g)=>{const x=this.cell.call([m].concat(g),l);return[x[0],x.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=u[0],h=u[1],p=u[2];this.stateful&&this.resetStates(p,r);const f=this.returnSequences?h:d;return this.returnState?[f].concat(p):f})}getInitialState(e){return o.tidy(()=>{let t=o.zeros(e.shape);return t=o.sum(t,[1,2]),t=ls(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Jo(t,[1,s]):t):this.cell.stateSize>1?[Jo(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===ut.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=st(r,s);return new e(Object.assign(t,{cell:i}))}}ut.className="RNN";o.registerClass(ut);class fs extends ne{}class To extends fs{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,$e(this.units,"units"),this.activation=Bt(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=me(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=me(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=me(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ge(e.kernelRegularizer),this.recurrentRegularizer=ge(e.recurrentRegularizer),this.biasRegularizer=ge(e.biasRegularizer),this.kernelConstraint=ke(e.kernelConstraint),this.recurrentConstraint=ke(e.recurrentConstraint),this.biasConstraint=ke(e.biasConstraint),this.dropout=xn([1,zt([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xn([1,zt([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=oe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return o.tidy(()=>{if(e=e,e.length!==2)throw new T(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vt({ones:()=>o.onesLike(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vt({ones:()=>o.onesLike(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const a=this.dropoutMask,l=this.recurrentDropoutMask;a!=null?i=xt(o.mul(e,a),this.kernel.read()):i=xt(e,this.kernel.read()),this.bias!=null&&(i=ct(i,this.bias.read())),l!=null&&(s=o.mul(s,l));let c=o.add(i,xt(s,this.recurrentKernel.read()));return this.activation!=null&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:_t(this.activation),useBias:this.useBias,kernelInitializer:be(this.kernelInitializer),recurrentInitializer:be(this.recurrentInitializer),biasInitializer:be(this.biasInitializer),kernelRegularizer:ue(this.kernelRegularizer),recurrentRegularizer:ue(this.recurrentRegularizer),biasRegularizer:ue(this.biasRegularizer),activityRegularizer:ue(this.activityRegularizer),kernelConstraint:Ie(this.kernelConstraint),recurrentConstraint:Ie(this.recurrentConstraint),biasConstraint:Ie(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}To.className="SimpleRNNCell";o.registerClass(To);class ki extends ut{constructor(e){e.cell=new To(e),super(e)}call(e,t){return o.tidy(()=>{this.cell.dropoutMask!=null&&(o.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(o.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}ki.className="SimpleRNN";o.registerClass(ki);class $o extends fs{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new T("GRUCell does not support reset_after parameter set to true.");this.units=e.units,$e(this.units,"units"),this.activation=Bt(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Bt(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=me(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=me(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=me(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ge(e.kernelRegularizer),this.recurrentRegularizer=ge(e.recurrentRegularizer),this.biasRegularizer=ge(e.biasRegularizer),this.kernelConstraint=ke(e.kernelConstraint),this.recurrentConstraint=ke(e.recurrentConstraint),this.biasConstraint=ke(e.biasConstraint),this.dropout=xn([1,zt([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xn([1,zt([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=oe(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return o.tidy(()=>{if(e=e,e.length!==2)throw new T(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vt({ones:()=>o.onesLike(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vt({ones:()=>o.onesLike(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u;0<this.dropout&&this.dropout<1&&(e=o.mul(e,i[0]));let d=xt(e,this.kernel.read());this.useBias&&(d=ct(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=o.mul(r,a[0]));const h=this.recurrentKernel.read(),[p,f]=o.split(h,[2*this.units,this.units],h.rank-1),m=xt(r,p),[g,x,b]=o.split(d,3,d.rank-1),[y,w]=o.split(m,2,m.rank-1);l=this.recurrentActivation.apply(o.add(g,y)),c=this.recurrentActivation.apply(o.add(x,w));const C=xt(o.mul(c,r),f);u=this.activation.apply(o.add(b,C));const v=o.add(o.mul(l,r),o.mul(o.add(1,o.neg(l)),u));return[v,v]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:_t(this.activation),recurrentActivation:_t(this.recurrentActivation),useBias:this.useBias,kernelInitializer:be(this.kernelInitializer),recurrentInitializer:be(this.recurrentInitializer),biasInitializer:be(this.biasInitializer),kernelRegularizer:ue(this.kernelRegularizer),recurrentRegularizer:ue(this.recurrentRegularizer),biasRegularizer:ue(this.biasRegularizer),activityRegularizer:ue(this.activityRegularizer),kernelConstraint:Ie(this.kernelConstraint),recurrentConstraint:Ie(this.recurrentConstraint),biasConstraint:Ie(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}$o.className="GRUCell";o.registerClass($o);class Ti extends ut{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new $o(e),super(e)}call(e,t){return o.tidy(()=>{this.cell.dropoutMask!=null&&(o.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(o.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Ti.className="GRU";o.registerClass(Ti);class ms extends fs{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,$e(this.units,"units"),this.activation=Bt(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Bt(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=me(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=me(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=me(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=ge(e.kernelRegularizer),this.recurrentRegularizer=ge(e.recurrentRegularizer),this.biasRegularizer=ge(e.biasRegularizer),this.kernelConstraint=ke(e.kernelConstraint),this.recurrentConstraint=ke(e.recurrentConstraint),this.biasConstraint=ke(e.biasConstraint),this.dropout=xn([1,zt([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xn([1,zt([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=oe(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;r=new(t=class extends Ze{apply(c,u){const d=i.apply([a]),h=new fo().apply([a]),p=i.apply([a*2]);return nl(nl(d,h),p)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return o.tidy(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new T(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vt({ones:()=>o.onesLike(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vt({ones:()=>o.onesLike(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;let c,u,d,h;0<this.dropout&&this.dropout<1&&(e=o.mul(e,a[0]));let p=xt(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=o.mul(r,l[0])),p=o.add(p,xt(r,this.recurrentKernel.read())),this.useBias&&(p=ct(p,this.bias.read()));const[f,m,g,x]=o.split(p,4,p.rank-1);c=this.recurrentActivation.apply(f),u=this.recurrentActivation.apply(m),d=o.add(o.mul(u,i),o.mul(c,this.activation.apply(g))),h=this.recurrentActivation.apply(x);const b=o.mul(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:_t(this.activation),recurrentActivation:_t(this.recurrentActivation),useBias:this.useBias,kernelInitializer:be(this.kernelInitializer),recurrentInitializer:be(this.recurrentInitializer),biasInitializer:be(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ue(this.kernelRegularizer),recurrentRegularizer:ue(this.recurrentRegularizer),biasRegularizer:ue(this.biasRegularizer),activityRegularizer:ue(this.activityRegularizer),kernelConstraint:Ie(this.kernelConstraint),recurrentConstraint:Ie(this.recurrentConstraint),biasConstraint:Ie(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}ms.className="LSTMCell";o.registerClass(ms);class $i extends ut{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ms(e),super(e)}call(e,t){return o.tidy(()=>{this.cell.dropoutMask!=null&&(o.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(o.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}$i.className="LSTM";o.registerClass($i);class No extends fs{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return o.tidy(()=>{e=e;let s=e.slice(1);const r=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?r.push(s.splice(0,l.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let a;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=r[l],l===0?a=[e[0]].concat(s):a=[a[0]].concat(s),a=c.call(a,t),i.push(a.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){tr(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{Zt(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(st(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return nr(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let a=0;a<s.weights.length;++a)t.push([s.weights[a],i[a]])}ei(t)}}No.className="StackedRNNCells";o.registerClass(No);function Vt(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,a=()=>i!=null?i(e(),t):Qc(e(),t),l=()=>us(a,e,s);return!r||r<=1?o.keep(l().clone()):Array(r).fill(void 0).map(l).map(u=>o.keep(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var _b=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class Bu extends ut{constructor(e){if(e.unroll)throw new J("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new J("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ve({ndim:5})]}call(e,t){return o.tidy(()=>{if(this.cell.dropoutMask!=null&&(o.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(o.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new T("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return o.tidy(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],a=o.zeros(i);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){o.tidy(()=>{if(!this.stateful)throw new dt("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new T("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>o.zeros(i)):this.states_=[o.zeros(i)];else if(e==null)o.dispose(this.states_),this.keptStates!=null&&(o.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>o.zeros(i)):this.states_[0]=o.zeros(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new T(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):o.dispose(this.states_);for(let l=0;l<this.states_.length;++l){const c=e[l],u=i;if(!o.arraysEqual(c.shape,u))throw new T(`State ${l} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>o.keep(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:a,dilationRate:l}=this.cell,c=t==="channelsFirst",u=e[c?3:2],d=e[c?4:3],h=ot(u,r[0],i,a[0],l[0]),p=ot(d,r[1],i,a[1],l[1]);return[...e.slice(0,2),...c?[s,h,p]:[h,p,s]]}}Bu.className="ConvRNN2D";class Ro extends ms{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,$e(this.filters,"filters"),this.kernelSize=gn(s,2,"kernelSize"),this.kernelSize.forEach(c=>$e(c,"kernelSize")),this.strides=gn(r||1,2,"strides"),this.strides.forEach(c=>$e(c,"strides")),this.padding=i||"valid",Xe(this.padding),this.dataFormat=a||"channelsLast",Ce(this.dataFormat),this.dilationRate=gn(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>$e(c,"dilationRate"))}build(e){var t;e=oe(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new T(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,a=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const u=this.biasInitializer,d=this.filters;c=new(t=class extends Ze{apply(p,f){const m=u.apply([d]),g=o.ones([d]),x=u.apply([d*2]);return qr([m,g,x])}},t.className="CustomInit",t)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return o.tidy(()=>{if(e.length!==3)throw new T(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],a=e[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vt({ones:()=>o.onesLike(r),rate:this.dropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,u=(_,z,V)=>!z||!z[V]?_:o.mul(z[V],_);let d=u(r,c,0),h=u(r,c,1),p=u(r,c,2),f=u(r,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vt({ones:()=>o.onesLike(i),rate:this.recurrentDropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=u(i,m,0),x=u(i,m,1),b=u(i,m,2),y=u(i,m,3);const w=3,[C,v,S,I]=o.split(this.kernel.read(),l,w),[k,$,N,R]=this.useBias?o.split(this.bias.read(),l):[null,null,null,null];d=this.inputConv(d,C,k,this.padding),h=this.inputConv(h,v,$,this.padding),p=this.inputConv(p,S,N,this.padding),f=this.inputConv(f,I,R,this.padding);const[F,O,L,A]=o.split(this.recurrentKernel.read(),l,w);g=this.recurrentConv(g,F),x=this.recurrentConv(x,O),b=this.recurrentConv(b,L),y=this.recurrentConv(y,A);const E=this.recurrentActivation.apply(o.add(d,g)),P=this.recurrentActivation.apply(o.add(h,x)),D=o.add(o.mul(P,a),o.mul(E,this.activation.apply(o.add(p,b)))),M=o.mul(this.recurrentActivation.apply(o.add(f,y)),this.activation.apply(D));return[M,M,D]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=_b(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=o.conv2d(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?ct(i,s,this.dataFormat):i}recurrentConv(e,t){return o.conv2d(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}Ro.className="ConvLSTM2DCell";o.registerClass(Ro);class Ni extends Bu{constructor(e){const t=new Ro(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Ni.className="ConvLSTM2D";o.registerClass(Ni);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ao extends ne{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);const s=Q(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return us(()=>Qc(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}Ao.className="Dropout";o.registerClass(Ao);class Ri extends Ao{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Ri.className="SpatialDropout1D";o.registerClass(Ri);class Ai extends ne{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,$e(this.units,"units"),this.activation=Bt(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=me(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=me(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ke(e.kernelConstraint),this.biasConstraint=ke(e.biasConstraint),this.kernelRegularizer=ge(e.kernelRegularizer),this.biasRegularizer=ge(e.biasRegularizer),this.activityRegularizer=ge(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=oe(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=oe(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);const s=Q(e),r=Hc(this.activation.getClassName());let i;return r!=null?i=xt(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=xt(s,this.kernel.read()),this.bias!=null&&(i=ct(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:_t(this.activation),useBias:this.useBias,kernelInitializer:be(this.kernelInitializer),biasInitializer:be(this.biasInitializer),kernelRegularizer:ue(this.kernelRegularizer),biasRegularizer:ue(this.biasRegularizer),activityRegularizer:ue(this.activityRegularizer),kernelConstraint:Ie(this.kernelConstraint),biasConstraint:Ie(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Ai.className="Dense";o.registerClass(Ai);class Di extends ne{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=oe(e);for(const t of e.slice(1))if(t==null)throw new T(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Mt(e,1)]}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);let s=Q(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=o.transpose(s,r)}return Yg(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Di.className="Flatten";o.registerClass(Di);class Ei extends ne{constructor(e){super(e),this.supportsMasking=!0,this.activation=Bt(e.activation)}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);const s=Q(e);return this.activation.apply(s)})}getConfig(){const e={activation:_t(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Ei.className="Activation";o.registerClass(Ei);class Fi extends ne{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return o.tidy(()=>(e=Q(e),jg(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Fi.className="RepeatVector";o.registerClass(Fi);class Oi extends ne{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,a=null;for(let c=0;c<r.length;++c){const u=r[c];if(this.isUnknown(u))if(a===null)a=c;else throw new T("Can only specifiy one unknown dimension.");else i*=u}const l=Mt(e);if(a!==null){if(i===0||l%i!==0)throw new T(s);r[a]=l/i}else if(l!==i)throw new T(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);const s=Q(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return o.reshape(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}Oi.className="Reshape";o.registerClass(Oi);class Li extends ne{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=rt(1,e.dims.length+1);if(!o.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ve({ndim:this.dims.length+1})]}computeOutputShape(e){e=oe(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return o.transpose(Q(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}Li.className="Permute";o.registerClass(Li);class Pi extends ne{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=Q(e);return o.any(o.notEqual(s,this.maskValue),-1)}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);const s=Q(e),a=o.any(o.notEqual(s,this.maskValue),-1,!0);return o.mul(s,o.cast(a,s.dtype))})}}Pi.className="Masking";o.registerClass(Pi);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Mi extends ne{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(ie(e.inputLength))}this.inputDim=e.inputDim,$e(this.inputDim,"inputDim"),this.outputDim=e.outputDim,$e(this.outputDim,"outputDim"),this.embeddingsInitializer=me(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ge(e.embeddingsRegularizer),this.activityRegularizer=ge(e.activityRegularizer),this.embeddingsConstraint=ke(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return o.tidy(()=>this.maskZero?(e=Q(e),o.notEqual(e,o.zerosLike(e))):null)}computeOutputShape(e){if(e=oe(e),this.inputLength==null)return[...e,this.outputDim];const t=ie(this.inputLength);if(t.length!==e.length-1)throw new T(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],a=e[r+1];if(i!=null&&a!=null&&i!==a)throw new T(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=a),s++}}return[e[0],...t,this.outputDim]}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);let s=Q(e);s.dtype!=="int32"&&(s=gt(s,"int32"));const r=Zc(this.embeddings.read(),o.reshape(s,[s.size]));return o.reshape(r,oe(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:be(this.embeddingsInitializer),embeddingsRegularizer:ue(this.embeddingsRegularizer),activityRegularizer:ue(this.activityRegularizer),embeddingsConstraint:Ie(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Mi.className="Embedding";o.registerClass(Mi);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cn extends ne{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new J}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],a=t[r];if(i==null||a==null||i<0||a<0)s.push(null);else if(i===1)s.push(a);else if(a===1)s.push(i);else{if(i!==a)throw new T("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[oe(e)]),e=e,e.length<2)throw new T(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Pt(t),t.length>1)throw new T(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const a=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&Pt(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return o.tidy(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=zt(r);for(let a of e){const l=a.rank;for(let c=0;c<i-l;++c)a=ls(a,1);s.push(a)}return this.mergeFunction(s)}else{let i=!1;for(const c of e){const u=c.rank;if(u==null){const d=c.shape,h=d[0],p=d.slice(1).concat([h]);let f=o.reshape(c,[h].concat(Mt(d.slice(1))));f=o.transpose(f,[1,0]),f=o.reshape(f,p),s.push(f),i=!0}else if(u>1){const d=rt(1,u).concat([0]);s.push(o.transpose(c,d)),i=!0}else s.push(c)}let a=this.mergeFunction(s);const l=a.rank;if(i){if(l==null){const c=a.shape,u=c.length,d=c[u-1],h=[d].concat(c.slice(0,c.length-1));a=o.reshape(o.transpose(o.reshape(a,[-1,d]),[1,0]),h)}else if(l>1){const c=[l-1].concat(rt(0,l-1));a=o.transpose(a,c)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Pt(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return o.tidy(()=>{if(t==null)return null;if(!Array.isArray(t))throw new T("`mask` should be an Array");if(!Array.isArray(e))throw new T("`inputs` should be an Array");if(t.length!==e.length)throw new T(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:o.expandDims(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=o.logicalAnd(s,t[r]);return s})}}class zi extends cn{constructor(e){super(e)}mergeFunction(e){return o.tidy(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=o.add(t,e[s]);return t})}}zi.className="Add";o.registerClass(zi);class _i extends cn{constructor(e){super(e)}mergeFunction(e){return o.tidy(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=o.mul(t,e[s]);return t})}}_i.className="Multiply";o.registerClass(_i);class Bi extends cn{constructor(e){super(e)}mergeFunction(e){return o.tidy(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=o.add(t,e[s]);return o.mul(1/e.length,t)})}}Bi.className="Average";o.registerClass(Bi);class Vi extends cn{constructor(e){super(e)}mergeFunction(e){return o.tidy(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=o.maximum(t,e[s]);return t})}}Vi.className="Maximum";o.registerClass(Vi);class Wi extends cn{constructor(e){super(e)}mergeFunction(e){return o.tidy(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=o.minimum(t,e[s]);return t})}}Wi.className="Minimum";o.registerClass(Wi);class Gi extends cn{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new T("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let a=!1;for(const l of s)if(o.arraysEqual(l,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new T("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return o.tidy(()=>qr(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new T("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new T("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new T("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new T(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return o.tidy(()=>{let s=!0;if(t.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(o.cast(o.onesLike(e[a]),"bool")):t[a].rank<e[a].rank?r.push(o.expandDims(t[a],-1)):r.push(t[a]);const i=o.concat(r,this.axis);return o.all(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}Gi.className="Concatenate";o.registerClass(Gi);function Bn(n,e){for(;n<0;)n+=e;return n}function Bb(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new J("batchDot is not implemented for tensors of 4D or higher rank yet");if(o.assert(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),o.assert(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new J("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return o.tidy(()=>{let a;if(s>r){a=s-r;const c=[];for(let u=0;u<a;++u)c.push(1);e=o.reshape(e,e.shape.concat(c))}else if(r>s){a=r-s;const c=[];for(let u=0;u<a;++u)c.push(1);n=o.reshape(n,n.shape.concat(c))}else a=0;let l;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?l=o.sum(o.mul(n,e),i[0]):l=o.sum(o.mul(o.transpose(n,[1,0]),e),i[1]);else{const c=i[0]!==n.shape.length-1,u=i[1]===e.shape.length-1;l=o.matMul(n,e,c,u)}if(a>0){let c;s>r?c=s+r-3:c=s-1;const u=[];for(let d=c;d<c+a;++d)u.push(d);l=o.squeeze(l,u)}return l.shape.length===1&&(l=o.expandDims(l,1)),l})}class Ui extends cn{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){o.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new J("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new T(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new T(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,a)=>Bn(i,e[a].shape.length)):r=[Bn(this.axes,t.shape.length),Bn(this.axes,s.shape.length)],this.normalize&&(t=qs(t,r[0]),s=qs(s,r[1])),Bb(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Bn(this.axes,e.length),Bn(this.axes,t.length)],s}computeOutputShape(e){o.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new J("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}Ui.className="Dot";o.registerClass(Ui);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Hi extends ne{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);const s=Q(e);return us(()=>o.add(po(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}Hi.className="GaussianNoise";o.registerClass(Hi);class qi extends ne{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t);const s=Q(e);return this.rate>0&&this.rate<1?us(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return o.mul(s,po(s.shape,1,i))},()=>s,t.training||!1):s})}}qi.className="GaussianDropout";o.registerClass(qi);class Xi extends ne{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Q(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return o.tidy(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return us(()=>{const i=Q(e),l=-1.6732632423543772*1.0507009873554805;let c=o.greaterEqual(o.randomUniform(s),this.rate);c=gt(c,"float32");const u=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-u*l*this.rate,h=o.add(o.mul(i,c),o.mul(o.add(c,-1),l));return o.add(o.mul(h,u),d)},()=>Q(e),t.training||!1)}return e})}}Xi.className="AlphaDropout";o.registerClass(Xi);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qn(n,e,t,s,r,i=.001){let a;if(n.rank===2)a=o.batchNorm2d(n,e,t,s,r,i);else if(n.rank===3)a=o.batchNorm3d(n,e,t,s,r,i);else if(n.rank===4)a=o.batchNorm4d(n,e,t,s,r,i);else throw new J(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function Vb(n,e,t,s,r=.001){return o.tidy(()=>{const i=o.moments(n,s),a=i.mean,l=i.variance;return[Qn(n,a,l,t,e,r),a,l]})}function Wb(n,e,t,s,r=.001){return o.tidy(()=>{const i=o.moments(n,s),a=i.mean,l=i.variance,c=[];for(const m of rt(0,n.rank))s.indexOf(m)!==-1?c.push(1):c.push(n.shape[m]);const u=o.reshape(a,c),d=o.reshape(l,c),h=e==null?null:o.reshape(e,c),p=t==null?null:o.reshape(t,c);return[Qn(n,u,d,p,h,r),a,l]})}function Gb(n,e,t,s,r=.001){return o.arraysEqual(s.slice().sort(),rt(0,n.rank-1))?Vb(n,e,t,s,r):Wb(n,e,t,s,r)}class ji extends ne{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=me(e.betaInitializer||"zeros"),this.gammaInitializer=me(e.gammaInitializer||"ones"),this.movingMeanInitializer=me(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=me(e.movingVarianceInitializer||"ones"),this.betaConstraint=ke(e.betaConstraint),this.gammaConstraint=ke(e.gammaConstraint),this.betaRegularizer=ge(e.betaRegularizer),this.gammaRegularizer=ge(e.gammaRegularizer)}build(e){e=oe(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new T(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ve({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return o.tidy(()=>{const s=t.training==null?!1:t.training,r=Q(e),i=r.shape,a=i.length,l=rt(0,a),c=this.axis>=0?this.axis:this.axis+a;l.splice(c,1);const u=Jt(1,a);u[c]=i[c];const d=l.slice();d.sort();const h=!o.arraysEqual(d,rt(0,a).slice(0,a-1)),p=()=>{if(h){const y=o.reshape(this.movingMean.read(),u),w=o.reshape(this.movingVariance.read(),u),C=this.center?o.reshape(this.beta.read(),u):null,v=this.scale?o.reshape(this.gamma.read(),u):null;return Qn(r,y,w,C,v,this.epsilon)}else return Qn(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return p();const[f,m,g]=Gb(r,this.gamma.read(),this.beta.read(),l,this.epsilon),x=(y,w,C)=>{o.tidy(()=>{const v=1-C,S=y.read(),I=o.mul(o.sub(S,w),v);y.write(o.sub(S,I))})};return(()=>{x(this.movingMean,m,this.momentum),x(this.movingVariance,g,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:be(this.betaInitializer),gammaInitializer:be(this.gammaInitializer),movingMeanInitializer:be(this.movingMeanInitializer),movingVarianceInitializer:be(this.movingVarianceInitializer),betaRegularizer:ue(this.betaRegularizer),gammaRegularizer:ue(this.gammaRegularizer),betaConstraint:Ie(this.betaConstraint),gammaConstraint:Ie(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}ji.className="BatchNormalization";o.registerClass(ji);class Ki extends ne{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=me(e.betaInitializer||"zeros"),this.gammaInitializer=me(e.gammaInitializer||"ones"),this.betaRegularizer=ge(e.betaRegularizer),this.gammaRegularizer=ge(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=oe(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Pt(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=Q(e),r=s.shape,i=r.length;return o.tidy(()=>{let{mean:l,variance:c}=o.moments(s,this.axis,!0);const u=Jt(1,i);for(const g of this.axis)u[g]=r[g];const d=g=>g!=null&&g.shape.length!==i?o.reshape(g,u):g;let h=this.scale?d(this.gamma.read()):null,p=this.center?d(this.beta.read()):null;const f=[],m=[];for(let g=0;g<i;++g)this.axis.indexOf(g)!==-1?(f.push(r[g]),m.push(1)):(f.push(1),m.push(r[g]));return l=o.tile(l,f),c=o.tile(c,f),h!=null&&(h=o.tile(h,m)),p!=null&&(p=o.tile(p,m)),Qn(s,l,c,p,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:be(this.betaInitializer),gammaInitializer:be(this.gammaInitializer),betaRegularizer:ue(this.betaRegularizer),gammaRegularizer:ue(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Ki.className="LayerNormalization";o.registerClass(Ki);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ub(n,e,t){return o.tidy(()=>{if(n.rank!==4)throw new T(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new T("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=it()),t!=="channelsLast"&&t!=="channelsFirst")throw new T(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],o.pad(n,s)})}class Yi extends ne{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?it():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new T(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new T(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new T(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new ve({ndim:4})]}computeOutputShape(e){e=oe(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return o.tidy(()=>Ub(Q(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Yi.className="ZeroPadding2D";o.registerClass(Yi);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Do(n,e,t,s,r,i){return o.tidy(()=>{Ce(r),Xc(i),Xe(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=it()),i==null&&(i="max"),n=bi(n,r);let a;const l=s==="same"?"same":"valid";return i==="max"?a=o.maxPool(n,e,t,l):a=o.avgPool(n,e,t,l),r==="channelsFirst"&&(a=o.transpose(a,[0,3,1,2])),a})}function Vu(n,e,t,s,r,i){return o.tidy(()=>{Ce(r),Xc(i),Xe(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=it()),i==null&&(i="max"),n=Pu(n,r);let a;const l=s==="same"?"same":"valid";return i==="max"?a=o.maxPool3d(n,e,t,l):a=o.avgPool3d(n,e,t,l),r==="channelsFirst"&&(a=o.transpose(a,[0,4,1,2,3])),a})}class Wu extends ne{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new T(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if($e(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new T(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);$e(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Xe(this.padding),this.inputSpec=[new ve({ndim:3})]}computeOutputShape(e){e=oe(e);const t=ot(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return o.tidy(()=>{this.invokeCallHook(e,t),e=ls(Q(e),2);const s=this.poolingFunction(Q(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return o.squeeze(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Zi extends Wu{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Ce(i),Xe(r),Do(e,t,s,r,i,"max")}}Zi.className="MaxPooling1D";o.registerClass(Zi);class Qi extends Wu{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Ce(i),Xe(r),Do(e,t,s,r,i,"avg")}}Qi.className="AveragePooling1D";o.registerClass(Qi);class Gu extends ne{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new T(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];$e(this.poolSize,"poolSize"),$e(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ce(this.dataFormat),Xe(this.padding),this.inputSpec=[new ve({ndim:4})]}computeOutputShape(e){e=oe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=ot(t,this.poolSize[0],this.padding,this.strides[0]),s=ot(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return o.tidy(()=>(this.invokeCallHook(e,t),this.poolingFunction(Q(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Ji extends Gu{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Ce(i),Xe(r),Do(e,t,s,r,i,"max")}}Ji.className="MaxPooling2D";o.registerClass(Ji);class ea extends Gu{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Ce(i),Xe(r),Do(e,t,s,r,i,"avg")}}ea.className="AveragePooling2D";o.registerClass(ea);class Uu extends ne{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new T(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];$e(this.poolSize,"poolSize"),$e(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ce(this.dataFormat),Xe(this.padding),this.inputSpec=[new ve({ndim:5})]}computeOutputShape(e){e=oe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=ot(t,this.poolSize[0],this.padding,this.strides[0]),s=ot(s,this.poolSize[1],this.padding,this.strides[1]),r=ot(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return o.tidy(()=>(this.invokeCallHook(e,t),this.poolingFunction(Q(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ta extends Uu{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Ce(i),Xe(r),Vu(e,t,s,r,i,"max")}}ta.className="MaxPooling3D";o.registerClass(ta);class na extends Uu{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Ce(i),Xe(r),Vu(e,t,s,r,i,"avg")}}na.className="AveragePooling3D";o.registerClass(na);class Hu extends ne{constructor(e){super(e),this.inputSpec=[new ve({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new J}}class sa extends Hu{constructor(e){super(e||{})}call(e,t){return o.tidy(()=>{const s=Q(e);return o.mean(s,1)})}}sa.className="GlobalAveragePooling1D";o.registerClass(sa);class oa extends Hu{constructor(e){super(e||{})}call(e,t){return o.tidy(()=>{const s=Q(e);return o.max(s,1)})}}oa.className="GlobalMaxPooling1D";o.registerClass(oa);class qu extends ne{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ce(this.dataFormat),this.inputSpec=[new ve({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new J}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ra extends qu{call(e,t){return o.tidy(()=>{const s=Q(e);return this.dataFormat==="channelsLast"?o.mean(s,[1,2]):o.mean(s,[2,3])})}}ra.className="GlobalAveragePooling2D";o.registerClass(ra);class ia extends qu{call(e,t){return o.tidy(()=>{const s=Q(e);return this.dataFormat==="channelsLast"?o.max(s,[1,2]):o.max(s,[2,3])})}}ia.className="GlobalMaxPooling2D";o.registerClass(ia);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Xu extends ne{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=st(r,s);delete t.layer;const a={layer:i};return Object.assign(a,t),new e(a)}}class aa extends Xu{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=oe(e),e.length<3)throw new T(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=oe(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return o.tidy(()=>(e=Q(e),_u((a,l)=>[Q(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}aa.className="TimeDistributed";o.registerClass(aa);function Hb(n){an(Gg,"BidirectionalMergeMode",n)}const qb="concat";class la extends Xu{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=st(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=st(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?qb:e.mergeMode,Hb(this.mergeMode),e.weights)throw new J("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Me(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=zu(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const a=[],l=[];if(s!=null){const u=s.length;if(u%2>0)throw new T("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,a.push(...s);const d=s.map(h=>new ve({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,u/2),this.backwardLayer.stateSpec=d.slice(u/2),l.push(...d)}if(r!=null)throw new J("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof at;for(const u of a)if(u instanceof at!==c)throw new T("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(u,t);return this.inputSpec=h,p}else return super.apply(e,t)}call(e,t){return o.tidy(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const c=s.slice(0,s.length/2),u=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:c})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=o.reverse(i,1));let l;return this.mergeMode==="concat"?l=qr([r,i]):this.mergeMode==="sum"?l=o.add(r,i):this.mergeMode==="ave"?l=o.mul(.5,o.add(r,i)):this.mergeMode==="mul"?l=o.mul(r,i):this.mergeMode==null&&(l=[r,i]),this.returnState?this.mergeMode==null?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Zt(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Zt(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=st(t.layer);if(delete t.layer,t.numConstants!=null)throw new J("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}la.className="Bidirectional";o.registerClass(la);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ca extends ne{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return o.tidy(()=>(e=Q(e),e.dtype!=="float32"&&(e=gt(e,"float32")),o.add(o.mul(e,this.scale),this.offset)))}}ca.className="Rescaling";o.registerClass(ca);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:Xb,cropAndResize:jb}=o.image;class ua extends ne{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,a,l,c){return o.tidy(()=>{let u,d=!1;const h=t/a,p=s/l,f=(r+t)/a,m=(i+s)/l,g=[h,p,f,m],x=[];e.rank===3?(d=!0,u=o.stack([e])):u=e;for(let v=0;v<u.shape[0];v++)x.push(g);const b=o.tensor(x,[x.length,4]),y=o.range(0,x.length,1,"int32"),C=jb(u,b,y,[r,i],"nearest");return gt(d?Q(o.unstack(C)):C,c)})}upsize(e,t,s,r){return o.tidy(()=>{const i=Xb(e,[t,s]);return gt(i,r)})}call(e,t){return o.tidy(()=>{const s=Q(e),r=s.dtype,i=s.shape,a=i[i.length-3],l=i[i.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let u=0;return l!==this.width&&(u=Math.floor((l-this.width)/2),u===0&&(u=1)),c>=0&&u>=0?this.centerCrop(s,c,u,this.height,this.width,a,l,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=oe(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}ua.className="CenterCrop";o.registerClass(ua);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Kb(n,e,t,s){let r=Q(n);if(r.dtype!=="int32"&&(r=gt(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=o.expandDims(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=o.expandDims(r,-1)),r.rank>2)throw new T(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const a=["multiHot","oneHot"].includes(e),l=r;let c;if(typeof s<"u"&&e==="count"?c=o.denseBincount(l,s,t,a):c=o.denseBincount(l,[],t,a),e!=="tfIdf")return c;if(s)return o.mul(c,s);throw new T("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class da extends ne{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=oe(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return o.tidy(()=>{e=Q(e),e.dtype!=="int32"&&(e=gt(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new T(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=Q(t.countWeights)}const r=o.max(e),i=o.min(e),a=o.greater(this.numTokens,r).bufferSync().get(0),l=o.greaterEqual(i,0).bufferSync().get(0);if(!(a&&l))throw new T(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Kb(e,this.outputMode,this.numTokens,s)})}}da.className="CategoryEncoding";o.registerClass(da);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Yb=["bilinear","nearest"],Cl=new Set(Yb);class ha extends ne{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(Cl.has(e.interpolation))this.interpolation=e.interpolation;else throw new T(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=oe(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return o.tidy(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return o.image.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return o.image.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Cl]} are supported`)})}}ha.className="Resizing";o.registerClass(ha);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ju{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}ju.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ku extends ne{constructor(e){super(e),this.randomGenerator=new ju(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}Ku.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Zb=["bilinear","nearest"],wl=new Set(Zb);class pa extends Ku{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new T(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new T(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new T(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(wl.has(s))this.interpolation=s;else throw new T(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=oe(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return o.tidy(()=>{const s=Q(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=o.randomUniform([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return o.image.resizeBilinear(e,a);case"nearest":return o.image.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...wl]} are supported`)}})}}pa.className="RandomWidth";o.registerClass(pa);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qb(n){return new Sn(n)}function Jb(n){return new mi(n)}function ey(n){return new hi(n)}function ty(n){return new pi(n)}function ny(n){return new fi(n)}function sy(n){return new xi(n)}function oy(n){return new gi(n)}function ry(n){return new ps(n)}function iy(n){return new Tn(n)}function ay(n){return new yi(n)}function ly(n){return new $n(n)}function cy(n){return new Ci(n)}function uy(n){return new wi(n)}function dy(n){return new vi(n)}function hy(n){return new Si(n)}function py(n){return new Ii(n)}function fy(n){return new Ei(n)}function my(n){return new Ai(n)}function gy(n){return new Ao(n)}function xy(n){return new Ri(n)}function by(n){return new Di(n)}function yy(n){return new Fi(n)}function Cy(n){return new Oi(n)}function wy(n){return new Li(n)}function vy(n){return new Mi(n)}function Sy(n){return new zi(n)}function Iy(n){return new Bi(n)}function ky(n){return new Gi(n)}function Ty(n){return new Vi(n)}function $y(n){return new Wi(n)}function Ny(n){return new _i(n)}function Ry(n){return new Ui(n)}function Ay(n){return new ji(n)}function Dy(n){return new Ki(n)}function Ey(n){return new Yi(n)}function fa(n){return new Qi(n)}function Fy(n){return fa(n)}function Oy(n){return fa(n)}function ma(n){return new ea(n)}function Ly(n){return ma(n)}function Py(n){return ma(n)}function ga(n){return new na(n)}function My(n){return ga(n)}function zy(n){return ga(n)}function _y(n){return new sa(n)}function By(n){return new ra(n)}function Yu(n){return new oa(n)}function Zu(n){return new ia(n)}function Qu(n){return new Zi(n)}function Ju(n){return new Ji(n)}function Vy(n){return new ta(n)}function Wy(n){return new Ti(n)}function Gy(n){return new $o(n)}function Uy(n){return new $i(n)}function Hy(n){return new ms(n)}function qy(n){return new ki(n)}function Xy(n){return new To(n)}function jy(n){return new Ni(n)}function Ky(n){return new Ro(n)}function Yy(n){return new ut(n)}function Zy(n){return new No(n)}function Qy(n){return new la(n)}function Jy(n){return new aa(n)}const eC=Yu,tC=Zu,nC=Qu,sC=Ju;function oC(n){return new Hi(n)}function rC(n){return new qi(n)}function iC(n){return new Xi(n)}function aC(n){return new Pi(n)}function lC(n){return new ca(n)}function cC(n){return new ua(n)}function uC(n){return new ha(n)}function dC(n){return new da(n)}function hC(n){return new pa(n)}const pC=Object.freeze(Object.defineProperty({__proto__:null,Layer:ne,RNN:ut,RNNCell:fs,activation:fy,add:Sy,alphaDropout:iC,average:Iy,averagePooling1d:fa,averagePooling2d:ma,averagePooling3d:ga,avgPool1d:Fy,avgPool2d:Ly,avgPool3d:My,avgPooling1d:Oy,avgPooling2d:Py,avgPooling3d:zy,batchNormalization:Ay,bidirectional:Qy,categoryEncoding:dC,centerCrop:cC,concatenate:ky,conv1d:ry,conv2d:iy,conv2dTranspose:ay,conv3d:ly,conv3dTranspose:cy,convLstm2d:jy,convLstm2dCell:Ky,cropping2D:dy,dense:my,depthwiseConv2d:py,dot:Ry,dropout:gy,elu:Jb,embedding:vy,flatten:by,gaussianDropout:rC,gaussianNoise:oC,globalAveragePooling1d:_y,globalAveragePooling2d:By,globalMaxPool1d:eC,globalMaxPool2d:tC,globalMaxPooling1d:Yu,globalMaxPooling2d:Zu,gru:Wy,gruCell:Gy,input:yu,inputLayer:Qb,layerNormalization:Dy,leakyReLU:ty,lstm:Uy,lstmCell:Hy,masking:aC,maxPool1d:nC,maxPool2d:sC,maxPooling1d:Qu,maxPooling2d:Ju,maxPooling3d:Vy,maximum:Ty,minimum:$y,multiply:Ny,permute:wy,prelu:ny,randomWidth:hC,reLU:ey,repeatVector:yy,rescaling:lC,reshape:Cy,resizing:uC,rnn:Yy,separableConv2d:uy,simpleRNN:qy,simpleRNNCell:Xy,softmax:sy,spatialDropout1d:xy,stackedRNNCells:Zy,thresholdedReLU:oy,timeDistributed:Jy,upSampling2d:hy,zeroPadding2d:Ey},Symbol.toStringTag,{value:"Module"}));function fC(n,e){return ai(n,e)}function mC(n,e){return uu(n,e)}function gC(n,e){return du(n,e)}function xC(n,e){return li(n,e)}function bC(n,e){return ci(n,e)}function yC(n,e){return cu(n,e)}function CC(n,e){return Zx(n,e)}function wC(n,e){return ii(n,e)}function vC(n,e){return vo(n,e)}function SC(n,e){return In(n,e)}function IC(n,e){return In(n,e)}function kC(n,e){return In(n,e)}function TC(n,e){return ln(n,e)}function $C(n,e){return ln(n,e)}function NC(n,e){return ln(n,e)}function RC(n,e){return Qx(n,e)}const AC=Object.freeze(Object.defineProperty({__proto__:null,MAPE:IC,MSE:$C,binaryAccuracy:fC,binaryCrossentropy:mC,categoricalAccuracy:xC,categoricalCrossentropy:bC,cosineProximity:wC,mape:kC,meanAbsoluteError:vC,meanAbsolutePercentageError:SC,meanSquaredError:TC,mse:NC,precision:yC,r2Score:RC,recall:CC,sparseCategoricalAccuracy:gC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const DC=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:$b},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function EC(n){return new hs(n)}function FC(n){return Ob(n)}function OC(n){return Lb(n)}const LC=Object.freeze(Object.defineProperty({__proto__:null,l1:FC,l1l2:EC,l2:OC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ed extends bn{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof St))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function Ns(n,e){return n<e}function vl(n,e){return n>e}class td extends ed{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new J("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Ns:this.mode==="max"?this.monitorFunc=vl:this.monitor.indexOf("acc")!==-1?this.monitorFunc=vl:this.monitorFunc=Ns,this.monitorFunc===Ns&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Ns?1/0:-1/0}async onEpochEnd(e,t){await Dt(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function PC(n){return new td(n)}const MC={earlyStopping:PC};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function zC(n,e){return Zs(n,e)}function Zs(n,e,t=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(yn(n)){const i=Array.isArray(n)?[]:{};s.add(n);for(const a in n){const l=n[a],c=Zs(l,e,t,s);i[a]=c}return s.delete(n),n.__proto__&&(i.__proto__=n.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,r.value),r.value}function _C(n,e=sd){return nd(n,e)}function nd(n,e,t=new Set){const s=n[0];if(t.has(s))throw new Error("Circular references are not supported.");const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(yn(s)){const i=Array.isArray(s)?[]:{};t.add(s);for(const a in s){const l=n.map(u=>u[a]),c=nd(l,e,t);i[a]=c}return t.delete(s),i}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function sd(n){return n===null?null:yn(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function od(n,e){const t=new Map;Zs(n,e,t);for(const r of Array.from(t.keys())){const i=t.get(r);if(o.isPromise(i)){const a=await i;t.set(r,a)}}return Zs(n,e,t)}function yn(n){let e=!1;if(o.env().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof o.Tensor)&&!(n instanceof Promise)&&!e)}function BC(n){return n==null||VC(n)||Array.isArray(n)||typeof n=="object"&&n instanceof o.Tensor||o.isTypedArray(n)}function VC(n){return n===null||typeof n!="object"&&typeof n!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function WC(n){return zC(n,GC)}function GC(n){return n instanceof o.Tensor?{value:n.clone(),recurse:!1}:yn(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class rd{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),s=this.get(t);return this.set(t,this.pop()),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Eo extends rd{constructor(){super(Eo.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),s=this.length();for(let r=0;r<s;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}Eo.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function id(n){return new qC(n)}function xa(n){return new XC(n)}function UC(n,e){return new ad(n,e)}function HC(n,e=Ot.FAIL){return new nw(n,e)}class Ne{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let s=await e.next();for(;!s.done;)t.push(s.value),s=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),s=e(t.value);for(;!t.done&&s;)t=await this.next(),s=e(t.value)}handleErrors(e){return new ew(this,e)}filter(e){return new QC(this,e)}map(e){return new JC(this,e)}mapAsync(e){return new Sl(this,e)}serialMapAsync(e){return new Sl(this,e).serial()}flatmap(e){return new tw(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new ZC(this,e,t)}columnMajorBatch(e,t=!0,s=sd){return this.rowMajorBatch(e,t).map(i=>_C(i,s))}concatenate(e,t){return new ad(id([this,e]),t)}take(e){return e<0||e==null?this:new YC(this,e)}skip(e){return e<0||e==null?this:new KC(this,e)}prefetch(e){return new ld(this,e)}shuffle(e,t){return new sw(this,e,t)}serial(){return new jC(this)}}class qC extends Ne{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:WC(e),done:!1}}}class XC extends Ne{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class jC extends Ne{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class KC extends Ne{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;o.dispose(e.value)}return this.upstream.next()}}class YC extends Ne{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class ZC extends Ne{constructor(e,t,s=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class QC extends Ne{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;o.dispose(e.value)}}}class JC extends Ne{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=o.getTensorsInContainer(e.value),s=this.transform(e.value),r=o.getTensorsInContainer(s);for(const i of t)o.isTensorInList(i,r)||i.dispose();return{value:s,done:!1}}}class ew extends Ne{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class Sl extends Ne{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=o.getTensorsInContainer(e.value),s=await this.transform(e.value),r=o.getTensorsInContainer(s);for(const i of t)o.isTensorInList(i,r)||i.dispose();return{value:s,done:!1}}}class ba extends Ne{constructor(){super(),this.outputQueue=new Eo,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class tw extends ba{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=o.getTensorsInContainer(e.value),s=this.transform(e.value),r=o.getTensorsInContainer(s);this.outputQueue.pushAll(s);for(const i of t)o.isTensorInList(i,r)||i.dispose();return!0}}class ad extends Ne{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var Ot;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Ot||(Ot={}));class nw extends Ne{constructor(e,t=Ot.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,s=0;function r(a){return a instanceof Ne?{value:a.next().then(c=>(t++,c.done&&s++,c.value)),recurse:!1}:{value:null,recurse:!0}}const i=await od(this.iterators,r);if(t===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case Ot.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Ot.SHORTEST:return{value:null,done:!0};case Ot.LONGEST:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class ld extends Ne{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new rd(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class sw extends ld{constructor(e,t,s){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=o.seedrandom.alea(s||o.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Nn{constructor(){this.size=null}batch(e,t=!0){const s=this;o.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Be(async()=>(await s.iterator()).columnMajorBatch(e,t,iw),r)}concatenate(e){const t=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,Be(async()=>(await t.iterator()).concatenate(await e.iterator()),s)}filter(e){const t=this;let s;return this.size===1/0?s=1/0:s=null,Be(async()=>(await t.iterator()).filter(r=>o.tidy(()=>e(r))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Be(async()=>(await t.iterator()).map(s=>o.tidy(()=>e(s))),this.size)}mapAsync(e){const t=this;return Be(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Be(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,Be(async()=>{const r=xa(async()=>({value:await t.iterator(),done:!1}));return UC(r.take(e))},s)}skip(e){const t=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,Be(async()=>(await t.iterator()).skip(e),s)}shuffle(e,t,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,i=o.seedrandom.alea(t||o.now().toString());return Be(async()=>{let a=i.int32();return s&&(a+=i.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){const t=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,Be(async()=>(await t.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}Nn.MAX_BUFFER_SIZE=1e4;function Be(n,e=null){return new class extends Nn{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function ow(n){return Be(async()=>id(n),n.length)}function rw(n){if(!yn(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return Be(async()=>{const t=await od(n,s=>{if(s instanceof Nn)return{value:s.iterator(),recurse:!1};if(yn(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return HC(t,Ot.SHORTEST)},e)}function iw(n){if(n===null)return null;const e=n[0];return BC(e)?{value:aw(n),recurse:!1}:{value:null,recurse:!0}}function aw(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof o.Tensor?o.stack(n):o.tensor(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class cd extends Nn{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */const Rs='"',Vn=Symbol("out"),Il=Symbol("field"),As=Symbol("quote"),Xo=Symbol("quoteafterquote"),kl=Symbol("quoteinquote");class ud extends Nn{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&o.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((r,i)=>(r[i]=r[i]+1||1,r),{}),s=Object.keys(t).filter(r=>t[r]>1);if(o.assert(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new cd(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(o.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},r={};for(let i=0;i<this.fullColumnNames.length;i++){const a=this.fullColumnNames[i],l=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!l)){const c=t[i];let u=null;if(c==="")if(l&&l.default!==void 0)u=l.default;else{if(l&&(l.required||l.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{const d=Number(c);if(isNaN(d))l&&l.dtype==="bool"?u=this.getBoolean(c):u=c;else if(!l||!l.dtype)u=d;else switch(l.dtype){case"float32":u=d;break;case"int32":u=Math.floor(d);break;case"bool":u=this.getBoolean(c);break;default:u=d}}l&&l.isLabel?r[a]=u:s[a]=u}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let r=0;const i=e.length;let a=Vn;for(let l=0;l<i;l++)switch(a){case Vn:switch(e.charAt(l)){case Rs:r=l+1,a=As;break;case this.delimiter:if(r=l+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),a=Vn;break;default:a=Il,r=l;break}break;case Il:switch(e.charAt(l)){case this.delimiter:s.push(e.substring(r,l)),a=Vn,r=l+1;break}break;case As:switch(e.charAt(l)){case Rs:a=Xo;break}break;case Xo:switch(e.charAt(l)){case this.delimiter:s.push(e.substring(r,l-1)),a=Vn,r=l+1;break;case Rs:a=As;break;default:a=kl;break}break;case kl:switch(e.charAt(l)){case Rs:a=As;break}break}if(a===Xo?s.push(e.substring(r,i-1)):s.push(e.substring(r)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ya extends Ne{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!o.env().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new ya(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(r=>{const i=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(i),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((r,i)=>s.set(r,i*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(o.sizeFromShape(t));return s.set(e,s.length-e.length),o.tensor(s,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Ca extends Ne{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=o.tensor1d([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,i=(1-s)/2,a=(1-r)/2,l=i+s,c=r+a;this.cropBox=o.tensor2d([a,i,c,l],[1,4])}else this.cropBox=o.tensor2d([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!o.env().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new Ca(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&o.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=o.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return o.tidy(()=>{const t=o.expandDims(o.cast(e,"float32"),0);let s;s=o.image.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return o.reshape(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class dd{}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class hd extends Ne{split(e){return new lw(this,e)}}class lw extends hd{constructor(e,t){super(),this.upstream=e,this.impl=new cw(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class cw extends ba{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class uw extends Ne{decodeUTF8(){return new dw(this)}}class dw extends hd{constructor(e){super(),this.upstream=e,this.impl=new hw(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class hw extends ba{constructor(e){if(super(),this.upstream=e,o.env().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return o.env().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class pd extends uw{constructor(e,t={}){super(),this.file=e,this.options=t,o.assert(e instanceof Uint8Array||(o.env().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{const i=new FileReader;i.onload=l=>{let c=i.result;if(c instanceof ArrayBuffer&&(c=new Uint8Array(c)),!(c instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(c)},i.onabort=l=>s(new Error("Aborted")),i.onerror=l=>s(new Error(l.type));const a=this.file.slice(this.offset,r);i.readAsArrayBuffer(a)}this.offset=r}),done:!1}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */async function pw(n,e={},t){let s,r;typeof n=="string"?s=n:(s=n.url,r=fw(n));const i=await(0,o.fetch)(s,r);if(i.ok){const a=new Uint8Array(await i.arrayBuffer());return new pd(a,e)}else throw new Error(i.statusText)}const fw=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function fd(n){return typeof n=="string"&&n.slice(0,7)==="file://"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class md extends dd{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(fd(this.input)&&o.env().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new pd(this.input,this.options)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class gd extends dd{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return fd(this.url)?new md(this.url,this.fileOptions).iterator():pw(this.url,this.fileOptions)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function mw(n,e={}){return new ud(new gd(n),e)}function gw(n){const e=xa(n);return Be(async()=>e)}function xw(n){return Be(async()=>{const e=await n();return xa(()=>e.next())})}async function bw(n,e){return Ca.create(n,e)}async function yw(n){return ya.create(n)}/** @license See the LICENSE file. */const xd="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cw=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:ud,Dataset:Nn,FileDataSource:md,TextLineDataset:cd,URLDataSource:gd,array:ow,csv:mw,func:gw,generator:xw,microphone:yw,version_data:xd,webcam:bw,zip:rw},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&o.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ww=o.whereImpl;class gs extends o.KernelBackend{nextDataId(){return gs.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new o.DataStorage(this,o.engine())}write(e,t,s){this.firstUse&&(this.firstUse=!1,o.env().get("IS_NODE")&&o.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&o.isString(s[0])){const i=s.map(a=>o.encodeString(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return It(r,i)}return o.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>o.decodeString(r));return o.buffer(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return o.buffer(e.shape,e.dtype,t)}makeOutput(e,t,s){return o.engine().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=o.now();return e(),{kernelMs:o.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){X([e],"where");const t=this.readSync(e.dataId);return ww(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}gs.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bd(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const vw=n=>{const{x:e}=n.inputs,t=n.backend;X(e,"abs");let s=new Float32Array(o.sizeFromShape(e.shape));const r=t.data.get(e.dataId).values;return s=bd(r),t.makeOutput(s,e.shape,e.dtype)},Sw={kernelName:o.Abs,backendName:"cpu",kernelFunc:vw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function we(n){return(e,t,s,r,i)=>{const a=o.assertAndGetBroadcastShape(e,t),l=a.length,c=o.computeStrides(a),u=o.sizeFromShape(a),d=o.getTypedArrayFromDType(i,u),h=e.length,p=t.length,f=o.computeStrides(e),m=o.computeStrides(t),g=o.getBroadcastDims(e,a),x=o.getBroadcastDims(t,a);if(g.length+x.length===0)for(let b=0;b<d.length;++b)d[b]=n(s[b%s.length],r[b%r.length]);else for(let b=0;b<d.length;++b){const y=o.indexToLoc(b,l,c),w=y.slice(-h);g.forEach(I=>w[I]=0);const C=o.locToIndex(w,h,f),v=y.slice(-p);x.forEach(I=>v[I]=0);const S=o.locToIndex(v,p,m);d[b]=n(s[C],r[S])}return[d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ve(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.makeTensorInfo(s.shape,"complex64"),c=t.data.get(l.dataId);return c.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",a)},l}const Iw={kernelName:o.Complex,backendName:"cpu",kernelFunc:Ve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qs(n,e,t="float32"){if(t==="complex64"){const r=Qs(n,e,"float32"),i=Qs(n,e,"float32");return Ve({inputs:{real:r,imag:i},backend:n})}const s=o.makeZerosTypedArray(o.sizeFromShape(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bt(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const kw={kernelName:o.Identity,backendName:"cpu",kernelFunc:bt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tn(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const Tw={kernelName:o.Real,backendName:"cpu",kernelFunc:tn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yd(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=o.toTypedArray([0],t),[i,a]=we((l,c)=>l!==c?1:0)(e,[],n,r,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Wt(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return bt({inputs:{x:r},backend:t});const d=Qs(t,r.shape,r.dtype),h=Wt({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),p=Ve({inputs:{real:h,imag:d},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),p}if(r.dtype==="complex64"){const d=tn({inputs:{input:r},backend:t}),h=Wt({inputs:{x:d},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(d),h}if(!o.hasEncodingLoss(r.dtype,i)){const d=bt({inputs:{x:r},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:i}}const a=t.data.get(r.dataId).values,[l,c,u]=yd(a,r.shape,r.dtype,i);return t.makeTensorInfo(l,c,u)}const $w={kernelName:o.Cast,backendName:"cpu",kernelFunc:Wt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Te(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a,b:l}=r,c=i;X([a,l],n);const u=c.data.get(a.dataId).values,d=c.data.get(l.dataId).values,h=a.dtype==="string"?kt(u):u,p=a.dtype==="string"?kt(d):d,f=s||a.dtype,[m,g]=e(a.shape,l.shape,h,p,f);return c.makeTensorInfo(g,f,m)}:({inputs:r,backend:i})=>{const{a,b:l}=r,c=i;if(a.dtype==="complex64"||l.dtype==="complex64"){const u=Wt({inputs:{x:a},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(u.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=c.data.get(h.dataId).values,m=c.data.get(p.dataId).values,g=Wt({inputs:{x:l},backend:c,attrs:{dtype:"complex64"}}),x=c.data.get(g.dataId),b=x.complexTensorInfos.real,y=x.complexTensorInfos.imag,w=c.data.get(b.dataId).values,C=c.data.get(y.dataId).values,[v,S,I]=t(a.shape,l.shape,f,m,w,C),k=c.makeTensorInfo(I,"float32",v),$=c.makeTensorInfo(I,"float32",S),N=Ve({inputs:{real:k,imag:$},backend:c});return c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(k),c.disposeIntermediateTensorInfo($),N}else{const u=c.data.get(a.dataId).values,d=c.data.get(l.dataId).values,h=s||a.dtype,[p,f]=e(a.shape,l.shape,u,d,h);return c.makeTensorInfo(f,h,p)}}}function wa(n){return(e,t,s,r,i,a)=>{const l=o.assertAndGetBroadcastShape(e,t),c=o.sizeFromShape(l),u=l.length,d=o.computeStrides(l),h=o.getTypedArrayFromDType("float32",c),p=o.getTypedArrayFromDType("float32",c),f=o.getBroadcastDims(e,l),m=o.getBroadcastDims(t,l),g=It(s,r),x=It(i,a),b=e.length,y=o.computeStrides(e),w=t.length,C=o.computeStrides(t);if(f.length+m.length===0)for(let v=0;v<h.length;v++){const S=v%g.length,I=v%x.length,k=n(g[S*2],g[S*2+1],x[I*2],x[I*2+1]);h[v]=k.real,p[v]=k.imag}else for(let v=0;v<h.length;v++){const S=o.indexToLoc(v,u,d),I=S.slice(-b);f.forEach(F=>I[F]=0);const k=o.locToIndex(I,b,y),$=S.slice(-w);m.forEach(F=>$[F]=0);const N=o.locToIndex($,w,C),R=n(g[k*2],g[k*2+1],x[N*2],x[N*2+1]);h[v]=R.real,p[v]=R.imag}return[h,p,l]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cd=we((n,e)=>n+e),Nw=wa((n,e,t,s)=>({real:n+t,imag:e+s})),Cn=Te(o.Add,Cd,Nw),Rw={kernelName:o.Add,backendName:"cpu",kernelFunc:Cn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function va(n,e,t,s,r){const i=o.sizeFromShape(s),a=o.makeZerosTypedArray(r,t);for(let l=0;l<n.length;l++){const c=n[l];if(c<0)throw new Error("Input x must be non-negative!");c>=r||(i>0?a[c]+=e[l]:a[c]+=1)}return a}function wd(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],a=o.buffer([r,t],e.dtype);for(let l=0;l<r;l++)for(let c=0;c<i;c++){const u=n.get(l,c);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(s?a.set(1,l,u):e.size>0?a.set(a.get(l,u)+e.get(l,c),l,u):a.set(a.get(l,u)+1,l,u))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vd=we((n,e)=>n&e),Aw=Te(o.BitwiseAnd,vd),Dw={kernelName:o.BitwiseAnd,backendName:"cpu",kernelFunc:Aw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yt(n){return(e,t,s)=>{const r=o.getArrayFromDType(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ae(n,e,t){const s=yt(e);return Gt(n,s,t)}function Gt(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;X(a,n);const l=i,c=l.data.get(a.dataId).values;let u;if(a.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");u=kt(c)}else u=c;const d=t||a.dtype,h=e(u,d,r);return l.makeTensorInfo(a.shape,d,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sd=yt(n=>Math.ceil(n)),Ew=Gt(o.Ceil,Sd),Fw={kernelName:o.Ceil,backendName:"cpu",kernelFunc:Ew};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Id(n,e,t,s){const r=o.getArrayFromDType(t,o.sizeFromShape(e));if(s&&t!=="string"){let i=0;n.forEach(a=>{const l=o.sizeFromShape(a.shape);r.set(a.vals,i),i+=l})}else{let i=0;n.forEach(a=>{const l=t==="string"?kt(a.vals):a.vals;let c=0;for(let u=0;u<a.shape[0];++u){const d=u*e[1]+i;for(let h=0;h<a.shape[1];++h)r[d+h]=l[c++]}i+=a.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kd=we((n,e)=>n===e?1:0),Td=Te(o.Equal,kd,null,"bool"),Ow={kernelName:o.Equal,backendName:"cpu",kernelFunc:Td};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $d=yt(n=>Math.exp(n)),Nd=Gt(o.Exp,$d,"float32"),Lw={kernelName:o.Exp,backendName:"cpu",kernelFunc:Nd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rd=yt(n=>Math.expm1(n)),Pw=Gt(o.Expm1,Rd),Mw={kernelName:o.Expm1,backendName:"cpu",kernelFunc:Pw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ad=yt(n=>Math.floor(n)),zw=Gt(o.Floor,Ad),_w={kernelName:o.Floor,backendName:"cpu",kernelFunc:zw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dd=we((n,e)=>Math.floor(n/e)),Bw=Te(o.FloorDiv,Dd,null,"int32"),Vw={kernelName:o.FloorDiv,backendName:"cpu",kernelFunc:Bw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(n,e,t,s,r,i,a,l,c){const u=o.buffer([s,i],t);for(let d=0;d<s;d++){const h=[];let p=0;for(let f=0;f<r;f++){const m=n[d*r+f];p+=m*a[f],h.push(m)}if(p<0||p>=c/i)throw new Error(`Invalid indices: ${h} does not index into ${l}`);for(let f=0;f<i;f++)u.values[d*i+f]=e.get(...e.indexToLoc(p*i+f))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fd(n,e,t){const s=o.buffer(t,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),l=a[0],c=a[2],u=e.locToIndex([l,c]);a[2]=e.values[u];const d=n.locToIndex(a);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Od=we((n,e)=>n>e?1:0),Ww=Te(o.Greater,Od,null,"bool"),Gw={kernelName:o.Greater,backendName:"cpu",kernelFunc:Ww};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ld=we((n,e)=>n>=e?1:0),Uw=Te(o.GreaterEqual,Ld,null,"bool"),Hw={kernelName:o.GreaterEqual,backendName:"cpu",kernelFunc:Uw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pd=we((n,e)=>n<e?1:0),qw=Te(o.Less,Pd,null,"bool"),Xw={kernelName:o.Less,backendName:"cpu",kernelFunc:qw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Md=we((n,e)=>n<=e?1:0),jw=Te(o.LessEqual,Md,null,"bool"),Kw={kernelName:o.LessEqual,backendName:"cpu",kernelFunc:jw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zd(n,e,t){const s=(e-n)/(t-1),r=o.makeZerosTypedArray(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _d=yt(n=>Math.log(n)),Yw=Gt(o.Log,_d),Zw={kernelName:o.Log,backendName:"cpu",kernelFunc:Yw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bd(n,e,t,s){const r=o.getTypedArrayFromDType(s,o.sizeFromShape(t));for(let i=0;i<r.length;++i){const a=i*e;let l=n[a];for(let c=0;c<e;++c){const u=n[a+c];(Number.isNaN(u)||u>l)&&(l=u)}r[i]=l}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vd=we((n,e)=>Math.max(n,e)),Qw=Te(o.Maximum,Vd),Jw={kernelName:o.Maximum,backendName:"cpu",kernelFunc:Qw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wd=we((n,e)=>Math.min(n,e)),e0=Te(o.Minimum,Wd),t0={kernelName:o.Minimum,backendName:"cpu",kernelFunc:e0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sa=we((n,e)=>n*e),n0=wa((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),Fo=Te(o.Multiply,Sa,n0),s0={kernelName:o.Multiply,backendName:"cpu",kernelFunc:Fo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gd(n,e,t){const s=o.createScalarValue(-1,t);return Sa([],e,s,n,t)}function o0(n){const{inputs:e,backend:t}=n,{x:s}=e;X(s,"neg");const r=t.data.get(s.dataId).values,[i,a]=Gd(r,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}const r0={kernelName:o.Neg,backendName:"cpu",kernelFunc:o0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ud=we((n,e)=>n!==e?1:0),i0=Te(o.NotEqual,Ud,null,"bool"),a0={kernelName:o.NotEqual,backendName:"cpu",kernelFunc:i0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ia(n,e,t,s,r){const i=e.length,a=o.sizeFromShape(e),l=o.computeStrides(e),c=o.computeStrides(r),u=o.getTypedArrayFromDType(t,o.sizeFromShape(r));for(let d=0;d<a;++d){const h=o.indexToLoc(d,i,l),p=new Array(h.length);for(let m=0;m<p.length;m++)p[m]=h[s[m]];const f=o.locToIndex(p,i,c);u[f]=n[d]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _e(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;X(r,"transpose");const a=r.shape.length,l=new Array(a);for(let h=0;h<l.length;h++)l[h]=r.shape[i[h]];const c=s.data.get(r.dataId).values,u=Ia(c,r.shape,r.dtype,i,l);return{dataId:s.write(u,l,r.dtype),shape:l,dtype:r.dtype}}const l0={kernelName:o.Transpose,backendName:"cpu",kernelFunc:_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hd(n,e,t,s){const[r,i]=o.computeOutAndReduceShapes(n,s),a=o.upcastType(e,"int32"),l=o.makeZerosTypedArray(o.sizeFromShape(r),a),c=o.sizeFromShape(i);for(let u=0;u<l.length;++u){const d=u*c;let h=1;for(let p=0;p<c;++p)h*=t[d+p];l[u]=h}return{outVals:l,outShape:r,outDtype:a}}function c0(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;X(r,"prod");const l=r.shape.length,c=o.parseAxisParam(i,r.shape),u=o.getAxesPermutation(c,l);let d=c,h=r;const p=[];u!=null&&(h=_e({inputs:{x:r},backend:t,attrs:{perm:u}}),p.push(h),d=o.getInnerMostAxes(d.length,l));const f=t.data.get(h.dataId).values,{outVals:m,outShape:g,outDtype:x}=Hd(h.shape,h.dtype,f,d);let b=g;return a&&(b=o.expandShapeToKeepDim(g,c)),p.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(b,x,m)}const u0={kernelName:o.Prod,backendName:"cpu",kernelFunc:c0};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d0(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=o.indexToLoc(r,e.length,o.computeStrides(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function h0(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function p0(n,e,t,s){const r=[];let i=0;const a=e.length-1+t.length,l=new Array(a).fill(null).map(()=>[0]);h0(t,s);let c=1;for(let u=0;u<e.length-1;++u){c*=e[u];const d=e[u+1];for(let h=1;h<c+1;++h)l[u].push(h*d)}for(let u=0;u<n.length;++u){let d=n[u],h=n[u]+1;for(let p=0;p<t.length;++p){const f=t[p],m=p+e.length-1;if(m>=0){const g=l[m],x=g[g.length-1]-f[d];for(let b=d;b<h;++b)l[m].push(f[b+1]+x)}d=f[d],h=f[h]}h!==d&&(r.push([d,h]),i+=h-d)}return{outSplits:l,valueSlices:r,numValues:i}}function f0(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=o.getArrayFromDType("int32",s);e.push(r),n[t].forEach((i,a)=>r[a]=i)}return e}function Tl(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function m0(n,e,t,s,r,i){const a=Tl(e,2)[1],l=Tl(i,2)[1];let c=0;for(const u of t)for(let d=u[0];d<u[1];++d){for(let h=0;h<s;++h)r[c*l+h]=n[d*a+h];++c}}function g0(n,e,t,s,r){const i=e.slice();i[0]=r;const a=o.getArrayFromDType(t,o.sizeFromShape(i)),l=n.length,c=l===0?0:l/e[0];return m0(n,e,s,c,a,i),[a,i]}function qd(n,e,t,s,r,i,a,l){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const c=e[0][0]-1;if(d0(i,a,c),s.length===0)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:d,valueSlices:h,numValues:p}=p0(i,a,n,u),f=f0(d),m=g0(t,s,r,h,p);return[f,m[0],m[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $l=2147483647;function Xd(n,e,t,s,r,i,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const l=e.length===0,c=r.length===0,u=a.length===0,d=[];l||d.push(e[0]),c||d.push(r[0]),u||d.push(a[0]);for(let x=1;x<d.length;++x)if(d[x]!==d[x-1])throw new Error("starts, limits, and deltas must have the same shape");const h=d.length===0?1:d[0],p=o.getArrayFromDType("int32",h+1);p[0]=0;for(let x=0;x<h;++x){const b=l?n[0]:n[x],y=c?s[0]:s[x],w=u?i[0]:i[x];if(w===0)throw new Error("Requires delta != 0");let C;if(w>0&&y<b||w<0&&y>b)C=0;else if(C=Math.ceil(Math.abs((y-b)/w)),C>$l)throw new Error(`Requires ((limit - start) / delta) <= ${$l}`);p[x+1]=p[x]+C}const f=p[h],m=o.getArrayFromDType(t,f);let g=0;for(let x=0;x<h;++x){const b=p[x+1]-p[x];let y=l?n[0]:n[x];const w=u?i[0]:i[x];for(let C=0;C<b;++C)m[g++]=y,y+=w}return[p,m]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ke=nt;class Js{constructor(e,t,s,r,i,a,l,c,u,d){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=l,this.rowPartitionValues=c,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=gc(d),this.raggedRank=xc(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ke.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ke.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ke.VALUE_ROWIDS:return Js.getMaxWidthValueRowID(t);case Ke.ROW_SPLITS:return Js.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Ke[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let a=1;a<t;++a){const l=e[a];l!==r&&(r=l,i=Math.max(a-s,i),s=a)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Rl(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;bc(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=mc(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let l=1;l<=this.raggedRank;++l)a[l]<0&&(a[l]=this.getMaxWidth(l));return a}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let a=0;for(let l=0;l<r;++l,a+=t)i.push(a);for(let l=r;l<e;++l)i.push(-1);return o.assert(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,a=[];for(let l=0;l<i-1;++l){const c=e[l+1]-e[l];let u=Math.min(r,c),d=t[l];d===-1&&(u=0);for(let h=0;h<u;++h)a.push(d),d+=s;for(let h=0;h<c-u;++h)a.push(-1)}if(i>0&&a.length!==e[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,a=[];if(i===0)return[];let l=0,c=e[0];if(c>=t.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${t.length}`);let u=t[c];a.push(u);for(let d=1;d<i;++d){const h=e[d];if(h===c)u>=0&&(++l,l<r?u+=s:u=-1);else{if(l=0,c=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Ke.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case Ke.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${Ke[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Ke.FIRST_DIM_SIZE:return e[0];case Ke.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ke.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ke[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let c=r.length-2;c>=0;--c)r[c]=r[c+1]*s[c+1];const i=Rl(s,!1),a=o.getArrayFromDType(this.valuesDType,o.sizeFromShape(i));if(r[0]*s[0]>0){let c=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)c=this.calculateOutputIndex(u-1,c,r[u],s[u]);this.setOutput(this.raggedRank,c,a,i)}return[i,a]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,a=s;let l=r.slice();l=l.slice(e+1);const c=o.sizeFromShape(l),u=t.length;let d=this.defaultValue;if(d.length!==c&&d.length!==1){const m=this.defaultValueShape;o.tidy(()=>{const g=o.reshape(d,m);d=o.broadcastTo(g,l).dataSync()})}let h=0,p=0,f=0;for(let m=0;m<=u;++m){let g=m<u?t[m]:-1;if(g===f){++f;continue}if(p<f){const x=i.subarray(h*c),b=a.subarray(p*c),y=(f-p)*c;Nl(b,x,y)}if(m>=u){const x=s.length;g=Math.floor(x/c)}if(g>f)if(this.defaultValue.length===1)a.subarray(f*c,g*c).fill(this.defaultValue[0]),f=g;else for(;g>f;){const x=a.slice(f*c);Nl(x,d,c),++f}g<0?(h=m+1,p=f):(h=m,p=f,f=p+1)}}}function Nl(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function Rl(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function jd(n,e,t,s,r,i,a,l,c,u){return new Js(n,e,t,s,r,i,a,l,c,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kd(n,e,t,s){const r=n===e,i=n<e&&t<0,a=e<n&&t>1;if(r||i||a)return o.makeZerosTypedArray(0,s);const l=Math.abs(Math.ceil((e-n)/t)),c=o.makeZerosTypedArray(l,s);e<n&&t===1&&(t=-1),c[0]=n;for(let u=1;u<c.length;u++)c[u]=c[u-1]+t;return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yd=yt(n=>1/Math.sqrt(n)),x0=Gt(o.Rsqrt,Yd),b0={kernelName:o.Rsqrt,backendName:"cpu",kernelFunc:x0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yt(n,e,t,s,r,i,a,l,c,u){const d=[s/r,r],h=n.values,p=e.values;if(s===0)return o.buffer(t,e.dtype);const f=c instanceof o.TensorBuffer?c:o.buffer(d,e.dtype);typeof c=="string"||typeof c=="number"?f.values.fill(c):typeof c=="boolean"&&f.values.fill(+c);for(let m=0;m<i;m++){const g=[];let x=0;for(let b=0;b<a;b++){const y=h[m*a+b];g.push(y),x+=y*l[b]}if(x<0||x>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let b=0;b<r;b++)u?f.values[x*r+b]+=p[m*r+b]:f.values[x*r+b]=e.rank===0?p[0]:p[m*r+b]}return f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0=yt(n=>1/(1+Math.exp(-n))),Zd=ae(o.Sigmoid,n=>1/(1+Math.exp(-n))),C0={kernelName:o.Sigmoid,backendName:"cpu",kernelFunc:Zd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qd(n,e,t,s,r){const i=Cr(s,e,t),a=o.sizeFromShape(t),l=o.computeStrides(s);if(i){const h=wr(e,l);return r==="string"?n.slice(h,h+a):n.subarray(h,h+a)}const c=r==="string"?kt(n):n,u=o.buffer(s,r,c),d=o.buffer(t,r);for(let h=0;h<d.size;++h){const p=d.indexToLoc(h),f=p.map((m,g)=>m+e[g]);d.set(u.get(...f),...p)}return r==="string"?zc(d.values):d.values}function nn(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s;X(r,"slice");const[l,c]=ao(r,i,a);br(r,l,c);const u=t.data.get(r.dataId).values,d=Qd(u,l,c,r.shape,r.dtype);return t.makeTensorInfo(c,r.dtype,d)}const w0={kernelName:o.Slice,backendName:"cpu",kernelFunc:nn};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jd(n,e,t,s,r,i,a){const l=e[0],c=i[0],u=new Array(c),d=new Array(l),h=e[1];if(c===0){if(l!==0)throw new Error(kc(l));const x=o.getArrayFromDType(t,0),b=o.getArrayFromDType(r,0);return[x,[0,h],b,u,d]}let p=!0,f=0;const m=new Array(c).fill(0);for(let x=0;x<l;++x){const b=n[x*h];if(b<0)throw new Error(Tc(x,b));if(b>=c)throw new Error($c(x,b,c));++m[b],p=p&&b>=f,f=b}let g=!0;for(let x=0;x<c;++x){const b=m[x]===0;u[x]=b,g=g&&!b,m[x]=Math.max(m[x],1),x>0&&(m[x]+=m[x-1])}if(g&&p){const x=n,b=s;for(let y=0;y<l;++y)d[y]=y;return[x,[l,h],b,u,d]}else{const x=m[c-1],b=o.getArrayFromDType(t,x*h),y=o.getArrayFromDType(r,x),w=new Array(c).fill(0);for(let C=0;C<l;++C){const v=n[C*h],S=w[v],I=(v===0?0:m[v-1])+S;w[v]++;for(let k=0;k<h;++k)b[I*h+k]=n[C*h+k];y[I]=s[C],d[C]=I}for(let C=0;C<c;++C)if(w[C]===0){const S=C===0?0:m[C-1];b[S*h+0]=C;for(let I=1;I<h;++I)b[S*h+I]=0;y[S]=a}return[b,[x,h],y,u,d]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eh(n,e,t,s,r){const i=o.sizeFromShape(s),a=e[0],l=r.length,c=[];let u=1,d=-1;for(let x=0;x<l;++x){const b=r[x];if(b===-1){if(d!==-1)throw new Error(Nc(d,x));d=x,c.push(1)}else{if(b<0)throw new Error(Rc(x,b));u*=b,c.push(b)}}if(d!==-1){if(u<=0)throw new Error(Ac());const x=Math.trunc(i/u);if(u*x!==i)throw new Error(Dc(s,c));c[d]=x}if(o.sizeFromShape(c)!==i)throw new Error(Ec(s,c));const p=s.length,f=[];if(p>0){f[p-1]=1;for(let x=p-2;x>=0;--x)f[x]=f[x+1]*s[x+1]}const m=[];if(l>0){m[l-1]=1;for(let x=l-2;x>=0;--x)m[x]=m[x+1]*c[x+1]}const g=o.getArrayFromDType(t,a*l);for(let x=0;x<a;++x){let b=0;for(let y=0;y<p;++y)b+=n[x*p+y]*f[y];for(let y=0;y<l;++y)g[x*l+y]=Math.trunc(b/m[y]),b%=m[y]}return[g,[a,l],c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(n,e,t,s,r,i=!1,a=0){const l=s.length,c=[e[0],n.length/e[0]],u=c[1],h=l>0?r[l-1]+1:0;if(h<0)throw new Error(Zo());const p=e.slice();p[0]=h;const f=p.reduce((w,C)=>w*C,1),m=o.getArrayFromDType(t,f);if(l===0)return h>0&&m.fill(a),[m,p];if(h<=0)throw new Error(Zo());let g=0,x=1,b=0,y=r[g];for(;;){let w=0;if(x<l){if(w=r[x],y===w){++x;continue}if(y>=w)throw new Error(Fc())}if(y<0||y>=h)throw new Error(Oc(y,h));y>b&&m.fill(a,b*u,y*u);for(let C=g;C<x;++C){const v=s[C];if(v<0||v>=c[0])throw new Error(Lc(C,s[C],c[0]));for(let S=0;S<u;S++)m[y*u+S]+=n[v*u+S]}if(i)for(let C=0;C<u;C++)m[y*u+C]/=x-g;if(g=x,++x,b=y+1,y=w,x>l)break}return b<h&&m.fill(a,b*u,h*u),[m,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0=yt(n=>Math.sqrt(n)),S0=ae(o.Sqrt,n=>Math.sqrt(n)),I0={kernelName:o.Sqrt,backendName:"cpu",kernelFunc:S0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const th=we((n,e)=>{const t=n-e;return t*t}),k0=Te(o.SquaredDifference,th),T0={kernelName:o.SquaredDifference,backendName:"cpu",kernelFunc:k0};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nh=yt((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),$0=Gt(o.StaticRegexReplace,nh),N0={kernelName:o.StaticRegexReplace,backendName:"cpu",kernelFunc:$0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sh(n,e,t,s){const r=o.buffer(n,e.dtype);for(let i=0;i<r.size;i++){const a=r.indexToLoc(i),l=new Array(a.length);for(let c=0;c<l.length;c++)l[c]=a[c]*t[c]+s[c];r.set(e.get(...l),...a)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R0{constructor(e,t,s,r,i,a){this.separator=o.encodeString(e),this.nGramWidths=t,this.leftPad=o.encodeString(s),this.rightPad=o.encodeString(r),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,a){for(let l=0;l<i;++l){const c=this.getPadWidth(a),u=Math.max(0,c-l),d=Math.max(0,c-(i-(l+1))),h=a-(u+d),p=t+(u>0?0:l-c);let f=0;f+=u*this.leftPad.length;for(let y=0;y<h;++y)f+=e[p+y].length;f+=d*this.rightPad.length;const m=u+d+h-1;f+=m*this.separator.length,s[r+l]=new Uint8Array(f);const g=s[r+l];let x=0;const b=y=>y.forEach(w=>g[x++]=w);for(let y=0;y<u;++y)b(this.leftPad),b(this.separator);for(let y=0;y<h-1;++y)b(e[p+y]),b(this.separator);if(h>0){b(e[p+h-1]);for(let y=0;y<d;++y)b(this.separator),b(this.rightPad)}else{for(let y=0;y<d-1;++y)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let c=t[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let u=1;u<r;++u){let d=t[u]>=c;if(d=d&&t[u]<=s,!d)throw new Error(`Invalid split value ${t[u]}, must be in [${c}, ${s}]`);c=t[u]}if(c!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`)}const i=r-1,a=o.getArrayFromDType("int32",r);if(s===0||r===0){const c=new Array(s);for(let u=0;u<=i;++u)a[u]=0;return[c,a]}a[0]=0;for(let c=1;c<=i;++c){const u=t[c]-t[c-1];let d=0;this.nGramWidths.forEach(h=>{d+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&d===0&&(d=1),a[c]=a[c-1]+d}const l=new Array(a[i]);for(let c=0;c<i;++c){const u=t[c];let d=a[c];if(this.nGramWidths.forEach(h=>{const p=t[c+1]-t[c],f=this.getNumNGrams(p,h);this.createNGrams(e,u,l,d,f,h),d+=f}),this.preserveShort&&d===a[c]){const h=t[c+1]-t[c];if(h===0)continue;const p=h+2*this.padWidth;this.createNGrams(e,u,l,d,1,p)}}return[l,a]}}function oh(n,e,t,s,r,i,a,l){return new R0(t,s,r,i,a,l).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let a=n.indexOf(i);for(;a!==-1;){const l=n.subarray(0,a);(!t||l.length!==0)&&s.push(l),n=n.subarray(a+1),a=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const a=n.subarray(r,i);(!t||a.length!==0)&&s.push(a),r=i+1}}function rh(n,e,t){const s=n.length,r=[];let i=0,a=0;const l=new Array(s);for(let p=0;p<s;++p){const f=r.length;A0(n[p],e,t,r);const m=r.length-f;l[p]=m,i+=m,a=Math.max(a,m)}const c=o.getArrayFromDType("int32",i*2),u=new Array(i),d=[s,a];let h=0;for(let p=0;p<s;++p)for(let f=0;f<l[p];++f)c[h*2]=p,c[h*2+1]=f,u[h]=r[h],++h;return[c,u,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ih(n,e){const t=o.getArrayFromDType("int32",n.length);for(let s=0;s<n.length;++s)t[s]=o.fingerPrint64(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ah=we((n,e)=>n-e),D0=wa((n,e,t,s)=>({real:n-t,imag:e-s})),Ta=Te(o.Sub,ah,D0),E0={kernelName:o.Sub,backendName:"cpu",kernelFunc:Ta};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lh(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=o.buffer(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),a=new Array(n.rank);for(let c=0;c<a.length;c++)a[c]=i[c]%n.shape[c];const l=n.locToIndex(a);s.values[r]=n.values[l]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gn=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function ch(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const l=s-t+1,c=e-t+1,u=Math.log(l),d=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*d*(l-d)/l)*Math.sign(c-l/2),p=Math.max(t,Math.floor(e-c*d/l+h)),f=Math.min(s,Math.floor(e+(l-c)*d/l+h));ch(n,e,p,f)}const r=n[e];let i=t,a=s;for(o.swap(n,t,e),Gn(n[s],r)>0&&o.swap(n,t,s);i<a;){for(o.swap(n,i,a),i++,a--;Gn(n[i],r)<0;)i=i+1;for(;Gn(n[a],r)>0;)a=a-1}Gn(n[t],r)===0?o.swap(n,t,a):(a=a+1,o.swap(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function uh(n,e,t,s,r){const i=e[e.length-1],[a,l]=[n.length/i,i],c=o.getTypedArrayFromDType(t,a*s),u=o.getTypedArrayFromDType("int32",a*s);for(let h=0;h<a;h++){const p=h*l,f=n.subarray(p,p+l);let m=new Array(f.length);f.forEach((y,w)=>m[w]={value:y,index:w}),s<m.length&&(ch(m,s),m=m.slice(0,s)),r&&m.sort(Gn);const g=h*s,x=c.subarray(g,g+s),b=u.subarray(g,g+s);for(let y=0;y<s;y++)x[y]=m[y].value,b[y]=m[y].index}const d=e.slice();return d[d.length-1]=s,[o.buffer(d,t,c),o.buffer(d,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dh(n,e,t,s){const r=o.parseAxisParam(e,t)[0],i=[1,t[0],1];for(let m=0;m<r;m++)i[0]*=t[m];i[1]=t[r];for(let m=r+1;m<t.length;m++)i[2]*=t[m];const a=new Map,l=new Int32Array(t[r]),c=new o.TensorBuffer(i,s,n),u=[],d=i[0]===1&&i[2]===1;for(let m=0;m<t[r];m++){let g;if(d)g=n[m].toString();else{const b=[];for(let y=0;y<i[0];y++)for(let w=0;w<i[2];w++)b.push(c.get(y,m,w));g=b.join(",")}const x=a.get(g);if(x!=null)l[m]=x;else{const b=a.size;a.set(g,b),l[m]=b,u.push(m)}}const h=i.slice();h[1]=a.size;const p=new o.TensorBuffer(h,s);u.forEach((m,g)=>{for(let x=0;x<i[0];x++)for(let b=0;b<i[2];b++)p.set(c.get(x,m,b),x,g,b)});const f=t.slice();return f[r]=h[1],{outputValues:p.values,outputShape:f,indices:l}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hh=Object.freeze(Object.defineProperty({__proto__:null,addImpl:Cd,bincountImpl:va,bincountReduceImpl:wd,bitwiseAndImpl:vd,castImpl:yd,ceilImpl:Sd,concatImpl:Id,equalImpl:kd,expImpl:$d,expm1Impl:Rd,floorDivImpl:Dd,floorImpl:Ad,gatherNdImpl:Ed,gatherV2Impl:Fd,greaterEqualImpl:Ld,greaterImpl:Od,lessEqualImpl:Md,lessImpl:Pd,linSpaceImpl:zd,logImpl:_d,maxImpl:Bd,maximumImpl:Vd,minimumImpl:Wd,multiplyImpl:Sa,negImpl:Gd,notEqualImpl:Ud,prodImpl:Hd,raggedGatherImpl:qd,raggedRangeImpl:Xd,raggedTensorToTensorImpl:jd,rangeImpl:Kd,rsqrtImpl:Yd,scatterImpl:Yt,sigmoidImpl:y0,simpleAbsImpl:bd,sliceImpl:Qd,sparseFillEmptyRowsImpl:Jd,sparseReshapeImpl:eh,sparseSegmentReductionImpl:ka,sqrtImpl:v0,squaredDifferenceImpl:th,staticRegexReplaceImpl:nh,stridedSliceImpl:sh,stringNGramsImpl:oh,stringSplitImpl:rh,stringToHashBucketFastImpl:ih,subImpl:ah,tileImpl:lh,topKImpl:uh,transposeImpl:Ia,uniqueImpl:dh},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const ph="4.22.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.registerBackend("cpu",()=>new gs,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fh=ae(o.Elu,n=>n>=0?n:Math.exp(n)-1),F0={kernelName:o.Elu,backendName:"cpu",kernelFunc:fh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mh(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;X([r],"leakyRelu");const a=o.sizeFromShape(r.shape),l=t.data.get(r.dataId).values,c=o.getTypedArrayFromDType("float32",a);for(let u=0;u<l.length;u++)c[u]=l[u]<0?i*l[u]:l[u];return t.makeTensorInfo(r.shape,"float32",c)}const O0={kernelName:o.LeakyRelu,backendName:"cpu",kernelFunc:mh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L0=we((n,e)=>n<0?e*n:n);function gh(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;X([s,r],"prelu");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,[l,c]=L0(s.shape,r.shape,i,a,"float32");return t.makeTensorInfo(c,"float32",l)}const P0={kernelName:o.Prelu,backendName:"cpu",kernelFunc:gh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xh=ae(o.Relu,n=>Math.max(0,n)),M0={kernelName:o.Relu,backendName:"cpu",kernelFunc:xh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bh=ae(o.Relu6,n=>Math.min(Math.max(0,n),6)),z0={kernelName:o.Relu6,backendName:"cpu",kernelFunc:bh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(n,e,t,s,r){if(t==="linear")return bt({inputs:{x:e},backend:n});if(t==="relu")return xh({inputs:{x:e},backend:n});if(t==="elu")return fh({inputs:{x:e},backend:n});if(t==="relu6")return bh({inputs:{x:e},backend:n});if(t==="prelu")return gh({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return mh({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return Zd({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=o.sizeFromShape(r.shape),l=o.inferFromImplicitShape(i,a),c=o.sizeFromShape(l);o.assert(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const u=t.data.get(r.dataId);if(u.complexTensorInfos!=null){const d=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;d.shape=l,h.shape=l}return{dataId:r.dataId,shape:l,dtype:r.dtype}}const _0={kernelName:o.Reshape,backendName:"cpu",kernelFunc:pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yh(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:l}=s;X([r,i],"matMul");const c=r.shape.length,u=i.shape.length,d=a?r.shape[c-2]:r.shape[c-1],h=l?i.shape[u-1]:i.shape[u-2],p=a?r.shape[c-1]:r.shape[c-2],f=l?i.shape[u-2]:i.shape[u-1],m=r.shape.slice(0,-2),g=i.shape.slice(0,-2),x=o.sizeFromShape(m),b=o.sizeFromShape(g),w=o.assertAndGetBroadcastShape(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([p,f]);o.assert(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${a} and transposeB=${l} must match.`);const C=a?[x,d,p]:[x,p,d],v=l?[b,f,h]:[b,h,f],S=pe({inputs:{x:r},backend:t,attrs:{shape:C}}),I=pe({inputs:{x:i},backend:t,attrs:{shape:v}}),k=a?S.shape[1]:S.shape[2],$=a?S.shape[2]:S.shape[1],N=l?I.shape[1]:I.shape[2],R=Math.max(x,b),F=t.data.get(S.dataId).values,O=t.data.get(I.dataId).values,L=o.computeStrides(S.shape),A=o.computeStrides(I.shape),[E,P,D]=a?[L[0],1,L[1]]:[L[0],L[1],1],[M,_,z]=l?[1,A[1],A[0]]:[A[1],1,A[0]],V=$*N,B=o.buffer([R,$,N],S.dtype),H=B.values,W=t.blockSize;for(let q=0;q<R;q++){const K=q%x,Z=q%b;for(let Y=0;Y<$;Y+=W){const ee=Math.min(Y+W,$);for(let te=0;te<N;te+=W){const re=Math.min(te+W,N);for(let de=0;de<k;de+=W){const ye=Math.min(de+W,k);for(let he=Y;he<ee;he++)for(let le=te;le<re;le++){let xe=0;for(let fe=de;fe<ye;fe++){const Ct=F[K*E+he*P+fe*D],Re=O[fe*M+le*_+Z*z];xe+=Ct*Re}H[q*V+(he*N+le)]+=xe}}}}}return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(I),t.makeTensorInfo(w,B.dtype,B.values)}const B0={kernelName:o.BatchMatMul,backendName:"cpu",kernelFunc:yh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:l}=e,{transposeA:c,transposeB:u,activation:d,leakyreluAlpha:h}=s;let p,f,m;const g=[];p=yh({inputs:{a:r,b:i},attrs:{transposeA:c,transposeB:u},backend:t}),a&&(f=Cn({inputs:{a:p,b:a},backend:t}),g.push(p),p=f),d&&(m=eo(t,p,d,l,h),g.push(p),p=m);for(const b of g)t.disposeIntermediateTensorInfo(b);return p}const W0={kernelName:o._FusedMatMul,backendName:"cpu",kernelFunc:V0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G0=ae(o.Acos,n=>Math.acos(n)),U0={kernelName:o.Acos,backendName:"cpu",kernelFunc:G0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H0=ae(o.Acosh,n=>Math.acosh(n)),q0={kernelName:o.Acosh,backendName:"cpu",kernelFunc:H0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0(n){const{inputs:e,backend:t}=n,s=e;X(e,"addN");const r=s.map(l=>t.data.get(l.dataId).values),i=o.buffer(s[0].shape,s[0].dtype),a=i.values;for(let l=0;l<s.length;l++){const c=r[l];for(let u=0;u<a.length;u++)a[u]+=c[u]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const j0={kernelName:o.AddN,backendName:"cpu",kernelFunc:X0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;X(r,"all");const l=o.parseAxisParam(i,r.shape);let c=l;const u=o.getAxesPermutation(c,r.shape.length);let d=r;u!=null&&(d=_e({inputs:{x:r},backend:t,attrs:{perm:u}}),c=o.getInnerMostAxes(c.length,r.shape.length)),o.assertAxesAreInnerMostDims("all",c,d.shape.length);const[h,p]=o.computeOutAndReduceShapes(d.shape,c),f=o.sizeFromShape(p),m=o.makeZerosTypedArray(o.sizeFromShape(h),d.dtype),g=t.data.get(d.dataId).values;for(let b=0;b<m.length;++b){const y=b*f;let w=g[y];for(let C=0;C<f;++C){const v=g[y+C];w=w&&v}m[b]=w}u!=null&&t.disposeIntermediateTensorInfo(d);const x=t.makeTensorInfo(h,d.dtype,m);if(a){const b=o.expandShapeToKeepDim(h,l),y=pe({inputs:{x},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(x),y}return x}const Y0={kernelName:o.All,backendName:"cpu",kernelFunc:K0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;X(r,"any");const l=o.parseAxisParam(i,r.shape);let c=l;const u=o.getAxesPermutation(c,r.shape.length);let d=r;u!=null&&(d=_e({inputs:{x:r},backend:t,attrs:{perm:u}}),c=o.getInnerMostAxes(c.length,r.shape.length)),o.assertAxesAreInnerMostDims("any",c,d.shape.length);const[h,p]=o.computeOutAndReduceShapes(d.shape,c),f=o.sizeFromShape(p),m=o.makeZerosTypedArray(o.sizeFromShape(h),d.dtype),g=t.data.get(d.dataId).values;for(let b=0;b<m.length;++b){const y=b*f;let w=g[y];for(let C=0;C<f;++C){const v=g[y+C];w=w||v}m[b]=w}u!=null&&t.disposeIntermediateTensorInfo(d);const x=t.makeTensorInfo(h,d.dtype,m);if(a){const b=o.expandShapeToKeepDim(h,l),y=pe({inputs:{x},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(x),y}return x}const Q0={kernelName:o.Any,backendName:"cpu",kernelFunc:Z0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;X(r,"argMax");let a=o.parseAxisParam(i,r.shape);const l=o.getAxesPermutation(a,r.shape.length);let c=r;const u=[];l!=null&&(c=_e({inputs:{x:r},backend:t,attrs:{perm:l}}),u.push(c),a=o.getInnerMostAxes(a.length,c.shape.length)),a=[a[0]],o.assertAxesAreInnerMostDims("argMax",a,c.shape.length);const[d,h]=o.computeOutAndReduceShapes(c.shape,a),p=o.sizeFromShape(d),f=o.makeZerosTypedArray(p,"int32"),m=o.sizeFromShape(h),g=t.data.get(c.dataId).values;for(let x=0;x<f.length;++x){const b=x*m;let y=g[b],w=0;for(let C=0;C<m;++C){const v=g[b+C];v>y&&(y=v,w=C)}f[x]=w}return u.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(d,"int32",f)}const ev={kernelName:o.ArgMax,backendName:"cpu",kernelFunc:J0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;X(r,"argMin");let a=o.parseAxisParam(i,r.shape);const l=o.getAxesPermutation(a,r.shape.length);let c=r;const u=[];l!=null&&(c=_e({inputs:{x:r},backend:t,attrs:{perm:l}}),u.push(c),a=o.getInnerMostAxes(a.length,c.shape.length)),a=[a[0]],o.assertAxesAreInnerMostDims("argMin",a,c.shape.length);const[d,h]=o.computeOutAndReduceShapes(c.shape,a),p=o.sizeFromShape(d),f=o.makeZerosTypedArray(p,"int32"),m=o.sizeFromShape(h),g=t.data.get(c.dataId).values;for(let x=0;x<f.length;++x){const b=x*m;let y=g[b],w=0;for(let C=0;C<m;++C){const v=g[b+C];v<y&&(y=v,w=C)}f[x]=w}return u.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(d,"int32",f)}const nv={kernelName:o.ArgMin,backendName:"cpu",kernelFunc:tv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sv=ae(o.Asin,n=>Math.asin(n)),ov={kernelName:o.Asin,backendName:"cpu",kernelFunc:sv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rv=ae(o.Asinh,n=>Math.asinh(n)),iv={kernelName:o.Asinh,backendName:"cpu",kernelFunc:rv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const av=ae(o.Atan,n=>Math.atan(n)),lv={kernelName:o.Atan,backendName:"cpu",kernelFunc:av};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cv=we((n,e)=>Math.atan2(n,e)),uv=Te(o.Atan2,cv),dv={kernelName:o.Atan2,backendName:"cpu",kernelFunc:uv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hv=ae(o.Atanh,n=>Math.atanh(n)),pv={kernelName:o.Atanh,backendName:"cpu",kernelFunc:hv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $a(n,e,t,s,r,i){const a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=o.buffer(r.outShape,t),x=g.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],w=r.outShape[3];for(let C=0;C<r.batchSize;++C){const v=C*b,S=C*s[0];for(let I=0;I<r.inChannels;++I)for(let k=0;k<r.outHeight;++k){const $=k*a-p,N=Math.max(0,$),R=Math.min(r.inHeight,d+$),F=v+k*y;for(let O=0;O<r.outWidth;++O){const L=O*l-f,A=Math.max(0,L),E=Math.min(r.inWidth,h+L);let P=m,D=0,M=0;for(let z=N;z<R;z+=c){const V=S+z*s[1];for(let B=A;B<E;B+=u){const H=V+B*s[2],W=n[H+I];i==="max"&&W>P?P=W:i==="avg"&&(D+=W,M++)}if(isNaN(P))break}const _=F+O*w+I;x[_]=i==="avg"?D/M:P}}}return g}function Ch(n,e,t,s,r=!1,i=!1){const a=o.buffer(s.outShape,"int32"),l=s.strideHeight,c=s.strideWidth,u=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterHeight,p=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,g=o.buffer(e,t,n);for(let x=0;x<s.batchSize;++x)for(let b=0;b<s.inChannels;++b)for(let y=0;y<s.outHeight;++y){const w=y*l-f;let C=w;for(;C<0;)C+=u;const v=Math.min(s.inHeight,h+w);for(let S=0;S<s.outWidth;++S){const I=S*c-m;let k=I;for(;k<0;)k+=d;const $=Math.min(s.inWidth,p+I);let N=Number.NEGATIVE_INFINITY,R=-1;for(let F=C;F<v;F+=u){const O=F-w;for(let L=k;L<$;L+=d){const A=L-I,E=g.get(x,F,L,b);E>N&&(N=E,r?R=i?((x*s.inHeight+F)*s.inWidth+L)*s.inChannels+b:(F*s.inWidth+L)*s.inChannels+b:R=O*p+A)}}a.set(R,x,y,S,b)}}return a}function wh(n,e,t,s,r,i){const a=r.strideDepth,l=r.strideHeight,c=r.strideWidth,u=r.dilationDepth,d=r.dilationHeight,h=r.dilationWidth,p=r.effectiveFilterDepth,f=r.effectiveFilterHeight,m=r.effectiveFilterWidth,g=r.padInfo.front,x=r.padInfo.top,b=r.padInfo.left,y=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=o.buffer(r.outShape,t),C=w.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],k=r.outShape[4];for(let $=0;$<r.batchSize;++$){const N=$*v,R=$*s[0];for(let F=0;F<r.inChannels;++F)for(let O=0;O<r.outDepth;++O){const L=O*a-g;let A=L;for(;A<0;)A+=u;const E=Math.min(r.inDepth,p+L),P=N+O*S;for(let D=0;D<r.outHeight;++D){const M=D*l-x;let _=M;for(;_<0;)_+=d;const z=Math.min(r.inHeight,f+M),V=P+D*I;for(let B=0;B<r.outWidth;++B){const H=B*c-b;let W=H;for(;W<0;)W+=h;const q=Math.min(r.inWidth,m+H),K=V+B*k;let Z=y,Y=0,ee=0;for(let re=A;re<E;re+=u){const de=R+re*s[1];for(let ye=_;ye<z;ye+=d){const he=de+ye*s[2];for(let le=W;le<q;le+=h){const xe=he+le*s[3],fe=n[xe+F];if(i==="max"&&fe>Z?Z=fe:i==="avg"&&(Y+=fe,ee++),isNaN(Z))break}if(isNaN(Z))break}if(isNaN(Z))break}const te=K+F;C[te]=i==="avg"?Y/Math.max(ee,1):Z}}}}return w}function fv(n,e){const t=o.buffer(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=e.padInfo.front,f=e.padInfo.top,m=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let x=0;x<e.inChannels;++x)for(let b=0;b<e.outDepth;++b){const y=b*s-p;let w=y;for(;w<0;)w+=a;const C=Math.min(e.inDepth,u+y);for(let v=0;v<e.outHeight;++v){const S=v*r-f;let I=S;for(;I<0;)I+=l;const k=Math.min(e.inHeight,d+S);for(let $=0;$<e.outWidth;++$){const N=$*i-m;let R=N;for(;R<0;)R+=c;const F=Math.min(e.inWidth,h+N);let O=Number.NEGATIVE_INFINITY,L=-1;for(let A=w;A<C;A+=a){const E=A-y;for(let P=I;P<k;P+=l){const D=P-S;for(let M=R;M<F;M+=c){const _=M-N,z=n.get(g,A,P,M,x);z>=O&&(O=z,L=E*d*h+D*d+_)}}}t.set(L,g,b,v,$,x)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;X(r,"avgPool");const{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=s,u=1;o.assert(o.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const d=o.computePool2DInfo(r.shape,i,a,u,l,c);let h;if(d.filterWidth===1&&d.filterHeight===1&&o.arraysEqual(d.inShape,d.outShape))h=bt({inputs:{x:r},backend:t});else{const p=t.data.get(r.dataId).values,f=o.computeStrides(r.shape),m=$a(p,r.shape,r.dtype,f,d,"avg");h=t.makeTensorInfo(d.outShape,r.dtype,m.values)}return h}const gv={kernelName:o.AvgPool,backendName:"cpu",kernelFunc:mv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:l,dimRoundingMode:c,dataFormat:u}=s;X(r,"avgPool3d");const d=o.computePool3DInfo(r.shape,i,a,1,l,c,u),h=t.data.get(r.dataId).values,p=wh(h,r.shape,r.dtype,o.computeStrides(r.shape),d,"avg");return t.makeTensorInfo(p.shape,"float32",p.values)}const bv={kernelName:o.AvgPool3D,backendName:"cpu",kernelFunc:xv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yv(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s;X([r,i],"avgPool3DGrad");const d=o.computePool3DInfo(i.shape,a,l,1,c,u),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,x=d.filterWidth,b=d.dilationDepth,y=d.dilationHeight,w=d.dilationWidth,C=d.effectiveFilterDepth,v=d.effectiveFilterHeight,S=d.effectiveFilterWidth,I=C-1-d.padInfo.front,k=S-1-d.padInfo.left,$=v-1-d.padInfo.top,N=o.buffer(i.shape,"float32"),R=1/(m*g*x),F=t.bufferSync(r);for(let O=0;O<d.batchSize;++O)for(let L=0;L<d.inChannels;++L)for(let A=0;A<d.inDepth;++A)for(let E=0;E<d.inHeight;++E)for(let P=0;P<d.inWidth;++P){const D=A-I,M=E-$,_=P-k;let z=0;for(let V=0;V<C;V+=b){const B=(D+V)/h;if(!(B<0||B>=d.outDepth||Math.floor(B)!==B))for(let H=0;H<v;H+=y){const W=(M+H)/p;if(!(W<0||W>=d.outHeight||Math.floor(W)!==W))for(let q=0;q<S;q+=w){const K=(_+q)/f;if(K<0||K>=d.outWidth||Math.floor(K)!==K)continue;const Z=F.get(O,B,W,K,L);z+=Z}}}N.set(z*R,O,A,E,P,L)}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const Cv={kernelName:o.AvgPool3DGrad,backendName:"cpu",kernelFunc:yv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wv(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;X([r,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:u}=s,d=o.computePool2DInfo(a.shape,l,c,1,u),h=d.strideHeight,p=d.strideWidth,f=d.filterHeight,m=d.filterWidth,g=d.dilationHeight,x=d.dilationWidth,b=d.effectiveFilterHeight,y=d.effectiveFilterWidth,w=y-1-d.padInfo.left,C=b-1-d.padInfo.top,v=o.buffer(a.shape,"float32"),S=1/(f*m),I=t.data.get(r.dataId).values,k=o.buffer(r.shape,"float32",I);for(let $=0;$<d.batchSize;++$)for(let N=0;N<d.inChannels;++N)for(let R=0;R<d.inHeight;++R)for(let F=0;F<d.inWidth;++F){const O=R-C,L=F-w;let A=0;for(let E=0;E<b;E+=g){const P=(O+E)/h;if(!(P<0||P>=d.outHeight||Math.floor(P)!==P))for(let D=0;D<y;D+=x){const M=(L+D)/p;if(M<0||M>=d.outWidth||Math.floor(M)!==M)continue;const _=k.get($,P,M,N);A+=_}}v.set(A*S,$,R,F,N)}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const vv={kernelName:o.AvgPoolGrad,backendName:"cpu",kernelFunc:wv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:a,mean:l,variance:c}=e;o.assert(l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),o.assert(a==null||l.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),o.assert(i==null||l.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),X([r,l,c,i,a],"batchNorm");let{varianceEpsilon:u}=s;u==null&&(u=.001);const d=t.data.get(r.dataId).values,h=t.data.get(l.dataId).values,p=t.data.get(c.dataId).values,f=i?t.data.get(i.dataId).values:new Float32Array([1]),m=a?t.data.get(a.dataId).values:new Float32Array([0]),g=new Float32Array(d.length),x=m.length,b=f.length,y=p.length,w=h.length;let C=0,v=0,S=0,I=0;for(let k=0;k<d.length;++k)g[k]=m[C++]+(d[k]-h[v++])*f[S++]/Math.sqrt(p[I++]+u),C>=x&&(C=0),v>=w&&(v=0),S>=b&&(S=0),I>=y&&(I=0);return t.makeTensorInfo(r.shape,r.dtype,g)}const Iv={kernelName:o.FusedBatchNorm,backendName:"cpu",kernelFunc:Sv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;X([r],"batchToSpaceND");const l=i.reduce((b,y)=>b*y),c=os(r.shape,i,l),u=rs(c.length,i.length),d=is(r.shape,i,l),h=$r(a,i.length),p=Nr(d,a,i.length),f=pe({inputs:{x:r},backend:t,attrs:{shape:c}}),m=_e({inputs:{x:f},backend:t,attrs:{perm:u}}),g=pe({inputs:{x:m},backend:t,attrs:{shape:d}}),x=nn({inputs:{x:g},backend:t,attrs:{begin:h,size:p}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),x}const Tv={kernelName:o.BatchToSpaceND,backendName:"cpu",kernelFunc:kv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,u=va(l,c,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,u)}const Nv={kernelName:o.Bincount,backendName:"cpu",kernelFunc:$v};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rv(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=o.assertAndGetBroadcastShape(Array.from(i),Array.from(a));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const Av={kernelName:o.BroadcastArgs,backendName:"cpu",kernelFunc:Rv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dv=ae(o.ClipByValue,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),Ev={kernelName:o.ClipByValue,backendName:"cpu",kernelFunc:Dv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fv=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(o.sizeFromShape(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,l=t.data.get(i.dataId).values,c=t.data.get(a.dataId).values;for(let u=0;u<l.length;u++){const d=l[u],h=c[u];s[u]=Math.hypot(d,h)}return t.makeOutput(s,e.shape,"float32")},Ov={kernelName:o.ComplexAbs,backendName:"cpu",kernelFunc:Fv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wn(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const Lv={kernelName:o.Imag,backendName:"cpu",kernelFunc:wn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vn(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=o.parseAxisParam(r,e[0].shape)[0],a=e.map(g=>g.shape);Ir(a,i);let l=mt(e.map(g=>g.shape),i);if(o.sizeFromShape(l)===0)return t.makeTensorInfo(l,e[0].dtype,[]);const c=e.filter(g=>o.sizeFromShape(g.shape)>0);if(c.length===1)return bt({inputs:{x:c[0]},backend:t});if(c[0].dtype==="complex64"){const g=c.map(C=>tn({inputs:{input:C},backend:t})),x=c.map(C=>wn({inputs:{input:C},backend:t})),b=vn({inputs:g,backend:t,attrs:{axis:i}}),y=vn({inputs:x,backend:t,attrs:{axis:i}}),w=Ve({inputs:{real:b,imag:y},backend:t});return g.forEach(C=>t.disposeIntermediateTensorInfo(C)),x.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(y),w}const u=c.map(g=>{const b=[-1,o.sizeFromShape(g.shape.slice(i))];return pe({inputs:{x:g},backend:t,attrs:{shape:b}})}),d=u.map(g=>({vals:t.data.get(g.dataId).values,shape:g.shape}));l=mt(u.map(g=>g.shape),1);const h=u[0].shape[0]===1,p=Id(d,l,e[0].dtype,h),f=mt(c.map(g=>g.shape),i),m=t.makeTensorInfo(f,e[0].dtype,p);return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const Pv={kernelName:o.Concat,backendName:"cpu",kernelFunc:vn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:l,dataFormat:c,dilations:u,dimRoundingMode:d}=s;X([r,i],"conv2d");const h=o.convertConv2DDataFormat(c),p=o.computeConv2DInfo(r.shape,i.shape,a,u,l,d,!1,h),f=p.filterHeight,m=p.filterWidth,g=p.dilationHeight,x=p.dilationWidth,b=p.padInfo.left,y=p.padInfo.top,w=p.dataFormat==="channelsLast",C=new o.TensorBuffer(p.outShape,r.dtype),v=o.computeStrides(r.shape),S=o.computeStrides(i.shape),I=v[0],k=w?v[1]:v[2],$=w?v[2]:1,N=w?1:v[1],R=C.strides[0],F=w?C.strides[1]:C.strides[2],O=w?C.strides[2]:1,L=w?1:C.strides[1],A=t.data.get(r.dataId).values,E=t.data.get(i.dataId).values,P=C.values;for(let D=0;D<p.batchSize;++D){const M=D*I,_=D*R;for(let z=0;z<p.outHeight;++z){const V=_+z*F,B=z*p.strideHeight-y;for(let H=0;H<f;++H){const W=B+H*g;if(W<0||W>=p.inHeight)continue;const q=H*S[0],K=M+W*k;for(let Z=0;Z<p.outWidth;++Z){const Y=V+Z*O,ee=Z*p.strideWidth-b;for(let te=0;te<m;++te){const re=ee+te*x;if(re<0||re>=p.inWidth)continue;const de=q+te*S[1],ye=K+re*$;let he=de;for(let le=0;le<p.inChannels;++le){const xe=A[ye+le*N];for(let fe=0;fe<p.outChannels;++fe)P[Y+fe*L]+=xe*E[he+fe];he+=p.outChannels}}}}}}return t.makeTensorInfo(C.shape,C.dtype,P)}const Mv={kernelName:o.Conv2D,backendName:"cpu",kernelFunc:vh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:l,dataFormat:c,dimRoundingMode:u,filterShape:d}=s;X([r,i],"conv2dBackpropFilter");const h=o.convertConv2DDataFormat(c),p=o.computeConv2DInfo(r.shape,d,a,1,l,u,!1,h),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:x}=p,b=p.dataFormat==="channelsLast",y=new o.TensorBuffer(p.filterShape,"float32"),w=p.padInfo.left,C=p.padInfo.top,v=t.data.get(r.dataId).values,S=t.data.get(i.dataId).values,I=new o.TensorBuffer(r.shape,r.dtype,v),k=new o.TensorBuffer(i.shape,i.dtype,S);for(let $=0;$<g;++$){const N=Math.max(0,Math.ceil((C-$)/f)),R=Math.min(p.outHeight,(p.inHeight+C-$)/f);for(let F=0;F<x;++F){const O=Math.max(0,Math.ceil((w-F)/m)),L=Math.min(p.outWidth,(p.inWidth+w-F)/m);for(let A=0;A<p.inChannels;++A)for(let E=0;E<p.outChannels;++E){let P=0;for(let D=0;D<p.batchSize;++D)for(let M=N;M<R;++M){const _=$+M*f-C;for(let z=O;z<L;++z){const V=F+z*m-w;b?P+=I.get(D,_,V,A)*k.get(D,M,z,E):P+=I.get(D,A,_,V)*k.get(D,E,M,z)}}y.set(P,$,F,A,E)}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const _v={kernelName:o.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:zv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bv(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:l,pad:c,dataFormat:u,dimRoundingMode:d}=s;X([r,i],"conv2dBackpropInput");const h=o.computeStrides(i.shape),p=o.computeStrides(r.shape);let f=o.convertConv2DDataFormat(u);const m=o.computeConv2DInfo(a,i.shape,l,1,c,d,!1,f),g=new o.TensorBuffer(m.inShape,"float32"),x=g.values,b=t.data.get(r.dataId).values,y=t.data.get(i.dataId).values,[w,C,v]=h,{batchSize:S,filterHeight:I,filterWidth:k,inChannels:$,inHeight:N,inWidth:R,outChannels:F,outHeight:O,outWidth:L,strideHeight:A,strideWidth:E}=m;f=m.dataFormat;const P=I-1-m.padInfo.top,D=k-1-m.padInfo.left,M=f==="channelsLast",_=g.strides[0],z=M?g.strides[1]:g.strides[2],V=M?g.strides[2]:1,B=M?1:g.strides[1],H=p[0],W=M?p[1]:p[2],q=M?p[2]:1,K=M?1:p[1];for(let Z=0;Z<S;++Z)for(let Y=0;Y<$;++Y)for(let ee=0;ee<N;++ee){const te=ee-P,re=Math.max(0,Math.ceil(te/A)),de=Math.min(O,(I+te)/A);for(let ye=0;ye<R;++ye){const he=ye-D,le=Math.max(0,Math.ceil(he/E)),xe=Math.min(L,(k+he)/E);let fe=0;for(let Re=re;Re<de;++Re){const $t=Re*A-te;for(let Ge=le;Ge<xe;++Ge){const Ht=Ge*E-he,Je=H*Z+W*Re+q*Ge,wt=w*(I-1-$t)+C*(k-1-Ht)+v*Y;for(let Nt=0;Nt<F;++Nt){const Rt=b[Je+K*Nt],At=y[wt+Nt];fe+=Rt*At}}}const Ct=_*Z+z*ee+V*ye+B*Y;x[Ct]=fe}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const Vv={kernelName:o.Conv2DBackpropInput,backendName:"cpu",kernelFunc:Bv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:l,dilations:c}=s;X([r,i],"conv3d");const u=o.computeConv3DInfo(r.shape,i.shape,a,c,l),{filterDepth:d,filterHeight:h,filterWidth:p,dilationDepth:f,dilationHeight:m,dilationWidth:g,padInfo:x}=u,b=x.front,y=x.left,w=x.top,C=new o.TensorBuffer(u.outShape,r.dtype),v=t.data.get(r.dataId).values,S=t.data.get(i.dataId).values,I=C.values,k=o.computeStrides(r.shape),$=o.computeStrides(i.shape);for(let N=0;N<u.batchSize;++N){const R=N*k[0],F=N*C.strides[0];for(let O=0;O<u.outDepth;++O){const L=F+O*C.strides[1],A=O*u.strideDepth-b;for(let E=0;E<d;++E){const P=A+E*f;if(P<0||P>=u.inDepth)continue;const D=E*$[0],M=R+P*k[1];for(let _=0;_<u.outHeight;++_){const z=L+_*C.strides[2],V=_*u.strideHeight-w;for(let B=0;B<h;++B){const H=V+B*m;if(H<0||H>=u.inHeight)continue;const W=D+B*$[1],q=M+H*k[2];for(let K=0;K<u.outWidth;++K){const Z=z+K*u.outChannels,Y=K*u.strideWidth-y;for(let ee=0;ee<p;++ee){const te=Y+ee*g;if(te<0||te>=u.inWidth)continue;const re=W+ee*$[2],de=q+te*u.inChannels;let ye=re;for(let he=0;he<u.inChannels;++he){const le=v[de+he];for(let xe=0;xe<u.outChannels;++xe)I[Z+xe]+=le*S[ye+xe];ye+=u.outChannels}}}}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const Gv={kernelName:o.Conv3D,backendName:"cpu",kernelFunc:Wv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:l,filterShape:c}=s;X([r,i],"conv3dBackpropFilterV2");const u=o.computeStrides(r.shape),d=o.computeStrides(i.shape),h=o.computeConv3DInfo(r.shape,c,a,1,l),p=h.strideDepth,f=h.strideHeight,m=h.strideWidth,g=h.filterDepth,x=h.filterHeight,b=h.filterWidth,y=new o.TensorBuffer(h.filterShape,"float32"),w=y.values,[C,v,S,I]=y.strides,k=t.data.get(i.dataId).values,[$,N,R,F]=d,O=t.data.get(r.dataId).values,[L,A,E,P]=u,D=h.padInfo.front,M=h.padInfo.left,_=h.padInfo.top;for(let z=0;z<g;++z){const V=Math.max(0,Math.ceil((D-z)/p)),B=Math.min(h.outDepth,(h.inDepth+D-z)/p),H=z*C;for(let W=0;W<x;++W){const q=Math.max(0,Math.ceil((_-W)/f)),K=Math.min(h.outHeight,(h.inHeight+_-W)/f),Z=W*v+H;for(let Y=0;Y<b;++Y){const ee=Math.max(0,Math.ceil((M-Y)/m)),te=Math.min(h.outWidth,(h.inWidth+M-Y)/m),re=Y*S+Z;for(let de=0;de<h.inChannels;++de){const ye=de*I+re;for(let he=0;he<h.outChannels;++he){let le=0;for(let xe=0;xe<h.batchSize;++xe){const fe=xe*L,Ct=xe*$;for(let Re=V;Re<B;++Re){const Ge=(z+Re*p-D)*A+fe,Ht=Re*N+Ct;for(let Je=q;Je<K;++Je){const Nt=(W+Je*f-_)*E+Ge,Rt=Je*R+Ht;for(let At=ee;At<te;++At){const zo=(Y+At*m-M)*P+Nt,_o=At*F+Rt;le+=O[zo+de]*k[_o+he]}}}}w[ye+he]=le}}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const Hv={kernelName:o.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:Uv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:l,inputShape:c}=s;X([r],"conv3dBackpropInputV2");const u=o.computeStrides(r.shape),d=o.computeStrides(i.shape),h=o.computeConv3DInfo(c,i.shape,l,1,a),p=new o.TensorBuffer(h.inShape,"float32"),f=p.values,[m,g,x,b]=p.strides,y=t.data.get(r.dataId).values,[w,C,v,S]=u,I=t.data.get(i.dataId).values,[k,$,N,R]=d,{batchSize:F,filterDepth:O,filterHeight:L,filterWidth:A,inChannels:E,inDepth:P,inHeight:D,inWidth:M,outChannels:_,outDepth:z,outHeight:V,outWidth:B,strideDepth:H,strideHeight:W,strideWidth:q}=h,K=O-1-h.padInfo.front,Z=L-1-h.padInfo.top,Y=A-1-h.padInfo.left;for(let ee=0;ee<F;++ee)for(let te=0;te<E;++te)for(let re=0;re<P;++re){const de=re-K,ye=Math.max(0,Math.ceil(de/H)),he=Math.min(z,(O+de)/H);for(let le=0;le<D;++le){const xe=le-Z,fe=Math.max(0,Math.ceil(xe/W)),Ct=Math.min(V,(L+xe)/W);for(let Re=0;Re<M;++Re){const $t=Re-Y,Ge=Math.max(0,Math.ceil($t/q)),Ht=Math.min(B,(A+$t)/q);let Je=0;for(let wt=ye;wt<he;++wt){const Nt=wt*H-de;for(let Rt=fe;Rt<Ct;++Rt){const At=Rt*W-xe;for(let zn=Ge;zn<Ht;++zn){const zo=zn*q-$t,_o=w*ee+C*wt+v*Rt+S*zn,of=k*(O-1-Nt)+$*(L-1-At)+N*(A-1-zo)+R*te;for(let Ss=0;Ss<_;++Ss){const rf=y[_o+Ss],af=I[of+Ss];Je+=rf*af}}}}f[m*ee+g*re+x*le+b*Re+te]=Je}}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const Xv={kernelName:o.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:qv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jv=ae(o.Cos,n=>Math.cos(n)),Kv={kernelName:o.Cos,backendName:"cpu",kernelFunc:jv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yv=ae(o.Cosh,n=>Math.cosh(n)),Zv={kernelName:o.Cosh,backendName:"cpu",kernelFunc:Yv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:l,method:c,extrapolationValue:u}=s,[d,h,p,f]=r.shape,m=i.shape[0],[g,x]=l,b=o.buffer([m,g,x,f],"float32"),y=t.data.get(i.dataId).values,w=t.data.get(a.dataId).values,C=t.data.get(r.dataId).values,v=o.computeStrides(r.shape),S=o.computeStrides(b.shape);for(let I=0;I<m;I++){const k=I*4,$=y[k],N=y[k+1],R=y[k+2],F=y[k+3],O=w[I];if(O>=d)continue;const L=g>1?(R-$)*(h-1)/(g-1):0,A=x>1?(F-N)*(p-1)/(x-1):0;for(let E=0;E<g;E++){const P=g>1?$*(h-1)+E*L:.5*($+R)*(h-1);if(P<0||P>h-1){for(let D=0;D<x;D++)for(let M=0;M<f;M++){const _=M+D*S[2]+E*S[1]+I*S[0];b.values[_]=u}continue}if(c==="bilinear"){const D=Math.floor(P),M=Math.ceil(P),_=P-D;for(let z=0;z<x;z++){const V=x>1?N*(p-1)+z*A:.5*(N+F)*(p-1);if(V<0||V>p-1){for(let q=0;q<f;q++){const K=q+z*S[2]+E*S[1]+I*S[0];b.values[K]=u}continue}const B=Math.floor(V),H=Math.ceil(V),W=V-B;for(let q=0;q<f;q++){let K=q+B*v[2]+D*v[1]+O*v[0];const Z=C[K];K=q+H*v[2]+D*v[1]+O*v[0];const Y=C[K];K=q+B*v[2]+M*v[1]+O*v[0];const ee=C[K];K=q+H*v[2]+M*v[1]+O*v[0];const te=C[K],re=Z+(Y-Z)*W,de=ee+(te-ee)*W;K=q+z*S[2]+E*S[1]+I*S[0],b.values[K]=re+(de-re)*_}}}else for(let D=0;D<x;++D){const M=x>1?N*(p-1)+D*A:.5*(N+F)*(p-1);if(M<0||M>p-1){for(let V=0;V<f;V++){const B=V+D*S[2]+E*S[1]+I*S[0];b.values[B]=u}continue}const _=Math.round(M),z=Math.round(P);for(let V=0;V<f;V++){const B=V+_*v[2]+z*v[1]+O*v[0],H=V+D*S[2]+E*S[1]+I*S[0];b.values[H]=C[B]}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const Jv={kernelName:o.CropAndResize,backendName:"cpu",kernelFunc:Qv};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:l}=s;X(r,"cumprod");const c=o.getAxesPermutation([i],r.shape.length);let u=r;c!=null&&(u=_e({inputs:{x:r},backend:t,attrs:{perm:c}}));const d=o.getInnerMostAxes(1,r.shape.length)[0];if(d!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${d}`);const h=o.upcastType(u.dtype,"int32"),p=o.makeOnesTypedArray(o.sizeFromShape(u.shape),h),f=t.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=l?(b,y)=>b+m-y-1:(b,y)=>b+y;for(let b=0;b<f.length;b+=m)for(let y=0;y<m;y++){const w=g(b,y);if(y===0)p[w]=a?1:f[w];else{const C=g(b,y-1);p[w]=a?f[C]*p[C]:f[w]*p[C]}}const x=t.makeTensorInfo(u.shape,h,p);if(c!=null){const b=o.getUndoAxesPermutation(c),y=_e({inputs:{x},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(u),y}return x}const tS={kernelName:o.Cumprod,backendName:"cpu",kernelFunc:eS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:l}=s;X(r,"cumsum");const c=o.getAxesPermutation([i],r.shape.length);let u=r;c!=null&&(u=_e({inputs:{x:r},backend:t,attrs:{perm:c}}));const d=o.getInnerMostAxes(1,r.shape.length)[0];if(d!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${d}`);const h=o.upcastType(u.dtype,"int32"),p=o.makeZerosTypedArray(o.sizeFromShape(u.shape),h),f=t.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=l?(b,y)=>b+m-y-1:(b,y)=>b+y;for(let b=0;b<f.length;b+=m)for(let y=0;y<m;y++){const w=g(b,y);if(y===0)p[w]=a?0:f[w];else{const C=g(b,y-1);p[w]=a?f[C]+p[C]:f[w]+p[C]}}const x=t.makeTensorInfo(u.shape,h,p);if(c!=null){const b=o.getUndoAxesPermutation(c),y=_e({inputs:{x},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(u),y}return x}const sS={kernelName:o.Cumsum,backendName:"cpu",kernelFunc:nS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:l}=s;if(r.shape.length===1){const c=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,d=va(c,u,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const c=t.bufferSync(r),u=t.bufferSync(i),d=wd(c,u,a,l);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const rS={kernelName:o.DenseBincount,backendName:"cpu",kernelFunc:oS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s;o.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const l=r.shape[0],c=r.shape[1],u=r.shape[2],d=r.shape[3],h=c*i,p=u*i,f=d/(i*i),m=t.data.get(r.dataId).values,g=new Float32Array(l*h*p*f);let x=0;for(let b=0;b<l;++b)for(let y=0;y<h;++y){const w=Math.floor(y/i),C=y%i;for(let v=0;v<p;++v){const S=Math.floor(v/i),I=v%i,k=(C*i+I)*f;for(let $=0;$<f;++$){const R=$+k+d*(S+u*(w+c*b));g[x++]=m[R]}}}return t.makeTensorInfo([l,h,p,f],r.dtype,g)}const aS={kernelName:o.DepthToSpace,backendName:"cpu",kernelFunc:iS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sh(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:l,dilations:c,dimRoundingMode:u}=s;X([r,i],"depthwiseConv2DNative");const d=o.computeStrides(r.shape),h=o.computeStrides(i.shape);let p=c;p==null&&(p=[1,1]),o.assert(o.eitherStridesOrDilationsAreOne(a,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);const f=o.computeConv2DInfo(r.shape,i.shape,a,p,l,u,!0),{filterHeight:m,filterWidth:g,dilationHeight:x,dilationWidth:b,padInfo:y}=f,w=y.left,C=y.top,v=f.outChannels/f.inChannels,S=new o.TensorBuffer(f.outShape,r.dtype),I=t.data.get(r.dataId).values,k=t.data.get(i.dataId).values,$=S.values;for(let N=0;N<f.batchSize;++N){const R=N*d[0],F=N*S.strides[0];for(let O=0;O<f.outHeight;++O){const L=F+O*S.strides[1],A=O*f.strideHeight-C;for(let E=0;E<m;++E){const P=A+E*x;if(P<0||P>=f.inHeight)continue;const D=E*h[0],M=R+P*d[1];for(let _=0;_<f.outWidth;++_){const z=L+_*S.strides[2],V=_*f.strideWidth-w;for(let B=0;B<g;++B){const H=V+B*b;if(H<0||H>=f.inWidth)continue;const W=D+B*h[1],q=M+H*f.inChannels;let K=z,Z=W;for(let Y=0;Y<f.inChannels;++Y){const ee=I[q+Y];for(let te=0;te<v;++te)$[K+te]+=ee*k[Z+te];K+=v,Z+=v}}}}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const lS={kernelName:o.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:Sh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:l,pad:c,dimRoundingMode:u,filterShape:d}=s;X([r,i],"depthwiseConv2dNativeBackpropFilter");const h=o.computeConv2DInfo(r.shape,d,a,l,c,u,!0),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,x=new o.TensorBuffer(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,w=h.outChannels/h.inChannels,C=t.data.get(r.dataId).values,v=new o.TensorBuffer(r.shape,r.dtype,C),S=t.data.get(i.dataId).values,I=new o.TensorBuffer(i.shape,i.dtype,S);for(let k=0;k<m;++k){const $=Math.max(0,Math.ceil((y-k)/p)),N=Math.min(h.outHeight,(h.inHeight+y-k)/p);for(let R=0;R<g;++R){const F=Math.max(0,Math.ceil((b-R)/f)),O=Math.min(h.outWidth,(h.inWidth+b-R)/f);for(let L=0;L<h.outChannels;++L){const A=Math.trunc(L/w),E=L%w;let P=0;for(let D=0;D<h.batchSize;++D)for(let M=$;M<N;++M){const _=k+M*p-y;for(let z=F;z<O;++z){const V=R+z*f-b;P+=v.get(D,_,V,A)*I.get(D,M,z,L)}}x.set(P,k,R,A,E)}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const uS={kernelName:o.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:cS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:l,pad:c,dimRoundingMode:u,inputShape:d}=s;X([r,i],"depthwiseConv2DNativeBackpropInput");const h=o.computeStrides(r.shape),p=o.computeStrides(i.shape),f=o.computeConv2DInfo(d,i.shape,a,l,c,u,!0),m=new o.TensorBuffer(f.inShape,"float32"),g=m.values,[x,b,y]=m.strides,w=t.data.get(r.dataId).values,[C,v,S]=h,I=t.data.get(i.dataId).values,[k,$,N]=p,{batchSize:R,filterHeight:F,filterWidth:O,inChannels:L,inHeight:A,inWidth:E,outChannels:P,outHeight:D,outWidth:M,strideHeight:_,strideWidth:z}=f,V=F-1-f.padInfo.top,B=O-1-f.padInfo.left,H=P/L;for(let W=0;W<R;++W)for(let q=0;q<L;++q)for(let K=0;K<A;++K){const Z=K-V,Y=Math.max(0,Math.ceil(Z/_)),ee=Math.min(D,(F+Z)/_);for(let te=0;te<E;++te){const re=te-B,de=Math.max(0,Math.ceil(re/z)),ye=Math.min(M,(O+re)/z);let he=0;for(let le=Y;le<ee;++le){const xe=le*_-Z;for(let fe=de;fe<ye;++fe){const Ct=fe*z-re,Re=C*W+v*le+S*fe,$t=k*(F-1-xe)+$*(O-1-Ct)+N*q;for(let Ge=0;Ge<H;++Ge){const Ht=q*H+Ge,Je=w[Re+Ht],wt=I[$t+Ge];he+=Je*wt}}}g[x*W+b*K+y*te+q]=he}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const hS={kernelName:o.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:dS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pS(n){const{inputs:e,backend:t}=n,{x:s}=e,r=o.sizeFromShape(s.shape),i=t.data.get(s.dataId).values,a=o.buffer([r,r],s.dtype),l=a.values;for(let u=0;u<i.length;u++)l[u*r+u]=i[u];const c=[...s.shape,...s.shape];return t.makeTensorInfo(c,a.dtype,a.values)}const fS={kernelName:o.Diag,backendName:"cpu",kernelFunc:pS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mS={kernelName:o.Dilation2D,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:a,dilations:l}=t,c=e,u=c.data.get(s.dataId).values,d=s.shape.length,h=c.data.get(r.dataId).values,p=r.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:x,outHeight:b,outWidth:y,padInfo:w,strideHeight:C,strideWidth:v,filterHeight:S,filterWidth:I,dilationHeight:k,dilationWidth:$,outShape:N}=o.computeDilation2DInfo(s.shape,r.shape,i,a,"NHWC",l),R=o.sizeFromShape(N),F=N.length,O=o.getArrayFromDType(s.dtype,R);for(let A=0;A<f;++A)for(let E=0;E<b;++E){const P=E*C-w.top;for(let D=0;D<y;++D){const M=D*v-w.left;for(let _=0;_<x;++_){let z=Number.MIN_SAFE_INTEGER;for(let B=0;B<S;++B){const H=P+B*k;if(H>=0&&H<m)for(let W=0;W<I;++W){const q=M+W*$;if(q>=0&&q<g){const K=o.locToIndex([A,H,q,_],d,o.computeStrides(s.shape)),Z=o.locToIndex([B,W,_],p,o.computeStrides(r.shape)),Y=u[K]+h[Z];Y>z&&(z=Y)}}}const V=o.locToIndex([A,E,D,_],F,o.computeStrides(N));O[V]=z}}}return{dataId:c.write(o.toTypedArray(O,s.dtype),N,s.dtype),shape:N,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gS={kernelName:o.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:l,dilations:c}=t,u=e,d=o.toNestedArray(s.shape,u.data.get(s.dataId).values),h=o.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:x,outWidth:b,padInfo:y,strideHeight:w,strideWidth:C,filterHeight:v,filterWidth:S,dilationHeight:I,dilationWidth:k,outShape:$}=o.computeDilation2DInfo(s.shape,r.shape,a,l,"NHWC",c);o.assert(i.rank===$.length,()=>`Error in ${o.Dilation2DBackpropFilter}, dy must have the same rank as output ${$.length}, but got ${i.rank}`);const N=o.toNestedArray($,u.data.get(i.dataId).values),R=o.makeZerosNestedTypedArray(r.shape,r.dtype);for(let O=0;O<p;++O)for(let L=0;L<x;++L){const A=L*w-y.top;for(let E=0;E<b;++E){const P=E*C-y.left;for(let D=0;D<g;++D){let M=Number.MIN_SAFE_INTEGER,_=0,z=0;for(let V=0;V<v;++V){const B=A+V*I;if(B>=0&&B<f)for(let H=0;H<S;++H){const W=P+H*k;if(W>=0&&W<m){const q=d[O][B][W][D]+h[V][H][D];q>M&&(M=q,_=V,z=H)}}}R[_][z][D]+=N[O][L][E][D]}}}return{dataId:u.write(o.toTypedArray(R,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xS={kernelName:o.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:l,dilations:c}=t,u=e,d=o.toNestedArray(s.shape,u.data.get(s.dataId).values),h=o.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:x,outWidth:b,padInfo:y,strideHeight:w,strideWidth:C,filterHeight:v,filterWidth:S,dilationHeight:I,dilationWidth:k,outShape:$}=o.computeDilation2DInfo(s.shape,r.shape,a,l,"NHWC",c);o.assert(i.rank===$.length,()=>`Error in ${o.Dilation2DBackpropInput}, dy must have the same rank as output ${$.length}, but got ${i.rank}`);const N=o.toNestedArray($,u.data.get(i.dataId).values),R=o.makeZerosNestedTypedArray(s.shape,s.dtype);for(let O=0;O<p;++O)for(let L=0;L<x;++L){const A=L*w-y.top;for(let E=0;E<b;++E){const P=E*C-y.left;for(let D=0;D<g;++D){let M=Number.MIN_SAFE_INTEGER,_=A<0?0:A,z=P<0?0:P;for(let V=0;V<v;++V){const B=A+V*I;if(B>=0&&B<f)for(let H=0;H<S;++H){const W=P+H*k;if(W>=0&&W<m){const q=d[O][B][W][D]+h[V][H][D];q>M&&(M=q,_=B,z=W)}}}R[O][_][z][D]+=N[O][L][E][D]}}}return{dataId:u.write(o.toTypedArray(R,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bS(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:a}=s,{contextOptions:l,imageOptions:c}=a||{},u=c?.alpha||1,d=l?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${l.contextType} is not supported by the CPU backend.`);const h=i.getContext(d,l?.contextAttributes||{});if(h==null)throw new Error(`Could not get the context with ${d} type.`);const[p,f]=r.shape.slice(0,2),m=r.shape.length===2?1:r.shape[2],g=t.data.get(r.dataId).values,x=r.dtype==="float32"?255:1,b=new Uint8ClampedArray(f*p*4);for(let w=0;w<p*f;++w){const C=[0,0,0,255*u];for(let S=0;S<m;S++){const I=g[w*m+S];if(r.dtype==="float32"){if(I<0||I>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${I}.`)}else if(r.dtype==="int32"&&(I<0||I>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${I}.`);m===1?(C[0]=I*x,C[1]=I*x,C[2]=I*x):C[S]=I*x}const v=w*4;b[v+0]=Math.round(C[0]),b[v+1]=Math.round(C[1]),b[v+2]=Math.round(C[2]),b[v+3]=Math.round(C[3])}i.width=f,i.height=p;const y=new ImageData(b,f,p);return h.putImageData(y,0,0),r}const yS={kernelName:o.Draw,backendName:"cpu",kernelFunc:bS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xs(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;X(r,"sum");let l;r.dtype==="bool"?l=Wt({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):l=bt({inputs:{x:r},backend:t});const c=l.shape.length,u=o.parseAxisParam(i,l.shape),d=o.getAxesPermutation(u,c);let h=u,p=l;d!=null&&(p=_e({inputs:{x:l},backend:t,attrs:{perm:d}}),h=o.getInnerMostAxes(h.length,c)),o.assertAxesAreInnerMostDims("sum",h,p.shape.length);const[f,m]=o.computeOutAndReduceShapes(p.shape,h),g=o.upcastType(p.dtype,"int32");let x=Qs(t,f,g);const b=o.sizeFromShape(m),y=t.data.get(x.dataId).values,w=t.data.get(p.dataId).values;for(let C=0;C<y.length;++C){const v=C*b;let S=0;for(let I=0;I<b;++I)S+=w[v+I];y[C]=S}if(a){const C=o.expandShapeToKeepDim(x.shape,u),v=x;x=pe({inputs:{x},backend:t,attrs:{shape:C}}),t.disposeIntermediateTensorInfo(v)}return t.disposeIntermediateTensorInfo(l),d!=null&&t.disposeIntermediateTensorInfo(p),x}const CS={kernelName:o.Sum,backendName:"cpu",kernelFunc:xs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:l,idDims:c}=Pr(r,i.length);zr(a.length,c,i);const{path:u,steps:d}=_r(l,c),h=d.length;let p=null,f=a.length;const m=[];for(let g=0;g<h;++g){for(const x of d[g]){const{permutationIndices:b,expandDims:y}=Mr(f,c[x]);let w;Br(b)?w=i[x]:(w=_e({inputs:{x:i[x]},backend:t,attrs:{perm:b}}),m.push(w));const C=w.shape.slice();for(let v=0;v<y.length;++v)C.splice(y[v],0,1);o.arraysEqual(w.shape,C)||(w=pe({inputs:{x:w},backend:t,attrs:{shape:C}}),m.push(w)),p===null?p=w:(p=Fo({inputs:{a:w,b:p},backend:t}),m.push(p))}g<h-1&&(u[g]>=0&&(p=xs({inputs:{x:p},backend:t,attrs:{axis:u[g]-(a.length-f),keepDims:!1}}),m.push(p)),f--)}for(const g of m)g!==p&&t.disposeIntermediateTensorInfo(g);return p}const vS={kernelName:o.Einsum,backendName:"cpu",kernelFunc:wS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SS(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;X([s,r],"eluGrad");const i=new Float32Array(o.sizeFromShape(r.shape)),a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values;for(let c=0;c<a.length;++c){const u=a[c];u>=0?i[c]=l[c]:i[c]=l[c]*(u+1)}return t.makeTensorInfo(r.shape,"float32",i)}const IS={kernelName:o.EluGrad,backendName:"cpu",kernelFunc:SS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kS=Rr,TS=Ar,$S=Dr,NS=Er,RS=Fr,AS=Or,DS=ae(o.Erf,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+kS*t);return e*(1-((((AS*s+RS)*s+NS)*s+$S)*s+TS)*s*Math.exp(-t*t))}),ES={kernelName:o.Erf,backendName:"cpu",kernelFunc:DS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function to(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,a=r.shape.length,l=r.shape.slice();let c=i;return i<0&&(o.assert(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),c=a+i+1),l.splice(c,0,1),pe({inputs:{x:r},backend:t,attrs:{shape:l}})}const FS={kernelName:o.ExpandDims,backendName:"cpu",kernelFunc:to};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OS=we((n,e)=>n/e),Na=Te(o.RealDiv,OS),ar={kernelName:o.RealDiv,backendName:"cpu",kernelFunc:Na};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ih(n,e,t){const s=n.shape,r=s[0],i=s[1],a=t.data.get(n.dataId),l=a.complexTensorInfos.real,c=a.complexTensorInfos.imag,u=[r,i],d=o.sizeFromShape(u),h=o.getTypedArrayFromDType("float32",d),p=o.getTypedArrayFromDType("float32",d);for(let x=0;x<r;x++){const b=nn({inputs:{x:l},backend:t,attrs:{begin:[x,0],size:[1,i]}}),y=nn({inputs:{x:c},backend:t,attrs:{begin:[x,0],size:[1,i]}}),w=Ve({inputs:{real:b,imag:y},backend:t}),{real:C,imag:v}=LS(w,e,t),S=It(C,v);for(let I=0;I<i;I++){const k=Lr(S,I);h[x*i+I]=k.real,p[x*i+I]=k.imag}t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(w)}const f=t.makeTensorInfo(u,"float32",h),m=t.makeTensorInfo(u,"float32",p),g=Ve({inputs:{real:f,imag:m},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),g}function LS(n,e,t){const s=o.sizeFromShape(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,a=t.data.get(r.complexTensorInfos.imag.dataId).values;if(PS(s)){const l=lr(i,a,s,e,t),c=[n.shape[0],n.shape[1]];if(e){const u=t.makeTensorInfo(c,"float32",l.real),d=t.makeTensorInfo(c,"float32",l.imag),h=t.makeTensorInfo([],"float32",o.createScalarValue(s,"float32")),p=bt({inputs:{x:h},backend:t}),f=ar.kernelFunc({inputs:{a:u,b:h},backend:t}),m=ar.kernelFunc({inputs:{a:d,b:p},backend:t}),g=t.data.get(f.dataId).values,x=t.data.get(m.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),{real:g,imag:x}}return l}else{const l=It(i,a),c=MS(l,s,e);return yc(c)}}function PS(n){return(n&n-1)===0}function lr(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=It(n,e),a=t/2,l=Cc(i),c=l.real,u=l.imag,d=[c.length],h=r.makeTensorInfo(d,"float32",c),p=r.makeTensorInfo(d,"float32",u),f=Ve({inputs:{real:h,imag:p},backend:r}),m=wc(i),g=m.real,x=m.imag,b=[g.length],y=r.makeTensorInfo(b,"float32",g),w=r.makeTensorInfo(b,"float32",x),C=Ve({inputs:{real:y,imag:w},backend:r}),v=lr(c,u,a,s,r),S=v.real,I=v.imag,k=[S.length],$=r.makeTensorInfo(k,"float32",S),N=r.makeTensorInfo(k,"float32",I),R=Ve({inputs:{real:$,imag:N},backend:r}),F=lr(g,x,a,s,r),O=F.real,L=F.imag,A=[O.length],E=r.makeTensorInfo(A,"float32",O),P=r.makeTensorInfo(A,"float32",L),D=Ve({inputs:{real:E,imag:P},backend:r}),M=Sc(t,s),_=[M.real.length],z=r.makeTensorInfo(_,"float32",M.real),V=r.makeTensorInfo(_,"float32",M.imag),B=Ve({inputs:{real:z,imag:V},backend:r}),H=Fo({inputs:{a:B,b:D},backend:r}),W=Cn({inputs:{a:R,b:H},backend:r}),q=Ta({inputs:{a:R,b:H},backend:r}),K=tn({inputs:{input:W},backend:r}),Z=tn({inputs:{input:q},backend:r}),Y=wn({inputs:{input:W},backend:r}),ee=wn({inputs:{input:q},backend:r}),te=vn({inputs:[K,Z],backend:r,attrs:{axis:0}}),re=vn({inputs:[Y,ee],backend:r,attrs:{axis:0}}),de=r.data.get(te.dataId).values,ye=r.data.get(re.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(Y),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(re),{real:de,imag:ye}}function MS(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,a=0;for(let l=0;l<e;l++){const c=Ic(r*l,e,t),u=Lr(n,l);i+=u.real*c.real-u.imag*c.imag,a+=u.real*c.imag+u.imag*c.real}t&&(i/=e,a/=e),vc(s,i,a,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(n){const{inputs:e,backend:t}=n,{input:s}=e,r=o.sizeFromShape(s.shape),i=s.shape[s.shape.length-1],a=r/i,l=pe({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),c=Ih(l,!1,t),u=pe({inputs:{x:c},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),u}const _S={kernelName:o.FFT,backendName:"cpu",kernelFunc:zS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ra(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,a=i||o.inferDtype(r),l=o.getArrayFromDType(a,o.sizeFromShape(s));return VS(l,r,a),e.makeTensorInfo(s,a,l)}const BS={kernelName:o.Fill,backendName:"cpu",kernelFunc:Ra};function VS(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WS={kernelName:o.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=o.getTypedArrayFromDType(s.dtype,o.sizeFromShape(s.shape)),[a,l,c,u]=s.shape,d=r.data.get(s.dataId).values;for(let p=0;p<a;p++){const f=p*c*l*u;for(let m=0;m<l;m++){const g=m*(c*u);for(let x=0;x<c;x++){const b=x*u;for(let y=0;y<u;y++){const w=Math.round(c-x-1),C=f+g+b+y;let v=d[C];if(w>=0&&w<c){const S=w*u,I=f+g+S+y;v=d[I]}i[C]=v}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:l}=e,{strides:c,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s;let g=vh({inputs:{x:r,filter:i},backend:t,attrs:{strides:c,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p}});if(a){const x=g;if(d==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const b=pe({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});g=Cn({inputs:{a:g,b},backend:t}),t.disposeIntermediateTensorInfo(b)}else g=Cn({inputs:{a:g,b:a},backend:t});t.disposeIntermediateTensorInfo(x)}if(f){const x=g;if(d==="NCHW"&&f==="prelu"&&l.shape.length===1&&l.shape[0]!==1){const b=pe({inputs:{x:l},backend:t,attrs:{shape:[l.shape[0],1,1]}});g=eo(t,g,f,b,m),t.disposeIntermediateTensorInfo(b)}else g=eo(t,g,f,l,m);t.disposeIntermediateTensorInfo(x)}return g}const US={kernelName:o.FusedConv2D,backendName:"cpu",kernelFunc:GS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:l}=e,{strides:c,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s;let g=Sh({inputs:{x:r,filter:i},backend:t,attrs:{strides:c,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p}});if(a){const x=g;g=Cn({inputs:{a:g,b:a},backend:t}),t.disposeIntermediateTensorInfo(x)}if(f){const x=g;g=eo(t,g,f,l,m),t.disposeIntermediateTensorInfo(x)}return g}const qS={kernelName:o.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:HS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XS(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=o.sizeFromShape(s.shape),a=r.shape,l=a[a.length-1],[c,u,d,h]=io(s,r);if(u===0)return t.makeTensorInfo(c,s.dtype,[]);const p=t.data.get(r.dataId).values,f=t.bufferSync(s),m=Ed(p,f,s.dtype,u,l,d,h,s.shape,i);return t.makeTensorInfo(c,s.dtype,m.values)}const jS={kernelName:o.GatherNd,backendName:"cpu",kernelFunc:XS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:l}=s;X([r,i],"gatherV2");const c=o.parseAxisParam(a,r.shape)[0],u=t.data.get(i.dataId).values,d=r.shape[c];for(let C=0;C<u.length;++C){const v=u[C];o.assert(v<=d-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${d-1}]`)}let h=l;l==null&&(h=0);const p=o.sizeFromShape(i.shape),f=Wr(r,i,c,h),m=pe({inputs:{x:r},backend:t,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),g=pe({inputs:{x:i},backend:t,attrs:{shape:[f.batchSize,p/f.batchSize]}}),x=[f.batchSize,f.outerSize,p/f.batchSize,f.sliceSize],b=t.bufferSync(g),y=t.bufferSync(m),w=Fd(y,b,x);return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.makeTensorInfo(f.outputShape,w.dtype,w.values)}const YS={kernelName:o.GatherV2,backendName:"cpu",kernelFunc:KS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZS(n){const{inputs:e,backend:t}=n,{input:s}=e,r=o.sizeFromShape(s.shape),i=s.shape[s.shape.length-1],a=r/i,l=pe({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),c=Ih(l,!0,t),u=pe({inputs:{x:c},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),u}const QS={kernelName:o.IFFT,backendName:"cpu",kernelFunc:ZS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JS=ae(o.IsFinite,n=>Number.isFinite(n)?1:0,"bool"),eI={kernelName:o.IsFinite,backendName:"cpu",kernelFunc:JS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tI=ae(o.IsInf,n=>Math.abs(n)===1/0?1:0,"bool"),nI={kernelName:o.IsInf,backendName:"cpu",kernelFunc:tI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sI=ae(o.IsNan,n=>Number.isNaN(n)?1:0,"bool"),oI={kernelName:o.IsNan,backendName:"cpu",kernelFunc:sI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rI(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=zd(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const iI={kernelName:o.LinSpace,backendName:"cpu",kernelFunc:rI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aI=ae(o.Log1p,n=>Math.log1p(n)),lI={kernelName:o.Log1p,backendName:"cpu",kernelFunc:aI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cI=we((n,e)=>n&&e),uI=Te(o.LogicalAnd,cI,null,"bool"),dI={kernelName:o.LogicalAnd,backendName:"cpu",kernelFunc:uI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hI=ae(o.LogicalNot,n=>n?0:1,"bool"),pI={kernelName:o.LogicalNot,backendName:"cpu",kernelFunc:hI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fI=we((n,e)=>n||e),mI=Te(o.LogicalOr,fI,null,"bool"),gI={kernelName:o.LogicalOr,backendName:"cpu",kernelFunc:mI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:l,beta:c}=s;X(r,"LRN");const u=r.shape[3],d=u-1,h=t.data.get(r.dataId).values,p=o.sizeFromShape(r.shape),f=new Float32Array(p);function m(g){const x=g%u;let b=g-x+Math.max(0,x-i);const y=g-x+Math.min(x+i,d);let w=0;for(;b<=y;b++){const C=h[b];w+=C*C}return w}for(let g=0;g<p;g++){const x=m(g),b=h[g]*Math.pow(a+l*x,-c);f[g]=b}return t.makeTensorInfo(r.shape,r.dtype,f)}const bI={kernelName:o.LRN,backendName:"cpu",kernelFunc:xI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:l,bias:c,alpha:u,beta:d}=s;X(a,"LRNGrad");const h=o.sizeFromShape(a.shape),p=a.shape[3],f=t.data.get(a.dataId).values,m=t.data.get(r.dataId).values,g=t.data.get(i.dataId).values,x=new Float32Array(h),b=h;for(let y=0;y<b;y++){const w=y%p,C=y-w+Math.max(0,w-l),v=y-w+Math.min(p,w+l+1);let S=0;for(let I=C;I<v;I++)S+=Math.pow(m[I],2);S=u*S+c;for(let I=C;I<v;I++){let k=-2*u*d*m[I]*g[y]/S;y===I&&(k+=Math.pow(S,-d)),k*=f[y],x[I]+=k}}return t.makeTensorInfo(a.shape,r.dtype,x)}const CI={kernelName:o.LRNGrad,backendName:"cpu",kernelFunc:yI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kh(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,l=t;let c=r.shape;const u=c.length,d=o.parseAxisParam(i,c);let h=d;const p=o.getAxesPermutation(h,u);let f=l.data.get(r.dataId).values;if(p!=null){const C=new Array(u);for(let v=0;v<C.length;v++)C[v]=c[p[v]];f=Ia(f,c,r.dtype,p,C),h=o.getInnerMostAxes(h.length,u),c=C}X(r,"max"),o.assertAxesAreInnerMostDims("max",h,u);const[m,g]=o.computeOutAndReduceShapes(c,h),x=o.sizeFromShape(g),b=Bd(f,x,m,r.dtype),y=l.write(b,m,r.dtype);let w=m;return a&&(w=o.expandShapeToKeepDim(m,d)),{dataId:y,shape:w,dtype:r.dtype}}const wI={kernelName:o.Max,backendName:"cpu",kernelFunc:kh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;X(r,"maxPool");const{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=s,u=1;o.assert(o.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const d=o.computePool2DInfo(r.shape,i,a,u,l,c);let h;if(d.filterWidth===1&&d.filterHeight===1&&o.arraysEqual(d.inShape,d.outShape))h=bt({inputs:{x:r},backend:t});else{const p=t.data.get(r.dataId).values,f=o.computeStrides(r.shape),m=$a(p,r.shape,r.dtype,f,d,"max");h=t.makeTensorInfo(d.outShape,r.dtype,m.values)}return h}const SI={kernelName:o.MaxPool,backendName:"cpu",kernelFunc:vI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:l,dimRoundingMode:c,dataFormat:u}=s;X(r,"maxPool3d");const d=o.computePool3DInfo(r.shape,i,a,1,l,c,u),h=t.data.get(r.dataId).values,p=wh(h,r.shape,r.dtype,o.computeStrides(r.shape),d,"max");return t.makeTensorInfo(p.shape,"float32",p.values)}const kI={kernelName:o.MaxPool3D,backendName:"cpu",kernelFunc:II};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s;X([r,i],"maxPool3DGrad");const d=o.computePool3DInfo(i.shape,a,l,1,c,u),h=t.bufferSync(i),p=fv(h,d),f=d.strideDepth,m=d.strideHeight,g=d.strideWidth,x=d.dilationDepth,b=d.dilationHeight,y=d.dilationWidth,w=d.effectiveFilterDepth,C=d.effectiveFilterHeight,v=d.effectiveFilterWidth,S=w-1-d.padInfo.front,I=v-1-d.padInfo.left,k=C-1-d.padInfo.top,$=o.buffer(i.shape,"float32"),N=t.bufferSync(r);for(let R=0;R<d.batchSize;++R)for(let F=0;F<d.inChannels;++F)for(let O=0;O<d.inDepth;++O)for(let L=0;L<d.inHeight;++L)for(let A=0;A<d.inWidth;++A){const E=O-S,P=L-k,D=A-I;let M=0;for(let _=0;_<w;_+=x){const z=(E+_)/f;if(!(z<0||z>=d.outDepth||Math.floor(z)!==z))for(let V=0;V<C;V+=b){const B=(P+V)/m;if(!(B<0||B>=d.outHeight||Math.floor(B)!==B))for(let H=0;H<v;H+=y){const W=(D+H)/g;if(W<0||W>=d.outWidth||Math.floor(W)!==W)continue;const q=w*C*v-1-p.get(R,z,B,W,F),K=_*C*v+V*v+H,Z=q===K?1:0;if(Z===0)continue;const Y=N.get(R,z,B,W,F);M+=Y*Z}}}$.set(M,R,O,L,A,F)}return t.makeTensorInfo($.shape,$.dtype,$.values)}const $I={kernelName:o.MaxPool3DGrad,backendName:"cpu",kernelFunc:TI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NI(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,l=i;X([i,a],"maxPoolGrad");const{filterSize:c,strides:u,pad:d,dimRoundingMode:h}=s,p=o.computePool2DInfo(l.shape,c,u,1,d,h),f=t.data.get(l.dataId).values,m=o.buffer(p.outShape,l.dtype,Ch(f,l.shape,l.dtype,p).values),g=p.strideHeight,x=p.strideWidth,b=p.dilationHeight,y=p.dilationWidth,w=p.effectiveFilterHeight,C=p.effectiveFilterWidth,v=C-1-p.padInfo.left,S=w-1-p.padInfo.top,I=o.buffer(l.shape,"float32"),k=t.data.get(r.dataId).values,$=o.buffer(r.shape,"float32",k);for(let N=0;N<p.batchSize;++N)for(let R=0;R<p.inChannels;++R)for(let F=0;F<p.inHeight;++F)for(let O=0;O<p.inWidth;++O){const L=F-S,A=O-v;let E=0;for(let P=0;P<w;P+=b){const D=(L+P)/g;if(!(D<0||D>=p.outHeight||Math.floor(D)!==D))for(let M=0;M<C;M+=y){const _=(A+M)/x;if(_<0||_>=p.outWidth||Math.floor(_)!==_)continue;const z=w*C-1-m.get(N,D,_,R),V=P*C+M,B=z===V?1:0;if(B===0)continue;const H=$.get(N,D,_,R);E+=H*B}}I.set(E,N,F,O,R)}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const RI={kernelName:o.MaxPoolGrad,backendName:"cpu",kernelFunc:NI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(n,e,t,s,r){const i=o.computeStrides(e),a=$a(n,e,t,i,r,"max"),l=Ch(n,e,t,r,!0,s);return[a.values,l.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DI={kernelName:o.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:l}=e,c=t;X(s,"MaxPoolWithArgmax");const u=c.data.get(s.dataId).values,d=o.computePool2DInfo(s.shape,r,i,[1,1],a),[h,p]=AI(u,s.shape,s.dtype,l,d),f=c.write(h,d.outShape,s.dtype),m=c.write(p,d.outShape,s.dtype);return[{dataId:f,shape:d.outShape,dtype:s.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,l=o.parseAxisParam(i,r.shape),u=o.computeOutAndReduceShapes(r.shape,l)[1],d=o.sizeFromShape(u),h=[],p=t.makeTensorInfo([],"float32",new Float32Array([d]));h.push(p);const f=Wt({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});h.push(f);const m=Na({inputs:{a:f,b:p},backend:t});h.push(m);const g=xs({inputs:{x:m},backend:t,attrs:{axis:i,keepDims:a}});return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}const FI={kernelName:o.Mean,backendName:"cpu",kernelFunc:EI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;X(r,"min");const l=o.parseAxisParam(i,r.shape);let c=l;const u=o.getAxesPermutation(c,r.shape.length);let d=r;u!=null&&(d=_e({inputs:{x:r},backend:t,attrs:{perm:u}}),c=o.getInnerMostAxes(c.length,r.shape.length)),o.assertAxesAreInnerMostDims("min",c,d.shape.length);const[h,p]=o.computeOutAndReduceShapes(d.shape,c),f=o.sizeFromShape(p),m=o.makeZerosTypedArray(o.sizeFromShape(h),d.dtype),g=t.data.get(d.dataId).values;for(let b=0;b<m.length;++b){const y=b*f;let w=g[y];for(let C=0;C<f;++C){const v=g[y+C];(Number.isNaN(v)||v<w)&&(w=v)}m[b]=w}u!=null&&t.disposeIntermediateTensorInfo(d);const x=t.makeTensorInfo(h,d.dtype,m);if(a){const b=o.expandShapeToKeepDim(h,l),y=pe({inputs:{x},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(x),y}return x}const LI={kernelName:o.Min,backendName:"cpu",kernelFunc:OI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:a}=s;X(r,"mirrorPad");const l=i.map((w,C)=>w[0]+r.shape[C]+w[1]),c=i.map(w=>w[0]),u=i.map((w,C)=>w[0]+r.shape[C]),d=a==="reflect"?0:1,h=t.data.get(r.dataId).values,p=r.shape.length,f=o.computeStrides(r.shape),m=o.sizeFromShape(l),g=l.length,x=o.computeStrides(l),b=o.getTypedArrayFromDType(r.dtype,m);for(let w=0;w<m;w++){let C=o.indexToLoc(w,g,x);for(let S=0;S<g;S++)C[S]<c[S]?C[S]=c[S]*2-C[S]-d:C[S]>=u[S]&&(C[S]=(u[S]-1)*2-C[S]+d);C=C.map((S,I)=>S-c[I]);const v=o.locToIndex(C,p,f);b[w]=h[v]}return{dataId:t.write(b,l,r.dtype),shape:l,dtype:r.dtype}}const MI={kernelName:o.MirrorPad,backendName:"cpu",kernelFunc:PI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zI=we((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),_I=Te(o.Mod,zI),BI={kernelName:o.Mod,backendName:"cpu",kernelFunc:_I};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Th(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=r.shape.length;let l=i;if(l===-1&&(l=a-1),l!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${l}`);const c=o.parseAxisParam([l],r.shape),u=kh({inputs:{x:r},backend:t,attrs:{reductionIndices:c,keepDims:!1}}),d=o.expandShapeToKeepDim(u.shape,c),h=pe({inputs:{x:u},backend:t,attrs:{shape:d}}),p=Ta({inputs:{a:r,b:h},backend:t}),f=Nd({inputs:{x:p},backend:t}),m=xs({inputs:{x:f},backend:t,attrs:{axis:c,keepDims:!1}}),g=pe({inputs:{x:m},backend:t,attrs:{shape:d}}),x=Na({inputs:{a:f,b:g},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),x}const VI={kernelName:o.Softmax,backendName:"cpu",kernelFunc:Th};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:l}=s;X(r,"multinomial");const c=l?r:Th({inputs:{logits:r},backend:t,attrs:{dim:-1}}),u=c.shape[0],d=c.shape[1],h=t.data.get(c.dataId).values,p=[u,i],f=o.makeZerosTypedArray(o.sizeFromShape(p),"int32");for(let m=0;m<u;++m){const g=m*d,x=new Float32Array(d-1);x[0]=h[g];for(let w=1;w<x.length;++w)x[w]=x[w-1]+h[g+w];const b=o.seedrandom.alea(a.toString()),y=m*i;for(let w=0;w<i;++w){const C=b();f[y+w]=x.length;for(let v=0;v<x.length;v++)if(C<x[v]){f[y+w]=v;break}}}return l||t.disposeIntermediateTensorInfo(c),t.makeTensorInfo(p,"int32",f)}const GI={kernelName:o.Multinomial,backendName:"cpu",kernelFunc:WI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UI=o.nonMaxSuppressionV3Impl;function HI(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=s;X(r,"NonMaxSuppression");const u=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,{selectedIndices:h}=UI(u,d,a,l,c);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const qI={kernelName:o.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:HI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XI=o.nonMaxSuppressionV4Impl;function jI(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:u}=s;X(r,"NonMaxSuppressionPadded");const d=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:p,validOutputs:f}=XI(d,h,a,l,c,u);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}const KI={kernelName:o.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:jI};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YI=o.nonMaxSuppressionV5Impl;function ZI(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=s;X(r,"NonMaxSuppressionWithScore");const d=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,p=a,f=l,m=c,g=u,{selectedIndices:x,selectedScores:b}=YI(d,h,p,f,m,g);return[t.makeTensorInfo([x.length],"int32",new Int32Array(x)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const QI={kernelName:o.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:ZI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JI(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:l,offValue:c}=s;X(r,"oneHot");const u=o.sizeFromShape(r.shape),d=new Float32Array(u*a);d.fill(c);const h=t.data.get(r.dataId).values;for(let p=0;p<u;++p)h[p]>=0&&h[p]<a&&(d[p*a+h[p]]=l);return t.makeTensorInfo([...r.shape,a],i,d)}const e1={kernelName:o.OneHot,backendName:"cpu",kernelFunc:JI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=tn({inputs:{input:s},backend:t}),i=no({inputs:{x:r},backend:t}),a=wn({inputs:{input:s},backend:t}),l=no({inputs:{x:a},backend:t}),c=Ve({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}else return Ra({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const t1={kernelName:o.ZerosLike,backendName:"cpu",kernelFunc:no};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $h(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=tn({inputs:{input:s},backend:t}),i=$h({inputs:{x:r},backend:t}),a=wn({inputs:{input:s},backend:t}),l=no({inputs:{x:a},backend:t}),c=Ve({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}else return Ra({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const n1={kernelName:o.OnesLike,backendName:"cpu",kernelFunc:$h};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nh(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return to({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{o.assertShapesMatch(i,d.shape,"All tensors passed to stack must have matching shapes"),o.assert(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=e.map(d=>{const h=to({inputs:{input:d},backend:t,attrs:{dim:r}});return l.push(h),h}),u=vn({inputs:c,backend:t,attrs:{axis:r}});return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),u}const s1={kernelName:o.Pack,backendName:"cpu",kernelFunc:Nh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;X(r,"pad");const l=i.map((y,w)=>y[0]+r.shape[w]+y[1]),c=i.map(y=>y[0]),u=t.data.get(r.dataId).values,d=o.sizeFromShape(r.shape),h=r.shape.length,p=o.computeStrides(r.shape),f=o.sizeFromShape(l),m=l.length,g=o.computeStrides(l),x=o.getTypedArrayFromDType(r.dtype,f);a!==0&&x.fill(a);for(let y=0;y<d;y++){const C=o.indexToLoc(y,h,p).map((S,I)=>S+c[I]),v=o.locToIndex(C,m,g);x[v]=u[y]}return{dataId:t.write(x,l,r.dtype),shape:l,dtype:r.dtype}}const Rh={kernelName:o.PadV2,backendName:"cpu",kernelFunc:o1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1=we((n,e)=>Math.pow(n,e)),i1=Te(o.Pow,r1),a1={kernelName:o.Pow,backendName:"cpu",kernelFunc:i1};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l1(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:l}=s,c=r.map(b=>t.data.get(b.dataId).values),u=r.map(b=>b.shape),d=t.data.get(i.dataId).values,h=t.data.get(a.dataId).values,[p,f,m]=qd(c,u,d,i.shape,i.dtype,h,a.shape),g=p.map(b=>t.makeTensorInfo([b.length],"int32",b)),x=t.makeTensorInfo(m,i.dtype,f);return g.concat([x])}const c1={kernelName:o.RaggedGather,backendName:"cpu",kernelFunc:l1};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u1(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,[u,d]=Xd(a,s.shape,s.dtype,l,r.shape,c,i.shape),h=t.makeTensorInfo([u.length],"int32",u),p=t.makeTensorInfo([d.length],s.dtype,d);return[h,p]}const d1={kernelName:o.RaggedRange,backendName:"cpu",kernelFunc:u1};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h1(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:l}=e,{rowPartitionTypes:c}=s,u=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,h=t.data.get(a.dataId).values,p=l.map(x=>t.data.get(x.dataId).values),f=l.map(x=>x.shape),[m,g]=jd(u,r.shape,d,i.shape,i.dtype,h,a.shape,p,f,c);return t.makeTensorInfo(m,i.dtype,g)}const p1={kernelName:o.RaggedTensorToTensor,backendName:"cpu",kernelFunc:h1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f1(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:a}=t,l=Kd(s,r,a,i);return e.makeTensorInfo([l.length],i,l)}const m1={kernelName:o.Range,backendName:"cpu",kernelFunc:f1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g1=ae(o.Reciprocal,n=>1/n),x1={kernelName:o.Reciprocal,backendName:"cpu",kernelFunc:g1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:l}=s;X(r,"resizeBilinear");const c=o.computeStrides(r.shape),[u,d]=l,[h,p,f,m]=r.shape,g=t.data.get(r.dataId).values,x=new Float32Array(o.sizeFromShape([h,u,d,m])),b=[i&&u>1?p-1:p,i&&d>1?f-1:f],y=[i&&u>1?u-1:u,i&&d>1?d-1:d];let w=0;const C=b[0]/y[0],v=b[1]/y[1];for(let S=0;S<h;S++)for(let I=0;I<u;I++){let k;a?k=C*(I+.5)-.5:k=C*I;const $=Math.max(0,Math.floor(k)),N=k-$,R=Math.min(p-1,Math.ceil(k)),F=S*c[0]+$*c[1],O=S*c[0]+R*c[1];for(let L=0;L<d;L++){let A;a?A=v*(L+.5)-.5:A=v*L;const E=Math.max(0,Math.floor(A)),P=A-E,D=Math.min(f-1,Math.ceil(A)),M=F+E*c[2],_=O+E*c[2],z=F+D*c[2],V=O+D*c[2];for(let B=0;B<m;B++){const H=g[M+B],W=g[_+B],q=g[z+B],K=g[V+B],Z=H+(q-H)*P,Y=W+(K-W)*P,ee=Z+(Y-Z)*N;x[w++]=ee}}}return t.makeTensorInfo([h,u,d,m],"float32",x)}const y1={kernelName:o.ResizeBilinear,backendName:"cpu",kernelFunc:b1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C1(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;X([i,r],"resizeBilinearGrad");const l=o.computeStrides(r.shape),[c,u,d,h]=r.shape,[,p,f]=i.shape,m=new Float32Array(c*u*d*h),g=[a&&p>1?u-1:u,a&&f>1?d-1:d],x=[a&&p>1?p-1:p,a&&f>1?f-1:f],b=g[0]/x[0],y=g[1]/x[1],w=t.data.get(i.dataId).values;let C=0;for(let v=0;v<c;v++){const S=v*l[0];for(let I=0;I<p;I++){const k=I*b,$=Math.floor(k),N=Math.min(Math.ceil(k),u-1),R=S+$*l[1],F=S+N*l[1],O=k-$,L=1-O;for(let A=0;A<f;A++){const E=A*y,P=Math.floor(E),D=Math.min(Math.ceil(E),d-1),M=E-P,_=1-M,z=R+P*l[2],V=R+D*l[2],B=F+P*l[2],H=F+D*l[2],W=L*_,q=L*M,K=O*_,Z=O*M;for(let Y=0;Y<h;Y++){const ee=w[C++];m[z+Y]+=ee*W,m[V+Y]+=ee*q,m[B+Y]+=ee*K,m[H+Y]+=ee*Z}}}}return t.makeTensorInfo([c,d,u,h],"float32",m)}const w1={kernelName:o.ResizeBilinearGrad,backendName:"cpu",kernelFunc:C1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:l}=s;X(r,"resizeNearestNeighbor");const c=o.computeStrides(r.shape),[u,d]=l,[h,p,f,m]=r.shape,g=t.data.get(r.dataId).values,x=new Float32Array(h*u*d*m),b=[i&&u>1?p-1:p,i&&d>1?f-1:f],y=[i&&u>1?u-1:u,i&&d>1?d-1:d],w=b[0]/y[0],C=b[1]/y[1];let v=0;for(let S=0;S<h;S++){const I=S*c[0];for(let k=0;k<u;k++){const $=a?w*(k+.5):w*k;let N=Math.min(p-1,i?Math.round($):Math.floor($));a&&(N=Math.max(0,N));const R=I+N*c[1];for(let F=0;F<d;F++){const O=a?C*(F+.5):C*F;let L=Math.min(f-1,i?Math.round(O):Math.floor(O));a&&(L=Math.max(0,L));const A=R+L*c[2];for(let E=0;E<m;E++){const P=g[A+E];x[v++]=P}}}}return t.makeTensorInfo([h,u,d,m],r.dtype,x)}const S1={kernelName:o.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:v1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;X([i,r],"resizeNearestNeighborGrad");const l=o.computeStrides(r.shape),c=o.computeStrides(i.shape),[u,d,h,p]=r.shape,[,f,m]=i.shape,g=new Float32Array(u*d*h*p),x=t.data.get(i.dataId).values,b=[a&&f>1?d-1:d,a&&m>1?h-1:h],y=[a&&f>1?f-1:f,a&&m>1?m-1:m],w=b[0]/y[0],C=b[1]/y[1],v=1/w,S=1/C,I=Math.ceil(v)*2+2,k=Math.ceil(S)*2+2;for(let $=0;$<u;$++){const N=$*l[0];for(let R=0;R<d;R++){const F=N+R*l[1],O=Math.floor(R*v),L=Math.floor(O-I/2);for(let A=0;A<h;A++){const E=F+A*l[2],P=Math.floor(A*S),D=Math.floor(P-k/2);for(let M=0;M<p;M++){let _=0;for(let z=0;z<I;z++){const V=z+L;if(V<0||V>=f)continue;const B=N+V*c[1],H=V*w,W=Math.min(d-1,a?Math.round(H):Math.floor(H));if(R===W)for(let q=0;q<k;q++){const K=q+D;if(K<0||K>=m)continue;const Z=B+K*c[2],Y=K*C,ee=Math.min(h-1,a?Math.round(Y):Math.floor(Y));A===ee&&(_+=x[Z+M])}}g[E+M]=_}}}}return t.makeTensorInfo(r.shape,r.dtype,g)}const k1={kernelName:o.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:I1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;X(r,"reverse");const a=r.shape.length,l=o.parseAxisParam(i,r.shape);if(a===0)return bt({inputs:{x:r},backend:t});const c=new o.TensorBuffer(r.shape,r.dtype),u=t.bufferSync(r);for(let d=0;d<c.size;d++){const h=c.indexToLoc(d),p=h.slice();l.forEach(f=>p[f]=r.shape[f]-1-p[f]),c.set(u.get(...p),...h)}return t.makeTensorInfo(c.shape,c.dtype,c.values)}const $1={kernelName:o.Reverse,backendName:"cpu",kernelFunc:T1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N1={kernelName:o.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,l=t,c=o.getTypedArrayFromDType(s.dtype,o.sizeFromShape(s.shape)),[u,d,h,p]=s.shape,[f,m]=Tr(a,d,h),g=255,x=Math.sin(r),b=Math.cos(r),y=l.data.get(s.dataId).values;for(let C=0;C<u;C++){const v=C*h*d*p;for(let S=0;S<d;S++){const I=S*(h*p);for(let k=0;k<h;k++){const $=k*p;for(let N=0;N<p;N++){const R=[u,S,k,N],F=R[2],O=R[1];let L=(F-f)*b-(O-m)*x,A=(F-f)*x+(O-m)*b;L=Math.round(L+f),A=Math.round(A+m);let E=i;if(typeof i!="number"&&(N===3?E=g:E=i[N]),L>=0&&L<h&&A>=0&&A<d){const D=A*(h*p),M=L*p,_=v+D+M+N;E=y[_]}const P=v+I+$+N;c[P]=E}}}}return{dataId:l.write(c,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R1=ae(o.Round,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),A1={kernelName:o.Round,backendName:"cpu",kernelFunc:R1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=o.calculateShapes(i,r,a),p=!0,f=t.bufferSync(r),m=t.bufferSync(i),g=Yt(f,m,a,h,u,c,l,d,0,p);return t.makeTensorInfo(a,g.dtype,g.values)}const E1={kernelName:o.ScatterNd,backendName:"cpu",kernelFunc:D1};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function O1(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function L1(n,e,t,s,r,i){const a=o.getArrayFromDType("int32",t*r);for(let l=0;l<t;++l){const c=n.slice(l*s,(l+1)*s),u=l*r;for(let d=0;d<r;++d)a[u+d]=i==="left"?F1(c,e[d+u]):O1(c,e[d+u])}return a}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P1(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,u=L1(l,c,r.shape[0],r.shape[1],i.shape[1],a);return t.makeTensorInfo(i.shape,"int32",u)}const M1={kernelName:o.SearchSorted,backendName:"cpu",kernelFunc:P1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;X([s,r,i],"select");const a=s.shape.length,l=t.data.get(s.dataId).values,c=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,d=o.upcastType(r.dtype,i.dtype),h=o.makeZerosTypedArray(o.sizeFromShape(r.shape),d);let p=0;const f=a===0||a>1||r.shape.length===1?1:o.sizeFromShape(r.shape.slice(1));for(let m=0;m<l.length;m++)for(let g=0;g<f;g++)l[m]===1?h[p++]=c[m]:h[p++]=u[m];return t.makeTensorInfo(r.shape,d,h)}const _1={kernelName:o.Select,backendName:"cpu",kernelFunc:z1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B1=co,V1=uo,W1=ae(o.Selu,n=>n>=0?V1*n:B1*(Math.exp(n)-1)),G1={kernelName:o.Selu,backendName:"cpu",kernelFunc:W1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U1=ae(o.Sign,n=>n<0?-1:n>0?1:0),H1={kernelName:o.Sign,backendName:"cpu",kernelFunc:U1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1=ae(o.Sin,n=>Math.sin(n)),X1={kernelName:o.Sin,backendName:"cpu",kernelFunc:q1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j1=ae(o.Sinh,n=>Math.sinh(n)),K1={kernelName:o.Sinh,backendName:"cpu",kernelFunc:j1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y1=11920928955078125e-23,Al=Math.log(Y1)+2,Z1=ae(o.Softplus,n=>{const e=n>-Al,t=n<Al,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),Q1={kernelName:o.Softplus,backendName:"cpu",kernelFunc:Z1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;X([r],"spaceToBatchND");const l=o.sizeFromShape(i),c=[[0,0]];c.push(...a);for(let S=1+i.length;S<r.shape.length;++S)c.push([0,0]);const u=Rh.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:c,constantValue:0}}),d=os(u.shape,i,l,!1),h=rs(d.length,i.length,!1),p=is(u.shape,i,l,!1),g=pe({inputs:{x:u},backend:t,attrs:{shape:d}}),y=_e({inputs:{x:g},backend:t,attrs:{perm:h}}),v=pe({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),v}const ek={kernelName:o.SpaceToBatchND,backendName:"cpu",kernelFunc:J1};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tk(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const l=t.data.get(s.dataId).values,c=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,d=t.data.get(a.dataId).values[0],[h,p,f,m,g]=Jd(l,s.shape,s.dtype,c,r.dtype,u,d);return[t.makeTensorInfo(p,s.dtype,h),t.makeTensorInfo([p[0]],r.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(x=>Number(x)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const nk={kernelName:o.SparseFillEmptyRows,backendName:"cpu",kernelFunc:tk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sk(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.data.get(r.dataId).values),l=t.data.get(s.dataId).values,c=Array.from(t.data.get(i.dataId).values),[u,d,h]=eh(l,s.shape,s.dtype,a,c);return[t.makeTensorInfo(d,s.dtype,u),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const ok={kernelName:o.SparseReshape,backendName:"cpu",kernelFunc:sk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rk(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,[u,d]=ka(a,s.shape,s.dtype,l,c,!0);return t.makeTensorInfo(d,s.dtype,u)}const ik={kernelName:o.SparseSegmentMean,backendName:"cpu",kernelFunc:rk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ak(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,[u,d]=ka(a,s.shape,s.dtype,l,c);return t.makeTensorInfo(d,s.dtype,u)}const lk={kernelName:o.SparseSegmentSum,backendName:"cpu",kernelFunc:ak};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ck(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:l}=s,{sliceRank:c,numUpdates:u,sliceSize:d,strides:h,outputSize:p}=o.calculateShapes(i,r,l),f=!1,m=t.bufferSync(r);let g;switch(i.dtype){case"bool":{const x=t.bufferSync(i),b=!!t.data.get(a.dataId).values[0];g=Yt(m,x,l,p,d,u,c,h,b,f);break}case"float32":{const x=t.bufferSync(i),b=t.data.get(a.dataId).values[0];g=Yt(m,x,l,p,d,u,c,h,b,f);break}case"int32":{const x=t.bufferSync(i),b=t.data.get(a.dataId).values[0];g=Yt(m,x,l,p,d,u,c,h,b,f);break}case"string":{const x=t.bufferSync(i),b=o.decodeString(t.data.get(a.dataId).values[0]);g=Yt(m,x,l,p,d,u,c,h,b,f);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(l,g.dtype,g.values)}const uk={kernelName:o.SparseToDense,backendName:"cpu",kernelFunc:ck};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dk(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,l=o.parseAxisParam(a,r.shape)[0],c=Vr(r,i,l),u=new Array(r.shape.length).fill(0),d=r.shape.slice();return c.map(h=>{const p=[...d];p[l]=h;const f=nn({inputs:{x:r},backend:t,attrs:{begin:u,size:p}});return u[l]+=h,f})}const hk={kernelName:o.SplitV,backendName:"cpu",kernelFunc:dk};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pk={kernelName:o.Square,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;X(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let l=0;l<r.length;++l){const c=r[l];i[l]=c*c}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fk=ae(o.Step,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),mk={kernelName:o.Step,backendName:"cpu",kernelFunc:fk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gk(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:l,beginMask:c,endMask:u,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=s;X(r,"stridedSlice");const{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:y,end:w,strides:C}=vr(r.shape,i,a,l,c,u,d,h,p);let v;if(g)v=pe({inputs:{x:r},backend:t,attrs:{shape:m}});else if(x||b){o.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const S=yr(y,w,C),I=nn({inputs:{x:r},backend:t,attrs:{begin:y,size:S}});v=pe({inputs:{x:I},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(I)}else{const S=t.bufferSync(r),I=sh(f,S,C,y);v=t.makeTensorInfo(m,I.dtype,I.values)}return v}const xk={kernelName:o.StridedSlice,backendName:"cpu",kernelFunc:gk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bk(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:l,padWidth:c,preserveShortSequences:u}=s,{data:d,dataSplits:h}=e,p=t.data.get(d.dataId).values,f=t.data.get(h.dataId).values,[m,g]=oh(p,f,r,i,a,l,c,u);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(h.shape,"int32",g)]}const yk={kernelName:o.StringNGrams,backendName:"cpu",kernelFunc:bk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ck(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const l=t.data.get(i.dataId).values,c=t.data.get(a.dataId).values[0],[u,d,h]=rh(l,c,r),p=d.length;return[t.makeTensorInfo([p,2],"int32",u),t.makeTensorInfo([p],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const wk={kernelName:o.StringSplit,backendName:"cpu",kernelFunc:Ck};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vk(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(i.dataId).values,l=ih(a,r);return t.makeTensorInfo(i.shape,"int32",l)}const Sk={kernelName:o.StringToHashBucketFast,backendName:"cpu",kernelFunc:vk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ik=ae(o.Tan,n=>Math.tan(n)),kk={kernelName:o.Tan,backendName:"cpu",kernelFunc:Ik};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tk=ae(o.Tanh,n=>Math.tanh(n)),$k={kernelName:o.Tanh,backendName:"cpu",kernelFunc:Tk};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nk(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=o.calculateShapes(i,r,s.shape),h=!1,p=t.bufferSync(r),f=t.bufferSync(i),m=t.bufferSync(s),g=Yt(p,f,s.shape,d,c,l,a,u,m,h);return t.makeTensorInfo(s.shape,g.dtype,g.values)}const Rk={kernelName:o.TensorScatterUpdate,backendName:"cpu",kernelFunc:Nk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ak(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;X(r,"tile");const a=lh(t.bufferSync(r),i);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const Dk={kernelName:o.Tile,backendName:"cpu",kernelFunc:Ak};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ek(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s;X(r,"topk");const l=t.data.get(r.dataId).values,[c,u]=uh(l,r.shape,r.dtype,i,a);return[t.makeTensorInfo(c.shape,c.dtype,c.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}const Fk={kernelName:o.TopK,backendName:"cpu",kernelFunc:Ek};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ok(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:l,fillValue:c,outputShape:u}=t,[d,h,p,f]=r.shape,[m,g]=u??[h,p],x=[d,m,g,f],b=o.computeStrides(r.shape),y=b[0],w=b[1],C=b[2],v=o.computeStrides(x),S=v[0],I=v[1],k=v[2],$=o.getTypedArrayFromDType(r.dtype,o.sizeFromShape(x));$.fill(c);const N=s.data.get(r.dataId).values,R=s.data.get(i.dataId).values;for(let O=0;O<d;++O){const L=i.shape[0]===1?R:R.subarray(O*8,O*8+8);for(let A=0;A<m;++A)for(let E=0;E<g;++E)for(let P=0;P<f;++P){let D;const M=L[6]*E+L[7]*A+1;if(M===0)continue;const _=(L[0]*E+L[1]*A+L[2])/M,z=(L[3]*E+L[4]*A+L[5])/M,V=Dl(_,p,l),B=Dl(z,h,l);switch(a){case"nearest":D=Bk(N,h,p,y,w,C,O,B,V,P,c);break;case"bilinear":D=Vk(N,h,p,y,w,C,O,B,V,P,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const H=O*S+A*I+E*k+P;$[H]=D}return s.makeTensorInfo(x,r.dtype,$)}return{dataId:s.write($,x,r.dtype),shape:r.shape,dtype:r.dtype}}const Lk={kernelName:o.Transform,backendName:"cpu",kernelFunc:Ok};function Dl(n,e,t){switch(t){case"reflect":return Pk(n,e);case"wrap":return Mk(n,e);case"nearest":return _k(n,e);case"constant":default:return zk(n)}}function Pk(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return o.clamp(0,t,e-1)}function Mk(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return o.clamp(0,t,e-1)}function zk(n,e){return n}function _k(n,e){return o.clamp(0,n,e-1)}function Un(n,e,t,s,r,i,a,l,c,u,d){const h=a*s+l*r+c*i+u;return 0<=l&&l<e&&0<=c&&c<t?n[h]:d}function Bk(n,e,t,s,r,i,a,l,c,u,d){const h=Math.round(l),p=Math.round(c);return Un(n,e,t,s,r,i,a,h,p,u,d)}function Vk(n,e,t,s,r,i,a,l,c,u,d){const h=Math.floor(l),p=Math.floor(c),f=h+1,m=p+1,g=(m-c)*Un(n,e,t,s,r,i,a,h,p,u,d)+(c-p)*Un(n,e,t,s,r,i,a,h,m,u,d),x=(m-c)*Un(n,e,t,s,r,i,a,f,p,u,d)+(c-p)*Un(n,e,t,s,r,i,a,f,m,u,d);return(f-l)*g+(l-h)*x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wk(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;X(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:l,outputShape:c,indices:u}=dh(a,r,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,l),s.makeTensorInfo([u.length],"int32",u)]}const Gk={kernelName:o.Unique,backendName:"cpu",kernelFunc:Wk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uk(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,l=r.shape[i],c=new Array(a-1);let u=0;for(let f=0;f<a;f++)f!==i&&(c[u++]=r.shape[f]);const d=new Array(a).fill(0),h=r.shape.slice();h[i]=1;const p=new Array(l);for(let f=0;f<p.length;f++){d[i]=f;const m=nn({inputs:{x:r},backend:t,attrs:{begin:d,size:h}});p[f]=pe({inputs:{x:m},backend:t,attrs:{shape:c}}),t.disposeIntermediateTensorInfo(m)}return p}const Hk={kernelName:o.Unpack,backendName:"cpu",kernelFunc:Uk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qk(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s;X(r,"unsortedSegmentSum");const l=r.shape.length,c=i.shape.length,u=[],d=[],h=l-c;let p=i;for(let m=0;m<h;++m){const g=to({inputs:{input:p},backend:t,attrs:{dim:m+1}});p=g,d.push(g)}for(let m=0;m<a;++m){const g=o.createScalarValue(m,"int32"),x=t.makeTensorInfo([],"int32",g),b=Td({inputs:{a:x,b:p},backend:t}),y=Wt({inputs:{x:b},backend:t,attrs:{dtype:"float32"}}),w=Fo({inputs:{a:y,b:r},backend:t}),C=xs({inputs:{x:w},backend:t,attrs:{axis:0,keepDims:!1}});u.push(C),d.push(x),d.push(b),d.push(y),d.push(w),d.push(C)}const f=Nh({inputs:u,backend:t,attrs:{axis:0}});return d.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const Xk={kernelName:o.UnsortedSegmentSum,backendName:"cpu",kernelFunc:qk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jk=[W0,Sw,U0,q0,Rw,j0,Y0,Q0,ev,nv,ov,iv,lv,dv,pv,gv,bv,Cv,vv,B0,Iv,Tv,Nv,Dw,Av,$w,Fw,Ev,Iw,Ov,Pv,Mv,_v,Vv,Gv,Hv,Xv,Kv,Zv,Jv,tS,sS,rS,aS,lS,uS,hS,fS,mS,gS,xS,yS,vS,F0,IS,Ow,ES,Lw,FS,Mw,_S,BS,WS,_w,Vw,US,qS,jS,YS,Gw,Hw,kw,QS,Lv,eI,nI,oI,O0,Xw,Kw,iI,Zw,lI,dI,pI,gI,bI,CI,wI,Jw,SI,kI,$I,RI,DI,FI,LI,t0,MI,BI,GI,s0,r0,qI,KI,QI,a0,e1,n1,s1,Rh,a1,P0,u0,c1,d1,p1,m1,Tw,ar,x1,M0,z0,_0,y1,w1,S1,k1,$1,N1,A1,b0,E1,M1,_1,G1,C0,H1,X1,K1,w0,VI,Q1,ek,nk,ok,ik,lk,uk,hk,I0,pk,T0,N0,mk,xk,yk,wk,Sk,E0,CS,kk,$k,Rk,Dk,Fk,Lk,l0,Gk,Hk,Xk,t1];for(const n of jk)o.registerKernel(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kt={},Ds={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ah(n,e){Kt[n]=e}function lt(n,e){if(!(n in Kt)||e!=null){const s=Yk(n,e);if(s!==null)Kt[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Kt[n];return t==null||t.isContextLost()?(delete Kt[n],lt(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Kt[n])}function Kk(n){if(!o.env().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Yk(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??Kk(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Kt[n]},!1),o.env().getBool("SOFTWARE_WEBGL_ENABLED")&&(Ds.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Ds)||t.getContext("experimental-webgl",Ds):t.getContext("webgl2",Ds)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Jn;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Jn||(Jn={}));var He;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(He||(He={}));var Ae;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ae||(Ae={}));function bs(n,e){return[e,n]}function Zk(n,e){return n*e}function Es(n){const e=o.sizeFromShape(n),t=Math.ceil(e/4);return o.sizeToSquarishShape(t)}function Rn(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function Qk(n,e){const[t,s]=Rn(n,e);return t*s*4}function Aa(n,e){const t=n;let s,r,i,a,l,c,u,d,h,p;return o.env().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,a=t.RGBA32F,l=t.RED,u=4,d=1,h=t.HALF_FLOAT,p=t.FLOAT,c=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,a=t.RGBA,l=n.RGBA,u=4,d=4,h=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT,c=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:l,downloadTextureFormat:c,downloadUnpackNumChannels:u,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U(n,e){const t=e();return o.env().getBool("DEBUG")&&Jk(n),t}function Jk(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+Eh(n,e))}const eT=596e-10,tT=65504;function Dh(n){return!!(o.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||eT<Math.abs(n)&&Math.abs(n)<tT)}function Eh(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Hn(n,e){return Tt(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Fh(n,e){const t=Tt(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(U(n,()=>n.shaderSource(t,e)),U(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Oh(n,e){const t=Tt(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(U(n,()=>n.shaderSource(t,e)),U(n,()=>n.compileShader(t)),o.env().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw Da(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const nT=/ERROR: [0-9]+:([0-9]+):/g;function Da(n,e){const t=nT.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,a=r.map((h,p)=>o.rightPad((p+1).toString(),i)+h);let l=0;for(let h=0;h<a.length;h++)l=Math.max(a[h].length,l);const c=a.slice(0,s-1),u=a.slice(s-1,s),d=a.slice(s);console.log(c.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${o.rightPad(u[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function Lh(n){return Tt(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function Ph(n,e){if(U(n,()=>n.linkProgram(e)),!o.env().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Ps(n,e){if(U(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Mh(n,e){const t=Tt(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return U(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),U(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function zh(n,e){const t=Tt(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return U(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),U(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function sT(){return o.env().getNumber("WEBGL_VERSION")===2?1:4}function _h(n){return Tt(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Bh(n,e){const t=o.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Vh(n){return Tt(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function cr(n,e,t,s,r,i,a){const l=n.getAttribLocation(e,t);return l===-1?!1:(U(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),U(n,()=>n.vertexAttribPointer(l,r,n.FLOAT,!1,i,a)),U(n,()=>n.enableVertexAttribArray(l)),!0)}function Wh(n,e,t){Xh(n,t),U(n,()=>n.activeTexture(n.TEXTURE0+t)),U(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function oT(n,e){Xh(n,e),U(n,()=>n.activeTexture(n.TEXTURE0+e)),U(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Gh(n,e,t){return Tt(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function Uh(n,e,t){return n.getUniformLocation(e,t)}function Hh(n,e,t,s){U(n,()=>Wh(n,e,s)),U(n,()=>n.uniform1i(t,s))}function rT(n){U(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),U(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),U(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function Ms(n,e,t){U(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),U(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function ur(n,e){U(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),U(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function qn(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+qh(n,e))}function qh(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Tt(n,e,t){const s=U(n,()=>e());if(s==null)throw new Error(t);return s}function Xh(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function sn(n,e=2){return o.sizeFromShape(n.slice(0,n.length-e))}function on(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Xn(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[sn(n),...on(n)]),e}function jh(n,e=!1){let t=o.env().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=o.env().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&o.env().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((l,c)=>c>=n.length-2?o.nearestLargerEven(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=o.squeezeShape(n).newShape);let r=o.sizeFromShape(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const a=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||a)if(e){const l=sn(n);let c=2,u=2;n.length&&([c,u]=on(n)),r=l*(c/2)*(u/2),i=o.sizeToSquarishShape(r).map(d=>d*2)}else i=o.sizeToSquarishShape(r);return i}function Fs(n){return n%2===0}function es(n,e){if(n=n.slice(-2),e=e.slice(-2),o.arraysEqual(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Fs(t)&&Fs(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Fs(n[0])&&Fs(e[0])}let zs,_s;function Kh(n){if(zs==null){const e=lt(n);zs=e.getParameter(e.MAX_TEXTURE_SIZE)}return zs}function iT(){zs=null}function aT(){_s=null}function Yh(n){if(_s==null){const e=lt(n);_s=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,_s)}function Zh(n){if(n===0)return 0;let e;const t=lt(n);return qe(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:qe(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function qe(n,e){return n.getExtension(e)!=null}function dr(n){try{if(lt(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Qh(n){if(n===0)return!1;const e=lt(n);if(n===1){if(!qe(e,"OES_texture_float"))return!1}else if(!qe(e,"EXT_color_buffer_float"))return!1;return hr(e)}function Jh(n){if(n===0)return!1;const e=lt(n);if(n===1){if(!qe(e,"OES_texture_float")||!qe(e,"WEBGL_color_buffer_float"))return!1}else{if(qe(e,"EXT_color_buffer_float"))return hr(e);const s="EXT_color_buffer_half_float";if(qe(e,s)){const r=e.getExtension(s);return lT(e,r)}return!1}return hr(e)}function hr(n){const e=Aa(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),a}function lT(n,e){const t=Aa(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),l}function ep(n){return n!==2?!1:lt(n).fenceSync!=null}function An(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&o.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const cT=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:An,bindCanvasToFramebuffer:rT,bindColorTextureToFramebuffer:Ms,bindTextureToProgramUniformSampler:Hh,bindTextureUnit:Wh,bindVertexBufferToProgramAttribute:cr,callAndCheck:U,canBeRepresented:Dh,createFragmentShader:Oh,createFramebuffer:Vh,createProgram:Lh,createStaticIndexBuffer:zh,createStaticVertexBuffer:Mh,createTexture:_h,createVertexShader:Fh,getBatchDim:sn,getExtensionOrThrow:Hn,getFramebufferErrorMessage:qh,getMaxTexturesInShader:Yh,getNumChannels:sT,getProgramUniformLocation:Uh,getProgramUniformLocationOrThrow:Gh,getRowsCols:on,getShapeAs3D:Xn,getTextureShapeFromLogicalShape:jh,getWebGLDisjointQueryTimerVersion:Zh,getWebGLErrorMessage:Eh,getWebGLMaxTextureSize:Kh,hasExtension:qe,isCapableOfRenderingToFloatTexture:Qh,isDownloadFloatTextureEnabled:Jh,isReshapeFree:es,isWebGLFenceEnabled:ep,isWebGLVersionEnabled:dr,linkProgram:Ph,logShaderSourceAndInfoLog:Da,resetMaxTextureSize:iT,resetMaxTexturesInShader:aT,unbindColorTextureFromFramebuffer:ur,unbindTextureUnit:oT,validateFramebuffer:qn,validateProgram:Ps,validateTextureSize:Bh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j=o.env();j.registerFlag("HAS_WEBGL",()=>j.getNumber("WEBGL_VERSION")>0);j.registerFlag("WEBGL_VERSION",()=>dr(2)?2:dr(1)?1:0);j.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);j.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>j.get("WEBGL_VERSION")===2);j.registerFlag("WEBGL_CPU_FORWARD",()=>!0);j.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);j.registerFlag("WEBGL_PACK",()=>j.getBool("HAS_WEBGL"));j.registerFlag("WEBGL_PACK_NORMALIZATION",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_PACK_CLIP",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_PACK_REDUCE",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_LAZILY_UNPACK",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_CONV_IM2COL",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>j.getBool("WEBGL_PACK"));j.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Kh(j.getNumber("WEBGL_VERSION")));j.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Yh(j.getNumber("WEBGL_VERSION")));j.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=j.getNumber("WEBGL_VERSION");return n===0?0:Zh(n)});j.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>j.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!o.isMobile());j.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Qh(j.getNumber("WEBGL_VERSION")));j.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>j.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:j.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));j.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Jh(j.getNumber("WEBGL_VERSION")));j.registerFlag("WEBGL_FENCE_API_ENABLED",()=>ep(j.getNumber("WEBGL_VERSION")));j.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>j.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);j.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});j.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>o.isMobile()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});j.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);j.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);j.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);j.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);j.registerFlag("WEBGL_EXP_CONV",()=>!1);j.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>j.getBool("IS_TEST"));j.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);j.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);j.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);j.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pe(){let n,e,t,s,r,i,a,l,c,u;return o.env().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",l=o.env().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",a="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:l,defineSpecialInf:c,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function un(n,e,t="index"){const s=o.computeStrides(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / ${r}`,l=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${a}; ${l};`}).join("")}function Oo(n,e,t="index"){const s=o.computeStrides(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,l=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${a}; ${l};`}).join("")}function uT(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function dT(n,e,t="index"){const s=n.map((i,a)=>a),r=uT(s,e);return r.map((i,a)=>{const l=`int ${n[a]} = ${t} / ${r[a]}`,c=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${l}; ${c};`}).join("")}function Ea(n){const e=o.computeStrides(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Fa(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const tp=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:np}=_c;function hT(n,e,t){const s=[];if(n.forEach(f=>{const m=o.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?s.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(s.push(`uniform sampler2D ${f.name};`),s.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){const{uniformShape:g}=Oa(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${f.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${f.name}Shape;`);break}s.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{s.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(f=>pT(f,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,l=Pe(),c=gT(l);let u,d,h=yT(l);return e.isPacked?(u=fT(e.logicalShape,a,t.enableShapeUniforms),d=bT(l)):(u=mT(e.logicalShape,a,t.enableShapeUniforms),d=xT(l)),t.packedInputs&&(h+=ST),[h,c,d,r,u,i,t.userCode].join(`
`)}function Dn(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return LT(n,e);case 1:return MT(n,e);case 2:return _T(n,e);case 3:return VT(n,e);case 4:return GT(n,e);case 5:return UT(n);case 6:return HT(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function sp(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return OT(n);case 1:return PT(n,e);case 2:return zT(n,e);case 3:return BT(n,e);default:return WT(n,e)}}function pT(n,e,t=!1,s){let r="";t?r+=sp(n,s):r+=Dn(n,s);const i=n.shapeInfo.logicalShape,a=e.logicalShape;return i.length<=a.length&&(t?r+=qT(n,e):r+=XT(n,e)),r}function fT(n,e,t){switch(n.length){case 0:return op();case 1:return IT(n,e,t);case 2:return ET(n,e,t);case 3:return TT(n,e,t);default:return NT(n,e,t)}}function mT(n,e,t){switch(n.length){case 0:return op();case 1:return kT(n,e,t);case 2:return FT(n,e,t);case 3:return $T(n,e,t);case 4:return RT(n,e,t);case 5:return AT(n,e);case 6:return DT(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function gT(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function xT(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function bT(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function yT(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${CT}
    ${wT}
    ${vT}
  `}const CT=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,wT=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,vT=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ST=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function op(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function IT(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function kT(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function TT(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function $T(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Oo(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=un(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function NT(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let a=i,l="",c="b, r, c";for(let u=2;u<n.length-1;u++)a*=n[n.length-u-1],l=`
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    `+l,c=`b${u}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${l}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${c});
    }
  `}function RT(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Oo(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=un(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function AT(n,e){const t=un(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function DT(n,e){const t=un(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function ET(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(o.arraysEqual(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function FT(n,e,t){return o.arraysEqual(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function dn(n){return`offset${n}`}function OT(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Pe();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function LT(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=dn(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[l,c]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${l}, ${c}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function PT(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Pe();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function MT(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${En(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],a=r[1];if(a===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const l=dn(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${l});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${a}, index + ${l});
      return sampleTexture(${t}, uv);
    }
  `}function zT(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=i[0],l=i[1],c=Pe();if(i!=null&&o.arraysEqual(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${c.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${a}.0);

        return ${c.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${u[0]}, ${u[1]}, row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `}function _T(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&o.arraysEqual(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const p=i[0],f=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:l}=o.squeezeShape(t),c=a;if(c.length<t.length){const p=Fn(n,c),f=["row","col"];return`
      ${Dn(p,e)}
      float ${r}(int row, int col) {
        return ${r}(${On(f,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${En(n)}
      }
    `;const u=i[0],d=i[1],h=dn(s);return d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${s}, uv);
    }
  `:u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function BT(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const p=t.slice(1),f=[1,2],m=Fn(n,p),g=["b","row","col"];return`
        ${sp(m,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${On(g,f)});
        }
      `}const l=Pe();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=a[0],u=a[1],d=Math.ceil(t[2]/2),h=d*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${u}, ${h}, ${d}, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function VT(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],a=t[2],{newShape:l,keptDims:c}=o.squeezeShape(t),u=l;if(u.length<t.length){const g=Fn(n,u),x=["row","col","depth"];return`
        ${Dn(g,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${On(x,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${a}, 1)));
        ${En(n)}
      }
    `;const d=n.shapeInfo.texShape,h=d[0],p=d[1],f=n.shapeInfo.flatOffset;if(p===i&&f==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===a&&f==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const m=dn(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${a} + depth + ${m};
        vec2 uv = uvFromFlat(${h}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function WT(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Pe();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,a=i.length,l=n.shapeInfo.texShape,c=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],u=c[0],d=c[1],h=Math.ceil(i[a-1]/2);let p=h*Math.ceil(i[a-2]/2),f="int b, int row, int col",m=`b * ${p} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<a-1;g++)f=`int b${g}, `+f,p*=i[a-g-1],m=`b${g} * ${p} + `+m;return`
    vec4 ${s}(${f}) {
      int index = ${m};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${u});
      return ${r.texture2D}(${t}, uv);
    }
  `}function GT(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],a=t[2]*i,l=t[1]*a,{newShape:c,keptDims:u}=o.squeezeShape(t);if(c.length<t.length){const y=Fn(n,c),w=["row","col","depth","depth2"];return`
      ${Dn(y,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${On(w,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${a}, ${i}, 1)));
        ${En(n)}
      }
    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],f=h[1],m=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,x=`int stride0 = ${s}Shape[1] * stride1;`;if(f===l&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(f===i&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;const b=dn(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${a} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${p}, ${f}, index + ${b});
      return sampleTexture(${s}, uv);
    }
  `}function UT(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,a=e[2]*i,l=e[1]*a,{newShape:c,keptDims:u}=o.squeezeShape(e);if(c.length<e.length){const g=Fn(n,c),x=["row","col","depth","depth2","depth3"];return`
      ${Dn(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${On(x,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${a}, ${i}, ${r})) +
          depth3;
        ${En(n)}
      }
    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],f=h[1];if(f===l&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=dn(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${a} + depth * ${i} +
          depth2 * ${r} + depth3 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function HT(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=o.squeezeShape(e);if(r.length<e.length){const x=Fn(n,r),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Dn(x)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${On(b,i)});
      }
    `}const a=e[5],l=e[4]*a,c=e[3]*l,u=e[2]*c,d=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${u}, ${c}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${En(n)}
      }
    `;const h=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,f=p[0],m=p[1];if(m===d&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${c}, ${l}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(m===a&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=dn(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${u} + depth * ${c} +
          depth2 * ${l} + depth3 * ${a} + depth4 + ${g};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${t}, uv);
    }
  `}function En(n){const e=n.name,t=o.sizeFromShape(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function qT(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,l=np(n.shapeInfo.logicalShape,e.logicalShape),c=ce(a),u=a-i;let d;const h=["x","y","z","w","u","v"];i===0?d="":a<2&&l.length>=1?d="coords = 0;":d=l.map(y=>`coords.${h[y+u]} = 0;`).join(`
`);let p="";a<2&&i>0?p="coords":p=n.shapeInfo.logicalShape.map((y,w)=>`coords.${h[w+u]}`).join(", ");let f="return outputValue;";const g=o.sizeFromShape(n.shapeInfo.logicalShape)===1,b=o.sizeFromShape(e.logicalShape)===1;if(i===1&&!g&&!b)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!b)a===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(l.length){const y=i-2,w=i-1;l.indexOf(y)>-1&&l.indexOf(w)>-1?f="return vec4(outputValue.x);":l.indexOf(y)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${p});
      ${f}
    }
  `}function XT(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,a=n.shapeInfo.texShape,l=n.shapeInfo.logicalShape.length,c=e.logicalShape.length;if(!n.shapeInfo.isUniform&&l===c&&n.shapeInfo.flatOffset==null&&o.arraysEqual(a,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=ce(c),d=np(n.shapeInfo.logicalShape,e.logicalShape),h=c-l;let p;const f=["x","y","z","w","u","v"];l===0?p="":c<2&&d.length>=1?p="coords = 0;":p=d.map(g=>`coords.${f[g+h]} = 0;`).join(`
`);let m="";return c<2&&l>0?m="coords":m=n.shapeInfo.logicalShape.map((g,x)=>`coords.${f[x+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${p}
      return get${s}(${m});
    }
  `}function ce(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Oa(n,e,t){const{newShape:s,keptDims:r}=o.squeezeShape(e),i=e.length,a=n&&i===3&&e[0]===1,l=a?e.slice(1):s,c=!n&&i>1&&!o.arraysEqual(e,t)&&s.length<i||a;return{useSqueezeShape:c,uniformShape:c?l:e,keptDims:r}}function Fn(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function On(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jT(n,e,t,s){const r=t.map((d,h)=>{const p={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(p.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:p}}),i=r.map(d=>d.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=hT(r,a,e),c=Oh(n.gl,l),u=n.createProgram(c);return o.env().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:c,source:l,webGLProgram:u,inShapeInfos:i,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:e,fragmentShader:c,source:l,webGLProgram:u,inShapeInfos:i,outShapeInfo:a},rp(n,e,u)))}function rp(n,e,t){const s=[],r=[];let i,a,l,c=null,u=null;u=n.getUniformLocation(t,"NAN",!1),o.env().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(const h of e.variableNames){const p={name:h,uniform:n.getUniformLocation(t,h,d),offset:n.getUniformLocation(t,`offset${h}`,d)};e.enableShapeUniforms&&(p.shape=n.getUniformLocation(t,`${h}Shape`,d),p.texShape=n.getUniformLocation(t,`${h}TexShape`,d)),s.push(p)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",d),l=n.getUniformLocation(t,"outShapeStrides",d),a=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms)for(const h of e.customUniforms)r.push(n.getUniformLocation(t,h.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:c,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:a}}function El(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],a=i.shape;if(!o.arraysEqual(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&i.isUniform)return;const l=t.texShape,c=i.isUniform?null:i.texData.texShape;if(!o.arraysEqual(l,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${c} must match`)})}function KT(n,e,t,s,r){e.program.enableShapeUniforms||(El(e.inShapeInfos,t),El([e.outShapeInfo],[s]));const i=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):n.setOutputMatrixTexture(i.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),o.env().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let c=0;c<t.length;++c){const u=t[c],{uniform:d,offset:h,shape:p,texShape:f}=e.variablesLocations[c];if(p){const{uniformShape:m}=Oa(e.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(p,new Int32Array(m));break;case 2:n.gl.uniform2iv(p,new Int32Array(m));break;case 3:n.gl.uniform3iv(p,new Int32Array(m));break;case 4:n.gl.uniform4iv(p,new Int32Array(m));break}}if(f&&n.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),d!=null){if(u.isUniform){if(o.sizeFromShape(u.shape)<2)n.gl.uniform1f(d,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(d,m)}continue}u.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,d,c)}}const l=e.outShapeLocation;if(l)switch(s.shape.length){case 1:n.gl.uniform1iv(l,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(l,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(l,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(l,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const c=o.computeStrides(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(c));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let c=0;c<e.program.customUniforms.length;++c){const u=e.program.customUniforms[c],d=e.customUniformLocations[c],h=r[c];if(u.type==="float")n.gl.uniform1fv(d,h);else if(u.type==="vec2")n.gl.uniform2fv(d,h);else if(u.type==="vec3")n.gl.uniform3fv(d,h);else if(u.type==="vec4")n.gl.uniform4fv(d,h);else if(u.type==="int")n.gl.uniform1iv(d,h);else if(u.type==="ivec2")n.gl.uniform2iv(d,h);else if(u.type==="ivec3")n.gl.uniform3iv(d,h);else if(u.type==="ivec4")n.gl.uniform4iv(d,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}n.executeProgram()}function YT(n,e,t){let s="";e.concat(t).forEach(a=>{const l=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const c=a.texData.texShape,{useSqueezeShape:u,uniformShape:d,keptDims:h}=Oa(n.packedInputs,a.shape,c);let p="",f="",m="";if(d.length===1&&n.packedInputs){const v=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];p=`${v[0]>1}_${v[1]>1}`}else if(d.length===2&&!n.packedInputs)f=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const v=o.computeStrides(d);m=`${v[0]===c[1]}_${v[v.length-1]===c[1]}`}const g=a.shape.length,x=d.length===2&&o.arraysEqual(a.shape,c),b=o.sizeFromShape(a.shape)===1,y=o.getBroadcastDims(a.shape,t.shape),w=!n.packedInputs&&g===t.shape.length&&o.arraysEqual(c,t.texData.texShape),C=n.packedInputs||d.length>2?"":`${c[0]>1}_${c[1]>1}`;s+=`${g}_${w}_${u?h:""}_${d.length}_${b}_${y}_${x}_${p}_${f}_${m}_${C}_${l}`}else{const c=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${c}_${l}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${o.env().getNumber("WEBGL_VERSION")}`,i}function Fe(n){return o.env().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZT{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Jn.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Pe();this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Oo(["r","c","d"],e):un(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QT{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Jn.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Pe();this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Oo(["r","c","d"],e):un(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JT{constructor(e){this.variableNames=["A"],this.outTexUsage=He.DOWNLOAD;const t=Pe();this.outputShape=e,this.userCode=`
      ${tp}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e${constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=He.DOWNLOAD;const t=Pe();this.outputShape=e,this.userCode=`
      ${tp}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t$={R:0,G:1,B:2,A:3};class Fl{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Pe();this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let a="";for(let l=0;l<s.length;l++){const c=s[l];a+=`
          if(offset == ${l}) {
            result = values[${t$[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Fa():Ea(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n${constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Pe();this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let l=0;l<=1;l++){const c=a*2+l;r+=`
          localCoords = coords;
          if(localCoords[2] + ${l} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${l};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Fa():Ea(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ip(n){const e=Pe(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Fh(n,t)}function ap(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Mh(n,e)}function lp(n){const e=new Uint16Array([0,1,2,2,1,3]);return zh(n,e)}function ys(n,e,t,s,r,i){Bh(e,t);const a=_h(n),l=n.TEXTURE_2D;return U(n,()=>n.bindTexture(l,a)),U(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),U(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),U(n,()=>n.texParameteri(l,n.TEXTURE_MIN_FILTER,n.NEAREST)),U(n,()=>n.texParameteri(l,n.TEXTURE_MAG_FILTER,n.NEAREST)),o.env().getNumber("WEBGL_VERSION")===1?U(n,()=>n.texImage2D(l,0,s,e,t,0,r,i,null)):U(n,()=>n.texStorage2D(l,1,s,e,t)),U(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function La(n){return n.internalFormatFloat}function cp(n,e,t,s){const[r,i]=bs(e,t);return ys(n,r,i,La(s),s.textureFormatFloat,n.FLOAT)}function Pa(n){return n.internalFormatHalfFloat}function up(n,e,t,s){const[r,i]=bs(e,t);return ys(n,r,i,Pa(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function Ma(n){return n.downloadTextureFormat}function dp(n,e,t,s){const[r,i]=bs(e,t);return ys(n,r,i,Ma(s),n.RGBA,n.UNSIGNED_BYTE)}function za(n){return n.internalFormatPackedFloat}function hp(n,e,t,s){const[r,i]=Rn(e,t);return ys(n,r,i,za(s),n.RGBA,n.FLOAT)}function _a(n){return n.internalFormatPackedHalfFloat}function pp(n,e,t,s){const[r,i]=Rn(e,t);return ys(n,r,i,_a(s),n.RGBA,s.textureTypeHalfFloat)}function fp(n,e,t){return U(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),cr(n,e,"clipSpacePos",t,3,20,0)&&cr(n,e,"uv",t,2,20,12)}function mp(n,e,t,s,r,i){U(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,l,c;r instanceof Uint8Array?(a=new Uint8Array(t*s*4),l=n.UNSIGNED_BYTE,c=n.RGBA):(a=new Float32Array(t*s*4),l=n.FLOAT,c=i.internalFormatPackedFloat),a.set(r),o.env().getNumber("WEBGL_VERSION")===2?U(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,l,a)):U(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,t,s,0,n.RGBA,l,a)),U(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function gp(n,e,t){U(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?o.env().getNumber("WEBGL_VERSION")===2?U(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):U(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):o.env().getNumber("WEBGL_VERSION")===2?U(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):U(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),U(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function xp(n,e,t,s){const r=n.createBuffer();U(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const l=4*4*e*t;return U(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,l,n.STREAM_READ)),U(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),U(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function bp(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function yp(n,e,t,s){const[r,i]=bs(e,t),a=4,l=new Uint8Array(Zk(e*t,a));return U(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function Cp(n,e,t,s,r,i,a,l){const c=n,u=new Float32Array(Qk(i,a));return c.bindBuffer(c.PIXEL_PACK_BUFFER,e),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,u),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),u}function wp(n,e,t){const s=new Float32Array(e*t*4);return U(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}const s$=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:fp,createBufferFromOutputTexture:xp,createFloat16MatrixTexture:up,createFloat16PackedMatrixTexture:pp,createFloat32MatrixTexture:cp,createIndexBuffer:lp,createPackedMatrixTexture:hp,createUnsignedBytesMatrixTexture:dp,createVertexBuffer:ap,createVertexShader:ip,downloadByteEncodedFloatMatrixFromOutputTexture:yp,downloadFloat32MatrixFromBuffer:bp,downloadMatrixFromPackedOutputTexture:wp,downloadPackedMatrixFromBuffer:Cp,getInternalFormatForFloat16MatrixTexture:Pa,getInternalFormatForFloat16PackedMatrixTexture:_a,getInternalFormatForFloat32MatrixTexture:La,getInternalFormatForPackedMatrixTexture:za,getInternalFormatForUnsignedBytesMatrixTexture:Ma,uploadDenseMatrixToTexture:mp,uploadPixelDataToTexture:gp},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bs{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=o.env().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,Ah(t,e)):this.gl=lt(t),e=this.gl,o.env().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>U(i,()=>i.createVertexArray()),this.bindVertexArray=a=>U(i,()=>i.bindVertexArray(a)),this.deleteVertexArray=a=>U(i,()=>i.deleteVertexArray(a)),this.getVertexArray=()=>U(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>U(e,()=>i.createVertexArrayOES()),this.bindVertexArray=a=>U(e,()=>i.bindVertexArrayOES(a)),this.deleteVertexArray=a=>U(e,()=>i.deleteVertexArrayOES(a)),this.getVertexArray=()=>U(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),o.env().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Hn(this.gl,i),qe(this.gl,a))this.textureHalfFloatExtension=Hn(this.gl,a);else if(o.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),qe(this.gl,r))this.colorBufferHalfFloatExtension=Hn(this.gl,r);else if(o.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",qe(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(qe(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=ap(this.gl),this.indexBuffer=lp(this.gl),this.framebuffer=Vh(this.gl),this.textureConfig=Aa(this.gl,this.textureHalfFloatExtension)}get debug(){return o.env().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;U(e,()=>e.finish()),U(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),U(e,()=>e.deleteFramebuffer(this.framebuffer)),U(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),U(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),U(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),cp(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),up(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),dp(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),gp(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),mp(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),pp(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),hp(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(ur(this.gl,this.framebuffer),this.outputTexture=null),U(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>yp(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,a){return Cp(this.gl,e,t,s,r,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return bp(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=xp(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(o.env().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(i,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=i}else o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>wp(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=ip(t));const s=Lh(t);U(t,()=>t.attachShader(s,this.vertexShader)),U(t,()=>t.attachShader(s,e)),Ph(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Ps(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;U(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),fp(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(U(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Ps(this.gl,this.program),U(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?Gh(this.gl,e,t):Uh(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),U(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),Hh(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=Rn(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Ps(this.gl,this.program),qn(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}U(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),U(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Hn(this.gl,o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await o.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=o$(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in o.env().platform&&(s=o.env().platform.setTimeoutCustom.bind(o.env().platform)),o.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ms(this.gl,e,this.framebuffer),this.debug&&qn(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ms(this.gl,this.outputTexture,this.framebuffer),this.debug&&qn(this.gl)):ur(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;Ms(r,e,this.framebuffer),this.debug&&qn(r),this.outputTexture=e,U(r,()=>r.viewport(0,0,t,s)),U(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),U(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function o$(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:r$,bincountImpl:vp,bincountReduceImpl:i$,bitwiseAndImpl:a$,castImpl:l$,ceilImpl:c$,concatImpl:u$,equalImpl:d$,expImpl:h$,expm1Impl:p$,floorImpl:f$,gatherNdImpl:m$,gatherV2Impl:g$,greaterImpl:x$,greaterEqualImpl:b$,lessImpl:y$,lessEqualImpl:C$,linSpaceImpl:w$,logImpl:v$,maxImpl:S$,maximumImpl:I$,minimumImpl:k$,multiplyImpl:T$,negImpl:$$,notEqualImpl:N$,prodImpl:R$,raggedGatherImpl:A$,raggedRangeImpl:D$,raggedTensorToTensorImpl:E$,rangeImpl:F$,rsqrtImpl:O$,scatterImpl:L$,sigmoidImpl:P$,simpleAbsImpl:Sp,sliceImpl:M$,sparseFillEmptyRowsImpl:z$,sparseReshapeImpl:_$,sparseSegmentReductionImpl:Ip,sqrtImpl:B$,staticRegexReplaceImpl:V$,stridedSliceImpl:W$,stringNGramsImpl:G$,stringSplitImpl:U$,stringToHashBucketFastImpl:H$,subImpl:q$,tileImpl:X$,topKImpl:j$,transposeImpl:Ba,uniqueImpl:K$}=hh;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kp(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Oe(n,e){return e===1?[n]:kp(n,e)}function Y$(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z${constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Fe(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Oe("rc",this.rank),s=ce(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)i=`${e[e.length-1-a]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tp{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Q$(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Fa():Ea(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function Q$(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?dT(["r","c","d"],"inputShape"):un(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J${constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=Ll(t,s),i=Pl(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const a=Ol(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const c=this.freeTextures[i].pop();return this.usedTextures[i].push(c),c}let l;return r===Ae.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Ae.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Ae.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Ae.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Ae.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(l),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),l}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=Ll(s,r),a=Pl(t,i,r);a in this.freeTextures||(this.freeTextures[a]=[]);const l=Ol(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),c=o.env().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=l):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const u=this.usedTextures[a],d=u&&u.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[d]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function eN(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function Ol(n,e,t,s,r){const i=tN(e,s);let a;if(r){const[c,u]=Rn(n[0],n[1]);a=c*u}else{const[c,u]=bs(n[0],n[1]);a=c*u}const l=eN(t,i);return a*l}function tN(n,e){switch(n){case Ae.PACKED_2X2_FLOAT32:return za(e);case Ae.PACKED_2X2_FLOAT16:return _a(e);case Ae.UNPACKED_FLOAT32:return La(e);case Ae.UNPACKED_FLOAT16:return Pa(e);case Ae.PACKED_4X1_UNSIGNED_BYTE:return Ma(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function nN(n){return o.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ae.PACKED_2X2_FLOAT32:Ae.UNPACKED_FLOAT32:n?Ae.PACKED_2X2_FLOAT16:Ae.UNPACKED_FLOAT16}function Ll(n,e){if(n===He.UPLOAD)return Ae.PACKED_2X2_FLOAT32;if(n===He.RENDER||n==null)return nN(e);if(n===He.DOWNLOAD||n===He.PIXELS)return Ae.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function Pl(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ft{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Qe="if (isnan(x)) return x;",sN="return x;",Ml="return abs(x);",oN="return (x >= 0.0) ? x : (exp(x) - 1.0);",rN=Qe+`
  return (x < 0.0) ? 0.0 : x;
`,iN=Qe+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Et="return x;",aN="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lN="return x;",cN=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,uN=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dN=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hN="return 1.0 / (1.0 + exp(-1.0 * x));";class Lt{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pN{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);const t=e.length,s=Oe("rc",t),r=ce(t),i=Y$(t,s),a=s.slice(-2),l=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fN=o.whereImpl,mN=1e-7,gN=1e-4,Os={};function xN(n){return n in Os||(Os[n]={}),Os[n]}const bN=o.env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),yN=600;function CN(){return o.env().global.screen==null?1024:o.env().global.screen.height*o.env().global.screen.width*window.devicePixelRatio*yN/1024/1024}class Cs extends o.KernelBackend{nextDataId(){return Cs.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!o.env().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Bs)t=e;else{const s=lt(o.env().getNumber("WEBGL_VERSION"),e);t=new Bs(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=lt(o.env().getNumber("WEBGL_VERSION"));t=new Bs(s),this.binaryCache=xN(o.env().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new J$(this.gpgpu),this.numMBBeforeWarning=CN(),this.texData=new o.DataStorage(this,o.engine())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,a){const l=this.makeTensorInfo(t,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[r,i]},c.texShape=[r,i];const u=Xn(t),d=new Fl(u,!1,a),h=this.runWebGLProgram(d,[l],s,[[r,i]]);return h.shape=t,c.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,t,s){if((o.env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||o.env().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:He.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(o.env().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:He.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:a,shape:l,isPacked:c}=t;if(a!=null){let p;c?p=new Lt(l,Et):p=new ft(l,Et);const f=this.runWebGLProgram(p,[{dataId:e,shape:l,dtype:r}],r),m=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const u=this.activeTimers!=null;let d;u&&(d=o.now());let h;if(r==="complex64"){const p=this.readSync(i.real.dataId),f=this.readSync(i.imag.dataId);h=It(p,f)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=o.now()-d),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const m=this.pendingRead.get(e);return new Promise(g=>m.push(g))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:a,complexTensorInfos:l,isPacked:c}=t;if(i!=null){let m;c?m=new Lt(r,Et):m=new ft(r,Et);const g=this.runWebGLProgram(m,[{dataId:e,shape:r,dtype:a}],a),x=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(s!=null)return this.convertAndCacheOnCPU(e);if(o.env().getBool("DEBUG")&&!o.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&o.env().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,d;if(a!=="complex64"&&o.env().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const m=this.texData.get(d.dataId);u=this.gpgpu.createBufferFromTexture(m.texture.texture,...Es(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(a==="complex64"){const m=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),g=m[0],x=m[1];h=It(g,x)}else if(u==null)h=this.getValuesFromTexture(e);else{const m=o.sizeFromShape(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,m)}if(d!=null&&this.disposeIntermediateTensorInfo(d),u!=null){const m=this.gpgpu.gl;U(m,()=>m.deleteBuffer(u))}const p=this.convertAndCacheOnCPU(e,h),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(m=>m(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&o.engine().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:a,dtype:l,isPacked:c,texture:u}=s;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let f;c?f=new Lt(i,Et):f=new ft(i,Et);const m=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:l}],l),g=this.readToGPU(m,t);return this.disposeIntermediateTensorInfo(m),g}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),h=o.engine().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>o.decodeString(r));return o.buffer(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return o.buffer(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!Dh(s))throw o.env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=o.sizeFromShape(t);if(o.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),f=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...Es(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(p),m}const a=o.env().getBool("WEBGL_PACK")&&r===!0,l=a?Xn(t):t,c=a?new e$(l):new JT(l),u=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=o.flatten(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),a=o.flatten(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(i);l.kernelMs=o.sum$1(c),l.getExtraProfileInfo=()=>c.map((u,d)=>({name:a[d],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:o.now(),endMs:null}}endTimer(e){return o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=o.now(),e)}async getQueryTime(e){if(o.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:a,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,u=this.dataRefCount.get(c);u>1?this.dataRefCount.set(c,u-1):(this.dataRefCount.delete(c),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=bN){return o.env().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&o.sizeFromShape(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){o.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return fN(e.shape,t)}packedUnaryOp(e,t,s){const r=new Lt(e.shape,t),i=this.compileAndRun(r,[e],s);return o.engine().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=Sp(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(o.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Ml,e.dtype);const t=new ft(e.shape,Ml),s=this.compileAndRun(t,[e]);return o.engine().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&o.isString(s[0])){const i=s.map(a=>o.encodeString(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return o.engine().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new pN(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Z$(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[sn(e.shape),...on(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[sn(t),...on(t)],a=new Tp(i,s),l=!0,c=[s],u=this.runWebGLProgram(a,[r],e.dtype,c,l);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:a}=s;if(t!=null){const p=o.sizeFromShape(i),f=t[0]*t[1]*4;o.assert(p<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=Xn(i);let c;r?c=new QT(l):c=new ZT(l);const u=!0,d=[t??Es(l)],h=this.runWebGLProgram(c,[{shape:l,dtype:a,dataId:e}],a,d,u,t);return{dtype:a,shape:i,dataId:h.dataId}}runWebGLProgram(e,t,s,r,i=!1,a){const l=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Jn.DENSE){const b=a??Es(e.outputShape);c.texShape=b.map(y=>y*2)}if(e.outTexUsage!=null&&(c.usage=e.outTexUsage),o.sizeFromShape(l.shape)===0)return c.values=o.getTypedArrayFromDType(l.dtype,0),l;const u=[],d=t.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(b.dataId);if(y.texture==null){if(!e.packedInputs&&o.sizeFromShape(b.shape)<=o.env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:y.values};e.packedInputs&&(y.isPacked=!0,y.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!y.isPacked!=!!e.packedInputs)b=y.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),y=this.texData.get(b.dataId);else if(y.isPacked&&!es(y.shape,b.shape)){const w=b,C=b.shape;b.shape=y.shape,b=this.packedReshape(b,C),u.push(b),y=this.texData.get(b.dataId),w.shape=C}return{shape:b.shape,texData:y,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:c,isUniform:!1},p=YT(e,d,h),f=this.getAndSaveBinary(p,()=>jT(this.gpgpu,e,d,h)),m=this.activeTimers!=null;let g;m&&(g=this.startTimer()),o.env().get("ENGINE_COMPILE_ONLY")||KT(this.gpgpu,f,d,h,r),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const x=o.env().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){const b=o.now();b-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!o.env().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&i===!1){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(o.env().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=o.tidy(()=>{if(!o.env().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=o.env().getBool("DEBUG");o.env().set("DEBUG",!1);const t=this.abs(o.scalar(1e-8)).dataSync()[0];if(o.env().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?mN:gN}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:a,usage:l,isPacked:c}=t;if(a!=null)return;const u=this.activeTimers!=null;let d;u&&(d=o.now());let h=t.texShape;if(h==null&&(h=jh(s,c),t.texShape=h),i!=null){const p=Xn(s);let f,m=h[1],g=h[0];const x=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!x)&&([m,g]=Rn(h[0],h[1])),c?f=new n$(p,x):f=new Fl(p,x);const b=x?[g,m]:h,y=this.makeTensorInfo(b,r),w=this.texData.get(y.dataId);x?w.usage=He.PIXELS:w.usage=He.UPLOAD,w.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),m,g,i);const C=[[g,m]],S=this.runWebGLProgram(f,[y],r,C,!0),I=this.texData.get(S.dataId);t.texShape=I.texShape,t.isPacked=I.isPacked,t.usage=I.usage,o.env().get("ENGINE_COMPILE_ONLY")?this.disposeData(S.dataId):(t.texture=I.texture,t.values=null,this.texData.delete(S.dataId)),this.disposeIntermediateTensorInfo(y),u&&(this.uploadWaitMs+=o.now()-d)}else{const p=this.acquireTexture(h,l,r,c);t.texture=p}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=wN(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*o.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Sr(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Da(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:c}=rp(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=c}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:a,channels:l}=e,c=o.engine().backend;if(!c.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=c.writeTexture(r,t,s,i,a,l);return o.engine().makeTensorFromDataId(u,t,s,c)}}Cs.nextDataId=0;function wN(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/** @license See the LICENSE file. */const $p="4.22.0";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Np(){o.env().set("WEBGL_FORCE_F16_TEXTURES",!0)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.isBrowser()&&o.registerBackend("webgl",()=>new Cs,2);const vN={forceHalfFloat:Np};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Va=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class rn{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=o.assertAndGetBroadcastShape(t,s),this.enableShapeUniforms=Fe(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hn=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Ln{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o.assertAndGetBroadcastShape(t,s);const i=this.outputShape.length;this.enableShapeUniforms=Fe(i);let a="";if(r)if(i===0||o.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${ce(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=Oe("coords",i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const SN={kernelName:o.Identity,backendName:"webgl",kernelFunc:We};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ut(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(i.dataId),l=We({inputs:{x:s},backend:t}),c=We({inputs:{x:r},backend:t});return a.complexTensorInfos={real:l,imag:c},i}const IN={kernelName:o.Complex,backendName:"webgl",kernelFunc:Ut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rp="return (a < 0.) ? b * a : a;",Ap=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function kN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,a=t.makeTensorInfo([],"float32",o.createScalarValue(i,"float32")),l=o.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ln(Ap,r.shape,a.shape):new rn(Rp,r.shape,a.shape),c=t.runWebGLProgram(l,[r,a],"float32");return t.disposeIntermediateTensorInfo(a),c}const TN={kernelName:o.LeakyRelu,backendName:"webgl",kernelFunc:kN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dp="return (a < 0.) ? b * a : a;",Ep=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $N(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=o.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ln(Ep,s.shape,r.shape):new rn(Dp,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const NN={kernelName:o.Prelu,backendName:"webgl",kernelFunc:$N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pn="if (isnan(x)) return x;";function se({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,l=i,c=s||a.dtype;if(l.shouldExecuteOnCPU([a])&&t!=null){const h=l.texData.get(a.dataId),p=t(h.values,c);return l.makeTensorInfo(a.shape,c,p)}const u=o.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return u?d=new Lt(a.shape,e):d=new ft(a.shape,n),l.runWebGLProgram(d,[a],c)}}function De({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:l})=>{const{a:c,b:u}=a,d=l;if(s&&c.dtype==="complex64"){const m=d.texData.get(c.dataId),g=d.texData.get(u.dataId),[x,b]=[[m.complexTensorInfos.real,g.complexTensorInfos.real],[m.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(w=>{const[C,v]=w,S={dataId:C.dataId,dtype:C.dtype,shape:c.shape},I={dataId:v.dataId,dtype:v.dtype,shape:u.shape},k=new rn(n,c.shape,u.shape);return d.runWebGLProgram(k,[S,I],o.upcastType(C.dtype,v.dtype))}),y=Ut({inputs:{real:x,imag:b},backend:d});return d.disposeIntermediateTensorInfo(x),d.disposeIntermediateTensorInfo(b),y}const h=i||o.upcastType(c.dtype,u.dtype);if((c.dtype==="string"||u.dtype==="string"||d.shouldExecuteOnCPU([c,u]))&&r!=null){const m=d.texData.get(c.dataId).values,g=d.texData.get(u.dataId).values,x=c.dtype==="string"?kt(m):m,b=c.dtype==="string"?kt(g):g,[y,w]=r(c.shape,u.shape,x,b,h),C=d.makeTensorInfo(w,h),v=d.texData.get(C.dataId);return v.values=y,C}const p=o.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let f;return p?f=new Ln(e,c.shape,u.shape,t):f=new rn(n,c.shape,u.shape),d.runWebGLProgram(f,[c,u],h)}}function ts(n,e=!1){if(n==="linear")return e?lN:sN;if(n==="relu")return e?uN:rN;if(n==="elu")return e?cN:oN;if(n==="relu6")return e?dN:iN;if(n==="prelu")return e?Ep:Dp;if(n==="leakyrelu")return e?Ap:Rp;if(n==="sigmoid")return e?hN:aN;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fp{constructor(e,t,s,r=!1,i=!1,a=!1,l=null,c=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Fe(this.outputShape.length);const d=r?e[1]:e[2],h=Math.ceil(d/2),p=r?"i * 2, rc.y":"rc.y, i * 2",f=i?"rc.z, i * 2":"i * 2, rc.z",m=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",b="";l&&(c?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:u?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:x=`vec4 activation(vec4 x) {
          ${l}
        }`,b="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let w="rc.x",C="rc.x";e[0]<t[0]?w=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(C=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${x}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${C};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${g[0]});
          result += (${m[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${b}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zl={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class _l{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=o.assertAndGetBroadcastShape(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bl="return a * b;";function Wa(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=o.upcastType(s.dtype,r.dtype);if(s.dtype==="complex64"){const l=t.texData.get(s.dataId),c=t.texData.get(r.dataId),u=new _l(zl.REAL,s.shape,r.shape),d=new _l(zl.IMAG,s.shape,r.shape),h=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:r.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:r.shape}],p=t.runWebGLProgram(u,h,"float32"),f=t.runWebGLProgram(d,h,"float32"),m=Ut({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),m}if(t.shouldExecuteOnCPU([s,r])){const l=t.texData.get(s.dataId),c=t.texData.get(r.dataId),[u,d]=T$(s.shape,r.shape,l.values,c.values,i),h=t.makeTensorInfo(d,i),p=t.texData.get(h.dataId);return p.values=u,h}let a;return o.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ln(Bl,s.shape,r.shape):a=new rn(Bl,s.shape,r.shape),t.runWebGLProgram(a,[s,r],i)}const RN={kernelName:o.Multiply,backendName:"webgl",kernelFunc:Wa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(n,e,t){const s=[sn(n.shape),...on(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[sn(e),...on(e)],a=new Tp(i,s),l=!0,c=[s],u=t.runWebGLProgram(a,[r],n.dtype,c,l);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=t,l=o.sizeFromShape(r.shape),c=o.inferFromImplicitShape(i,l),u=o.sizeFromShape(c);o.assert(l===u,()=>`The new shape (${c}) has ${u} elements and the old shape (${r.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const d=a.texData.get(r.dataId);return d.isPacked&&!es(r.shape,c)&&!(d.texture!==null&&es(d.shape,c))?AN(r,c,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype})}const DN={kernelName:o.Reshape,backendName:"webgl",kernelFunc:G};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vl{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];const l=Math.floor(s/4)*4,c=s%4;let u="sumValue += dot(values, ones);";if(t!=null){const h=1/t;u=`sumValue += dot(values * ${o.isInt(h)?h.toPrecision(2):h}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${l};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EN{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];let l="0.0",c="";t==="prod"?l="1.0":t==="min"?(l="1.0 / 1e-20",c="min"):t==="max"&&(l="-1.0 / 1e-20",c="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const d=Math.floor(s/4)*4,h=s%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(l="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(l="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let m="";i%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${l};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${l});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${h===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${h===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${h===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=lo(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function pn(n,e,t,s){const r=FN(n.shape);let i=n;for(let a=0;a<r.length;a++){const{inSize:l,windowSize:c,outSize:u}=r[a];let d,h;t==="mean"?d=a===0?new Vl({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:u},l):new Vl({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:u}):d=new EN({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:u},t),h=i,i=s.runWebGLProgram(d,[i],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ON{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const r=ce(this.rank),i=LN(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function LN(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PN{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[t[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=ce(this.rank),i=kp("rc",this.rank),a=new Array(this.rank);for(let d=0;d<t.length;d++)a[t[d]]=i[d];const l=`vec2(${a.slice(-2).join()})`,c=`++${i[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${l})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${c}) {
        result[1] = ${u};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${u};
        if(${c}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lo(n,e,t){const s=o.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PN(n.shape,e):new ON(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MN(n,e,t,s){const r=e,i=n.shape.length,a=o.parseAxisParam(r,n.shape);let l=a;const c=o.getAxesPermutation(l,i),u=c!=null;let d=n;u&&(d=Lo(n,c,s),l=o.getInnerMostAxes(l.length,i)),o.assertAxesAreInnerMostDims("sum",l,i);const[h,p]=o.computeOutAndReduceShapes(d.shape,l);let f=h;t&&(f=o.expandShapeToKeepDim(h,a));const m=o.sizeFromShape(p),x=o.sizeFromShape(n.shape)/m,b=G({inputs:{x:d},attrs:{shape:[x,m]},backend:s}),y=o.sumOutType(n.dtype),w=pn(b,y,"sum",s),C=G({inputs:{x:w},attrs:{shape:f},backend:s});return s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(w),u&&s.disposeIntermediateTensorInfo(d),C}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Po(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return MN(r,i,a,t)}const zN={kernelName:o.Sum,backendName:"webgl",kernelFunc:Po};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Le(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,a=t,l=r.shape.length,c=new Array(l);for(let d=0;d<c.length;d++)c[d]=r.shape[i[d]];let u;if(a.shouldExecuteOnCPU([r])){const h=a.texData.get(r.dataId).values,p=Ba(h,r.shape,r.dtype,i,c);u=a.makeTensorInfo(c,r.dtype);const f=a.texData.get(u.dataId);f.values=p}else u=Lo(r,i,a);return u}const _N={kernelName:o.Transpose,backendName:"webgl",kernelFunc:Le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Op=1e3;function so({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:l=0,activation:c=null}){const u=n.shape.length,d=e.shape.length,h=t?n.shape[u-2]:n.shape[u-1],p=s?e.shape[d-1]:e.shape[d-2],f=t?n.shape[u-1]:n.shape[u-2],m=s?e.shape[d-2]:e.shape[d-1],g=n.shape.slice(0,-2),x=e.shape.slice(0,-2),b=o.sizeFromShape(g),y=o.sizeFromShape(x),C=o.assertAndGetBroadcastShape(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,m]);o.assert(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const v=t?[b,h,f]:[b,f,h],S=s?[y,m,p]:[y,p,m],I=G({inputs:{x:n},backend:r,attrs:{shape:v}}),k=G({inputs:{x:e},backend:r,attrs:{shape:S}}),$=[I,k],N=Math.max(b,y),R=t?I.shape[1]:I.shape[2],F=i!=null,O=a!=null,L=c==="leakyrelu",A=c!=null?ts(c,!0):null,E=F||O||L||A!=null;let P;if((f===1||m===1)&&R>Op&&E===!1){let M=I,_=k;t&&(M=Le({inputs:{x:I},backend:r,attrs:{perm:[0,2,1]}}),$.push(M)),s&&(_=Le({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),$.push(_));const z=m!==1,V=m===1;let B=M;z&&(B=G({inputs:{x:M},backend:r,attrs:{shape:[N,R,1]}}),$.push(B));const H=m===1?2:1;let W=_;V&&(W=G({inputs:{x:_},backend:r,attrs:{shape:[N,1,R]}}),$.push(W));const q=Wa({inputs:{a:B,b:W},backend:r});P=Po({inputs:{x:q},backend:r,attrs:{axis:H,keepDims:!0}}),$.push(q)}else{const M=o.upcastType(n.dtype,e.dtype),_=new Fp(v,S,[N,f,m],t,s,F,A,O,L),z=[I,k];if(i!=null&&z.push(i),O&&z.push(a),L){const V=r.makeTensorInfo([],"float32",o.createScalarValue(l,"float32"));z.push(V),$.push(V)}P=r.runWebGLProgram(_,z,M)}const D=G({inputs:{x:P},backend:r,attrs:{shape:C}});$.push(P);for(const M of $)r.disposeIntermediateTensorInfo(M);return D}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:l}=e,{transposeA:c,transposeB:u,activation:d,leakyreluAlpha:h}=s;return so({a:r,b:i,transposeA:c,transposeB:u,backend:t,bias:a,preluActivationWeights:l,leakyreluAlpha:h,activation:d})}const VN={kernelName:o._FusedMatMul,backendName:"webgl",kernelFunc:BN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wl="return abs(x);";function WN(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),a=Sp(i.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let r;return o.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Lt(s.shape,Wl):r=new ft(s.shape,Wl),t.runWebGLProgram(r,[s],s.dtype)}const GN={kernelName:o.Abs,backendName:"webgl",kernelFunc:WN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UN=Qe+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,HN=se({opSnippet:UN}),qN={kernelName:o.Acos,backendName:"webgl",kernelFunc:HN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XN=Qe+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,jN=se({opSnippet:XN}),KN={kernelName:o.Acosh,backendName:"webgl",kernelFunc:jN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gl="return a + b;",YN=De({opSnippet:Gl,packedOpSnippet:Gl,supportsComplex:!0,cpuKernelImpl:r$}),ZN={kernelName:o.Add,backendName:"webgl",kernelFunc:YN};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QN{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JN{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vs(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return We({inputs:{x:s[0]},backend:t});if(s.length>o.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(s.length/2),u=Vs({inputs:s.slice(0,c),backend:t}),d=Vs({inputs:s.slice(c),backend:t});return Vs({inputs:[u,d],backend:t})}const r=s.map(c=>c.dtype).reduce((c,u)=>o.upcastType(c,u)),i=s.map(c=>c.shape),l=o.env().getBool("WEBGL_PACK")?new JN(s[0].shape,i):new QN(s[0].shape,i);return t.runWebGLProgram(l,s,r)}const eR={kernelName:o.AddN,backendName:"webgl",kernelFunc:Vs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,l=r.shape.length,c=o.parseAxisParam(i,r.shape);let u=c;const d=o.getAxesPermutation(u,l);let h=r;d!=null&&(h=Le({inputs:{x:r},backend:t,attrs:{perm:d}}),u=o.getInnerMostAxes(u.length,l)),o.assertAxesAreInnerMostDims("all",u,l);const[p,f]=o.computeOutAndReduceShapes(h.shape,u),m=o.sizeFromShape(f),g=G({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),x=pn(g,g.dtype,"all",t);let b;if(a){const y=o.expandShapeToKeepDim(p,c);b=G({inputs:{x},backend:t,attrs:{shape:y}})}else b=G({inputs:{x},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),d!=null&&t.disposeIntermediateTensorInfo(h),b}const nR={kernelName:o.All,backendName:"webgl",kernelFunc:tR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,l=r.shape.length,c=o.parseAxisParam(i,r.shape);let u=c;const d=o.getAxesPermutation(u,l);let h=r;d!=null&&(h=Le({inputs:{x:r},backend:t,attrs:{perm:d}}),u=o.getInnerMostAxes(u.length,l)),o.assertAxesAreInnerMostDims("any",u,l);const[p,f]=o.computeOutAndReduceShapes(h.shape,u),m=o.sizeFromShape(f),g=G({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),x=pn(g,g.dtype,"any",t);let b;if(a){const y=o.expandShapeToKeepDim(p,c);b=G({inputs:{x},backend:t,attrs:{shape:y}})}else b=G({inputs:{x},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),d!=null&&t.disposeIntermediateTensorInfo(h),b}const oR={kernelName:o.Any,backendName:"webgl",kernelFunc:sR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rR{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const l=t==="max"?">":"<",c=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${l} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iR{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,o.assert(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],a=Math.ceil(i/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const l=this.outputShape,c=l.length,u=ce(c),d=Oe("coords",c);let h,p;if(a===1){p=c+1;const k=ce(p);h=`
        ${k} sourceLocR = ${k}(${d.join()}, 0);
        ++${d[c-1]};
        ${k} sourceLocG = ${k}(${d.join()}, 0);
        ++${d[c-2]};
        ${k} sourceLocA = ${k}(${d.join()}, 0);
        --${d[c-1]};
        ${k} sourceLocB = ${k}(${d.join()}, 0);
        --${d[c-2]};`}else p=c,h=`
        ${u} sourceLocR = coords;
        ++${d[c-1]};
        ${u} sourceLocG = coords;
        ++${d[c-2]};
        ${u} sourceLocA = coords;
        --${d[c-1]};
        ${u} sourceLocB = coords;
        --${d[c-2]};`;const f=["x","y","z","w","u","v"].slice(0,p),m="."+f[p-1],g=f.map(k=>"int "+k),x=Oe("sourceLocR",p-1).concat("inIdx.r"),b=Oe("sourceLocG",p-1).concat("inIdx.g"),y=Oe("sourceLocB",p-1).concat("inIdx.b"),w=Oe("sourceLocA",p-1).concat("inIdx.a"),C=s==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${w.join()})));`,S=`vec4(
            getAChannel(${x.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,I=r?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${d[c-1]} < ${l[c-1]-1};
        bool hasNextRow = ${d[c-2]} < ${l[c-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${S};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${S};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lp(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const a=lo(i),l={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},c=new rR(l,t,s==null),u=[e];s!=null&&u.push(s);const d=n.runWebGLProgram(c,u,"int32");if(d.shape[1]===1)return d;const h=Lp(n,e,t,d);return n.disposeIntermediateTensorInfo(d),h}function Pp(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],a=lo(i),l=new iR(r,a,t,s==null),c=s==null?[e]:[e,s],u=n.runWebGLProgram(l,c,"int32");if(u.shape.length===e.shape.length){const d=Pp(n,e,t,u);return n.disposeIntermediateTensorInfo(u),d}return u}function Mp(n,e,t,s){const r=[t];if(o.assertAxesAreInnerMostDims("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!o.env().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],a=n.texData.get(e.dataId),l=a!==null&&a.isPacked;let c=e;l&&(c=n.unpackTensor(e),i.push(c));const[u,d]=o.computeOutAndReduceShapes(c.shape,r),h=o.sizeFromShape(d),p=G({inputs:{x:c},backend:n,attrs:{shape:[-1,h]}});i.push(p);const f=Lp(n,p,s);i.push(f);const m=G({inputs:{x:f},backend:n,attrs:{shape:u}});return i.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}return Pp(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=o.parseAxisParam(i,r.shape);const l=o.getAxesPermutation(a,r.shape.length);let c=r;const u=[];l!=null&&(c=Le({inputs:{x:r},backend:t,attrs:{perm:l}}),u.push(c),a=o.getInnerMostAxes(a.length,c.shape.length)),o.assertAxesAreInnerMostDims("argMax",[a[0]],c.shape.length);const d=Mp(t,c,a[0],"max");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}const lR={kernelName:o.ArgMax,backendName:"webgl",kernelFunc:aR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=o.parseAxisParam(i,r.shape);const l=o.getAxesPermutation(a,r.shape.length);let c=r;const u=[];l!=null&&(c=Le({inputs:{x:r},backend:t,attrs:{perm:l}}),u.push(c),a=o.getInnerMostAxes(a.length,c.shape.length)),o.assertAxesAreInnerMostDims("argMin",[a[0]],c.shape.length);const d=Mp(t,c,a[0],"min");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}const uR={kernelName:o.ArgMin,backendName:"webgl",kernelFunc:cR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dR=Qe+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,hR=se({opSnippet:dR}),pR={kernelName:o.Asin,backendName:"webgl",kernelFunc:hR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fR=Qe+"return log(x + sqrt(x * x + 1.0));",mR=se({opSnippet:fR}),gR={kernelName:o.Asinh,backendName:"webgl",kernelFunc:mR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xR=Qe+`
  return atan(x);
`,bR=se({opSnippet:xR}),yR={kernelName:o.Atan,backendName:"webgl",kernelFunc:bR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CR=Va+`
  return atan(a, b);
`,wR=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+hn+`
  return result;
`,vR=De({opSnippet:CR,packedOpSnippet:wR}),SR={kernelName:o.Atan2,backendName:"webgl",kernelFunc:vR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IR=Qe+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,kR=se({opSnippet:IR}),TR={kernelName:o.Atanh,backendName:"webgl",kernelFunc:kR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ns{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(g||(y="-1.0 / 1e-20"),s){const k=">=";this.userCode=`
        const ivec2 strides = ivec2(${l}, ${c});
        const ivec2 pads = ivec2(${f}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${k} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?x:b:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / max(count, 1.0)");const v=Math.floor(a/4)*4,S=a%4,I=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${f}, ${m});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${I}
          }

          int xC = xCCorner + ${v};
          if (${S===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${S===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${S===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${I}
          }
        }
        setOutput(${C});
      }
    `}}class Ga{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,l=e.strideDepth,c=e.strideHeight,u=e.strideWidth,d=e.dilationDepth,h=e.dilationHeight,p=e.dilationWidth,f=e.effectiveFilterDepth,m=e.effectiveFilterHeight,g=e.effectiveFilterWidth,x=e.padInfo.front,b=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const w=t==="avg";let C="0.0";if(w||(C="-1.0 / 1e-20"),s){const N=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${l}, ${c}, ${u});
        const ivec3 pads = ivec3(${x}, ${b}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${N} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${m} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(S="avgValue / max(count, 1.0)");const I=Math.floor(a/4)*4,k=a%4,$=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${l}, ${c}, ${u});
      const ivec3 pads = ivec3(${x}, ${b}, ${y});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${I}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${$}
            }

            int xC = xCCorner + ${I};
            if (${k===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${k===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${k===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${$}
            }
          }
        }
        setOutput(${S});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $R(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;An(r,"avgPool");const{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=s,u=1;o.assert(o.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const d=o.computePool2DInfo(r.shape,i,a,u,l,c);if(d.filterWidth===1&&d.filterHeight===1&&o.arraysEqual(d.inShape,d.outShape))return We({inputs:{x:r},backend:t});const h=new ns(d,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const NR={kernelName:o.AvgPool,backendName:"webgl",kernelFunc:$R};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:l,dimRoundingMode:c,dataFormat:u}=s,d=[1,1,1],h=o.computePool3DInfo(r.shape,i,a,d,l,c,u),p=new Ga(h,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const AR={kernelName:o.AvgPool3D,backendName:"webgl",kernelFunc:RR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=c-1-e.padInfo.top,h=u-1-e.padInfo.left,p=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${h});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${l}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class ER{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=h-1-e.padInfo.front,g=p-1-e.padInfo.top,x=f-1-e.padInfo.left,b=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${g}, ${x});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FR(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=s,h=[1,1,1],p=o.computePool3DInfo(a.shape,l,c,h,u,d),f=new ER(p);return t.runWebGLProgram(f,[r],a.dtype)}const OR={kernelName:o.AvgPool3DGrad,backendName:"webgl",kernelFunc:FR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LR(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;An([r,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:u}=s,d=o.computePool2DInfo(a.shape,l,c,1,u),h=new DR(d);return t.runWebGLProgram(h,[r],a.dtype)}const PR={kernelName:o.AvgPoolGrad,backendName:"webgl",kernelFunc:LR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:l}=s;return so({a:r,b:i,transposeA:a,transposeB:l,backend:t})}const zR={kernelName:o.BatchMatMul,backendName:"webgl",kernelFunc:MR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _R{constructor(e,t,s,r,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],o.assertAndGetBroadcastShape(e,t),o.assertAndGetBroadcastShape(e,s);let l="0.0";r!=null&&(o.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="1.0";i!=null&&(o.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${l};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BR{constructor(e,t,s,r,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],o.assertAndGetBroadcastShape(e,t),o.assertAndGetBroadcastShape(e,s);let l="vec4(0.0)";r!=null&&(o.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="vec4(1.0)";i!=null&&(o.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${l};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VR=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:a,scale:l}=n;o.assert(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),o.assert(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),o.assert(l==null||r.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=t;c==null&&(c=.001);const u=[s,r,i];let d=null;a!=null&&(d=a.shape,u.push(a));let h=null;l!=null&&(h=l.shape,u.push(l));const p=o.env().getBool("WEBGL_PACK_NORMALIZATION")?new BR(s.shape,r.shape,i.shape,d,h,c):new _R(s.shape,r.shape,i.shape,d,h,c);return e.runWebGLProgram(p,u,u[0].dtype)},WR={kernelName:o.FusedBatchNorm,backendName:"webgl",kernelFunc:VR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GR{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=ce(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=UR(this.rank);let r;const i=e.map((a,l)=>`sourceLoc.${pr[l]} = start[${l}] + coords.${pr[l]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const pr=["x","y","z","w","u","v"];function UR(n){if(n===1)return"sourceLoc";if(n<=6)return pr.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HR{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=ce(this.rank),s=Oe("coords",this.rank),r=Oe("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${i})`,l=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,h)=>`start[${h}]`).join()});`:e.map((d,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${l}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qR(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),a=s.texData.get(i.dataId);Object.assign(a,r),a.refCount=1,a.shape=t,a.dtype=n.dtype;let l=wr(e,o.computeStrides(n.shape));r.slice&&(l+=r.slice.flatOffset),a.slice={flatOffset:l,origDataId:r.slice&&r.slice.origDataId||n.dataId};const c=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,c+1),i}function Mn(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s,[l,c]=ao(r,i,a);if(br(r,l,c),o.sizeFromShape(c)===0)return t.makeTensorInfo(c,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),p=M$(h.values,l,c,r.shape,r.dtype);return t.makeTensorInfo(c,r.dtype,p)}const{isPacked:u}=t.texData.get(r.dataId),d=Cr(r.shape,l,c);if(u||!d){const h=o.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HR(c):new GR(c),p=[l];return t.runWebGLProgram(h,[r],r.dtype,p)}return t.uploadToGPU(r.dataId),qR(r,l,c,t)}const XR={kernelName:o.Slice,backendName:"webgl",kernelFunc:Mn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jR=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;o.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((y,w)=>y*w),c=os(r.shape,i,l),u=rs(c.length,i.length),d=is(r.shape,i,l),h=$r(a,i.length),p=Nr(d,a,i.length),f=[],m=G({inputs:{x:r},backend:t,attrs:{shape:c}}),g=Le({inputs:{x:m},backend:t,attrs:{perm:u}}),x=G({inputs:{x:g},backend:t,attrs:{shape:d}}),b=Mn({inputs:{x},backend:t,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(x),f.forEach(y=>t.disposeIntermediateTensorInfo(y)),b},KR={kernelName:o.BatchToSpaceND,backendName:"webgl",kernelFunc:jR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,l=t.readSync(r.dataId),c=t.readSync(i.dataId),u=vp(l,c,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,u)}const ZR={kernelName:o.Bincount,backendName:"webgl",kernelFunc:YR};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QR=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,JR=`
  return float(int(a.r) & int(b.r));
`;function eA(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=o.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=o.env().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||a===1){const c=t.texData.get(s.dataId).values,u=t.texData.get(r.dataId).values,[d,h]=a$(s.shape,r.shape,c,u,s.dtype),p=t.makeTensorInfo(h,s.dtype),f=t.texData.get(p.dataId);return f.values=d,p}let l;return i?l=new Ln(QR,s.shape,r.shape,!1):l=new rn(JR,s.shape,r.shape),t.runWebGLProgram(l,[s,r],s.dtype)}const tA={kernelName:o.BitwiseAnd,backendName:"webgl",kernelFunc:eA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nA(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),a=t.readSync(r.dataId),l=o.assertAndGetBroadcastShape(Array.from(i),Array.from(a));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const sA={kernelName:o.BroadcastArgs,backendName:"webgl",kernelFunc:nA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oA="return float(a != b);",zp=De({opSnippet:oA,cpuKernelImpl:N$,dtype:"bool"}),rA={kernelName:o.NotEqual,backendName:"webgl",kernelFunc:zp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ws(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return We({inputs:{x:r.complexTensorInfos.real},backend:t})}const iA={kernelName:o.Real,backendName:"webgl",kernelFunc:ws};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aA="return float(int(x));";function lA(n,e){const t=new ft(n.shape,aA),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fr(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return We({inputs:{x:r},backend:t});const a=o.zeros(r.shape),l=fr({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),c=Ut({inputs:{real:l,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(l),c}if(r.dtype==="complex64"){const a=ws({inputs:{input:r},backend:t}),l=fr({inputs:{x:a},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(a),l}if(!o.hasEncodingLoss(r.dtype,i)){const a=We({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId).values,[l,c,u]=l$(a,r.shape,r.dtype,i);return t.makeTensorInfo(l,c,u)}if(i==="int32")return lA(r,t);if(i==="bool"){const a=t.makeTensorInfo([],"bool",o.getTypedArrayFromDType("bool",1)),c=zp({inputs:{a:r,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),c}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const cA={kernelName:o.Cast,backendName:"webgl",kernelFunc:fr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ul="return ceil(x);",uA=se({opSnippet:Ul,packedOpSnippet:Ul,cpuKernelImpl:c$}),dA={kernelName:o.Ceil,backendName:"webgl",kernelFunc:uA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hA{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let l;o.env().getBool("WEBGL_PACK_CLIP")?l=new pA(r.shape):l=new hA(r.shape);const c=[[i],[a]];return t.runWebGLProgram(l,[r],r.dtype,c)}const mA={kernelName:o.ClipByValue,backendName:"webgl",kernelFunc:fA};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gA{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hl(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function xA(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new gA(s.shape),a=[Hl(s,r.complexTensorInfos.real),Hl(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,a,a[0].dtype)}const bA={kernelName:o.ComplexAbs,backendName:"webgl",kernelFunc:xA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yA{constructor(e){this.outputShape=[],this.outputShape=mt(e,1),this.variableNames=e.map((a,l)=>`T${l}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const l=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${l}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CA{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=mt(e,t);const s=this.outputShape,r=s.length,i=ce(r),a=Oe("coords",r),l=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((g,x)=>`T${x}`);const c=new Array(e.length-1);c[0]=e[0][t];for(let g=1;g<c.length;g++)c[g]=c[g-1]+e[g][t];const u=l[t],d=l.slice(-2),h=l.join();let p=`if (${u} < ${c[0]}) {
        return getChannel(
            getT0(${h}), vec2(${d.join()}));
        }`;for(let g=1;g<c.length;g++){const x=c[g-1];p+=`
        if (${u} < ${c[g]}  && ${u} >= ${c[g-1]}) {
          return getChannel(
            getT${g}(${Ls(l,u,x)}),
            vec2(${Ls(d,u,x)}));
        }`}const f=c.length,m=c[c.length-1];p+=`
        return getChannel(
          getT${f}(${Ls(l,u,m)}),
          vec2(${Ls(d,u,m)}));`,this.userCode=`
      float getValue(${l.map(g=>"int "+g)}) {
        ${p}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Ls(n,e,t){const s=n.indexOf(e);return n.map((i,a)=>a===s?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mo(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return We({inputs:{x:r.complexTensorInfos.imag},backend:t})}const wA={kernelName:o.Imag,backendName:"webgl",kernelFunc:Mo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(n,e,t){const s=n[0].dtype;if(s==="complex64"){const f=n.map(y=>ws({inputs:{input:y},backend:t})),m=n.map(y=>Mo({inputs:{input:y},backend:t})),g=jn(f,e,t),x=jn(m,e,t),b=Ut({inputs:{real:g,imag:x},backend:t});return f.forEach(y=>t.disposeIntermediateTensorInfo(y)),m.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),b}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const f=n.map(C=>{const S=[-1,o.sizeFromShape(C.shape.slice(e))];return G({inputs:{x:C},backend:t,attrs:{shape:S}})}),m=f.map(C=>({vals:t.readSync(C.dataId),shape:C.shape})),g=mt(f.map(C=>C.shape),1),x=f[0].shape[0]===1,b=u$(m,g,s,x),y=mt(n.map(C=>C.shape),e),w=t.makeTensorInfo(y,s,b);return f.forEach(C=>t.disposeIntermediateTensorInfo(C)),w}const i=n.filter(f=>o.sizeFromShape(f.shape)>0),a=o.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const f=a?new ft(n[0].shape,Et):new Lt(n[0].shape,Et);return t.runWebGLProgram(f,n,s)}const l=o.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>l){const f=[];for(let g=0;g<i.length;g+=l){const x=i.slice(g,g+l);f.push(jn(x,e,t))}const m=jn(f,e,t);for(const g of f)t.disposeIntermediateTensorInfo(g);return m}if(a){const f=new CA(i.map(m=>m.shape),e);return t.runWebGLProgram(f,i,s)}const{tensors2D:c,outShape:u}=vA(i,e,t),d=new yA(c.map(f=>f.shape)),h=t.runWebGLProgram(d,c,s);c.forEach(f=>t.disposeIntermediateTensorInfo(f));const p=G({inputs:{x:h},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(h),p}function vA(n,e,t){const s=mt(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>G({inputs:{x:i},attrs:{shape:[-1,o.sizeFromShape(i.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _p(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=o.parseAxisParam(r,e[0].shape)[0],a=e.map(u=>u.shape);Ir(a,i);const l=mt(e.map(u=>u.shape),i);if(o.sizeFromShape(l)===0)return t.makeTensorInfo(l,e[0].dtype,[]);const c=e.filter(u=>o.sizeFromShape(u.shape)>0);return c.length===1?We({inputs:{x:c[0]},backend:t}):jn(c,i,t)}const SA={kernelName:o.Concat,backendName:"webgl",kernelFunc:_p};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bp{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,l=e.padInfo.left,c=e.strideHeight,u=e.strideWidth,d=e.dilationHeight,h=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,x=e.dataFormat==="channelsLast",b=x?1:2,y=x?2:3,w=x?3:1;let C="",v="";s&&(r?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:C=`
          float activation(float x) {
            ${s}
          }
        `,v="result = activation(result);");const S=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${c}, ${u});
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${x}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${x}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${x}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${x}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${S}
        ${v}
        setOutput(result);
      }
    `}}class IA{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,a=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.filterDepth,p=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${l});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vp{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Fe(this.outputShape.length);const a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,h=d;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<d;x++)p+=`
           vec4 xTexelC${x*2};
           int xTexelC${x*2}Ready;
           vec4 xTexelC${x*2+1};
           int xTexelC${x*2+1}Ready;
           vec4 xC${x};`;p+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let x=0;x<d;x++)p+=`
           xTexelC${x*2} = vec4(0.0);
           xTexelC${x*2}Ready = 0;
           xTexelC${x*2+1} = vec4(0.0);
           xTexelC${x*2+1}Ready = 0;
           xC${x} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let x=0;x<(h+1)/2;x++){const b=x*2;if(p+=`
           xC = xCCorner + ${b*c};
           `,l===1){if(b<d&&(a%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,c===1&&b>0?p+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<d)){const y=a%2===0?o.nearestLargerEven(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,c>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:p+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):y===1?p+=`
                     xC${b+1} = xTexelC${b};
                     `:p+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<d&&(a%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<d&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<d&&(p+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<d&&(p+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<d&&(p+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let f="",m="";s&&(r?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:f=`vec4 activation(vec4 x) {
           ${s}
         }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${m}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kA{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Fe(this.outputShape.length);const{dataFormat:s}=t,r=Pe(),i=s==="channelsLast",a=i?1:2,l=i?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let d=0;d<=1;d++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${d};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${l}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oo(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function Wp({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape,u=s.texData.get(n.dataId),d=t.inChannels,h=c[0]*c[1]*c[2],p=t.outChannels,f=t.dataFormat==="channelsLast",m=!1,g=!1;let x;const b=[];if(i!=null){const C=oo(i.shape,f);C!=null&&(i=G({inputs:{x:i},backend:s,attrs:{shape:C}}),b.push(i))}if(r!=null){const C=oo(r.shape,f);C!=null&&(r=G({inputs:{x:r},backend:s,attrs:{shape:C}}),b.push(r))}if(!((h===1||p===1)&&d>Op)&&u.isPacked&&f&&u.texture!=null&&c[2]%2!==0&&o.arraysEqual(u.shape.slice(-3),c.slice(-3))){const C=c[0]*c[1]*(c[2]+1),v={dataId:n.dataId,shape:[1,C,t.inChannels],dtype:n.dtype},S=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,o.assert(es(u.shape,v.shape),()=>`packed reshape ${u.shape} to ${v.shape} isn't free`);const I=G({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});b.push(I);const k=so({a:v,b:I,backend:s,transposeA:m,transposeB:g,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:a}),$=s.texData.get(k.dataId);o.assert($.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=S,$.shape=t.outShape,x=We({inputs:{x:k},backend:s}),x.shape=t.outShape,b.push(k)}else{const C=t.outHeight*t.outWidth,v=G({inputs:{x:n},backend:s,attrs:{shape:f?[t.batchSize,C,t.inChannels]:[t.batchSize,t.inChannels,C]}}),S=G({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),I=so({a:f?v:S,b:f?S:v,transposeA:!f,transposeB:g,backend:s,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:a});x=G({inputs:{x:I},backend:s,attrs:{shape:t.outShape}}),b.push(v),b.push(S),b.push(I)}for(const C of b)s.disposeIntermediateTensorInfo(C);return x}function Gp({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const{filterWidth:c,filterHeight:u,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=t,m=f==="channelsLast",g=c*u*d,x=p*h,b=[t.batchSize,g,x],y=!0,w=!1,C=[];if(i!=null){const D=oo(i.shape,m);D!=null&&(i=G({inputs:{x:i},backend:s,attrs:{shape:D}}),C.push(i))}if(r!=null){const D=oo(r.shape,m);D!=null&&(r=G({inputs:{x:r},backend:s,attrs:{shape:D}}),C.push(r))}const v=G({inputs:{x:e},backend:s,attrs:{shape:[1,g,o.sizeFromShape(e.shape)/g]}});C.push(v);const S=new kA(b,t),I=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],k=s.runWebGLProgram(S,[n],"float32",I),$=G({inputs:{x:k},backend:s,attrs:{shape:b}});C.push(k),C.push($);const N=r!=null,R=i!=null,F=l==="leakyrelu",O=l?ts(l,!0):null,L=new Fp(m?$.shape:v.shape,m?v.shape:$.shape,m?[t.batchSize,x,t.outChannels]:[t.batchSize,t.outChannels,x],y,w,N,O,R,F),A=m?[$,v]:[v,$];if(r&&A.push(r),R&&A.push(i),F){const D=s.makeTensorInfo([],"float32",o.createScalarValue(a,"float32"));A.push(D),C.push(D)}const E=s.runWebGLProgram(L,A,"float32"),P=G({inputs:{x:E},backend:s,attrs:{shape:t.outShape}});C.push(E);for(const D of C)s.disposeIntermediateTensorInfo(D);return P}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:l,dataFormat:c,dilations:u,dimRoundingMode:d}=s,h=o.convertConv2DDataFormat(c),p=o.computeConv2DInfo(r.shape,i.shape,a,u,l,d,!1,h);let f;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))f=Wp({x:r,filter:i,convInfo:p,backend:t});else if(p.strideWidth<=2&&h==="channelsLast"&&o.env().getBool("WEBGL_EXP_CONV")){const g=new Vp(p),x=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];f=t.runWebGLProgram(g,[r,i],"float32",x)}else if(o.env().getBool("WEBGL_CONV_IM2COL"))f=Gp({x:r,filter:i,convInfo:p,backend:t});else{const g=new Bp(p);f=t.runWebGLProgram(g,[r,i],"float32")}const m=G({inputs:{x:f},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(f),m}const $A={kernelName:o.Conv2D,backendName:"webgl",kernelFunc:TA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class RA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dataFormat==="channelsLast",l=t-1-e.padInfo.top,c=s-1-e.padInfo.left,u=a?1:2,d=a?2:3,h=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class AA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,a=e.padInfo.top,l=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${l};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class DA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,l=e.strideWidth,c=t-1-e.padInfo.front,u=s-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${u}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:l,dataFormat:c,dimRoundingMode:u,filterShape:d}=s,h=o.convertConv2DDataFormat(c),p=o.computeConv2DInfo(r.shape,d,a,1,l,u,!1,h),f=new NA(p);return t.runWebGLProgram(f,[r,i],"float32")}const FA={kernelName:o.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:EA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OA{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Fe(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LA(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:l,pad:c,dataFormat:u,dimRoundingMode:d}=s,h=o.convertConv2DDataFormat(u),p=o.computeConv2DInfo(a,i.shape,l,1,c,d,!1,h);if(o.env().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const f=[[p.strideHeight,p.strideWidth]],m=new OA(p);return t.runWebGLProgram(m,[r,i],"float32",f)}else{const f=new RA(p);return t.runWebGLProgram(f,[r,i],"float32")}}const PA={kernelName:o.Conv2DBackpropInput,backendName:"webgl",kernelFunc:LA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:l,dilations:c}=s,u=o.computeConv3DInfo(r.shape,i.shape,a,c,l),d=new IA(u);return t.runWebGLProgram(d,[r,i],"float32")}const zA={kernelName:o.Conv3D,backendName:"webgl",kernelFunc:MA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _A(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:l,filterShape:c}=s,u=o.computeConv3DInfo(r.shape,c,a,1,l),d=new AA(u);return t.runWebGLProgram(d,[r,i],"float32")}const BA={kernelName:o.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:_A};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VA(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:l,inputShape:c}=s,u=o.computeConv3DInfo(c,i.shape,l,1,a),d=new DA(u);return t.runWebGLProgram(d,[r,i],"float32")}const WA={kernelName:o.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:VA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GA=Pn+`
  return cos(x);
`,UA=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${hn}
  return result;
`,HA=se({opSnippet:GA,packedOpSnippet:UA}),qA={kernelName:o.Cos,backendName:"webgl",kernelFunc:HA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XA=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,jA=se({opSnippet:XA}),KA={kernelName:o.Cosh,backendName:"webgl",kernelFunc:jA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YA{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,l,c,u]=e,[d]=t,[h,p]=s;this.outputShape=[d,h,p,u];const f=r==="bilinear"?1:0,[m,g]=[`${l-1}.0`,`${c-1}.0`],[x,b,y]=h>1?[`${(l-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[w,C,v]=p>1?[`${(c-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${x});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${C};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZA=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:l,method:c,extrapolationValue:u}=s,d=new YA(r.shape,i.shape,l,c,u);return t.runWebGLProgram(d,[r,i,a],"float32")},QA={kernelName:o.CropAndResize,backendName:"webgl",kernelFunc:ZA};var ss;(function(n){n.Prod="*",n.Sum="+"})(ss||(ss={}));class ql{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=this.op===ss.Prod?"1.0":"0.0",l=s?a:`getX(${Xl(i,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let u="",d="";s?(u=r?`end != ${c-1}`:"end != 0",d=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${c}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ce(i)} coords = getOutputCoords();
        int end = ${jl(i,"coords",this.op)};
        float val = ${l};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${d};
          ${jl(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${Xl(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Xl(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function jl(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Up(n,e,t,s,r,i){const a=e.shape.length,l=o.getAxesPermutation([s],a);let c=e;l!=null&&(c=Le({inputs:{x:e},backend:t,attrs:{perm:l}}));const u=o.getInnerMostAxes(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=c.shape[u];let h=We({inputs:{x:c},backend:t});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const f=new ql(n,c.shape,!1,i),m=[[p]],g=h;h=t.runWebGLProgram(f,[h],h.dtype,m),t.disposeIntermediateTensorInfo(g)}if(r){const p=new ql(n,c.shape,r,i),f=h;h=t.runWebGLProgram(p,[h],h.dtype),t.disposeIntermediateTensorInfo(f)}if(l!=null){const p=o.getUndoAxesPermutation(l),f=Le({inputs:{x:h},backend:t,attrs:{perm:p}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(c),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:l}=s;return Up(ss.Prod,r,t,i,a,l)}const e2={kernelName:o.Cumprod,backendName:"webgl",kernelFunc:JA};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:l}=s;return Up(ss.Sum,r,t,i,a,l)}const n2={kernelName:o.Cumsum,backendName:"webgl",kernelFunc:t2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:l}=s;if(r.shape.length===1){const c=t.readSync(r.dataId),u=t.readSync(i.dataId),d=vp(c,u,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const c=t.bufferSync(r),u=t.bufferSync(i),d=i$(c,u,a,l);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const o2={kernelName:o.DenseBincount,backendName:"webgl",kernelFunc:s2};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r2{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s,l=r.shape[0],c=a==="NHWC"?r.shape[1]:r.shape[2],u=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],h=c*i,p=u*i,f=d/(i*i),m=a==="NHWC"?[l,h,p,f]:[l,f,h,p],g=new r2(m,i,a);return t.runWebGLProgram(g,[r],r.dtype)}const a2={kernelName:o.DepthToSpace,backendName:"webgl",kernelFunc:i2};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hp{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Fe(this.outputShape.length);const a=e.filterHeight,l=e.filterWidth,c=e.outChannels/e.inChannels;let u="",d="";s&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:u=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${l}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qp{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Fe(this.outputShape.length);const a=e.outChannels/e.inChannels,l=e.padInfo.left,c=e.strideWidth,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=h;let f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<h;b++)f+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;f+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let b=0;b<h;b++)f+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(p+1)/2;b++){const y=b*2;if(f+=`
          xC = xCCorner + ${y*u};
          `,c===1){if(y<h&&(l%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,u===1&&y>0?f+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<h)){const w=l%2===0?o.nearestLargerEven(u):u;u%2===0&&l%2===1||u%2!==0&&l%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,u>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:f+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):w===1?f+=`
                    xC${y+1} = xTexelC${y};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<h&&(l%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<h&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<h&&(f+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<h&&(f+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<h&&(f+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let m="",g="";s&&(r?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:m=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${x}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:l,dilations:c,dimRoundingMode:u}=s;let d=c;d==null&&(d=[1,1]),o.assert(o.eitherStridesOrDilationsAreOne(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const h=o.computeConv2DInfo(r.shape,i.shape,a,d,l,u,!0);let p;o.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?p=new qp(h):p=new Hp(h);const f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(p,[r,i],"float32",f)}const c2={kernelName:o.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:l2};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u2{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class d2{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:l,pad:c,dimRoundingMode:u,filterShape:d}=s,h=o.computeConv2DInfo(r.shape,d,a,l,c,u,!0),p=new u2(h);return t.runWebGLProgram(p,[r,i],"float32")}const p2={kernelName:o.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:h2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f2(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:l,pad:c,dimRoundingMode:u,inputShape:d}=s,h=o.computeConv2DInfo(d,i.shape,a,l,c,u,!0),p=new d2(h);return t.runWebGLProgram(p,[r,i],"float32")}const m2={kernelName:o.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:f2};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g2{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=o.sizeFromShape(s.shape),a=G({inputs:{x:s},backend:t,attrs:{shape:[i]}}),l=new g2(i),c=t.runWebGLProgram(l,[a],a.dtype),u=G({inputs:{x:c},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),u}const b2={kernelName:o.Diag,backendName:"webgl",kernelFunc:x2};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y2{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:a,filterHeight:l,filterWidth:c,dilationHeight:u,dilationWidth:d}=e,{top:h,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${h}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${l}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:l,dilations:c}=s,u=o.computeDilation2DInfo(r.shape,i.shape,a,l,"NHWC",c);let d;const h=new y2(u);d=t.runWebGLProgram(h,[r,i],"float32");const p=G({inputs:{x:d},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(d),p}const w2={kernelName:o.Dilation2D,backendName:"webgl",kernelFunc:C2};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:l,idDims:c}=Pr(r,i.length);zr(a.length,c,i);const{path:u,steps:d}=_r(l,c),h=d.length;let p=null,f=a.length;const m=[];for(let g=0;g<h;++g){for(const x of d[g]){const{permutationIndices:b,expandDims:y}=Mr(f,c[x]);let w;Br(b)?w=i[x]:(w=Le({inputs:{x:i[x]},backend:t,attrs:{perm:b}}),m.push(w));const C=w.shape.slice();for(let v=0;v<y.length;++v)C.splice(y[v],0,1);o.arraysEqual(w.shape,C)||(w=G({inputs:{x:w},backend:t,attrs:{shape:C}}),m.push(w)),p===null?p=w:(p=Wa({inputs:{a:w,b:p},backend:t}),m.push(p))}g<h-1&&(u[g]>=0&&(p=Po({inputs:{x:p},backend:t,attrs:{axis:u[g]-(a.length-f),keepDims:!1}}),m.push(p)),f--)}for(const g of m)g!==p&&t.disposeIntermediateTensorInfo(g);return p}const S2={kernelName:o.Einsum,backendName:"webgl",kernelFunc:v2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I2="return (x >= 0.0) ? x : (exp(x) - 1.0);",k2=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,T2=se({opSnippet:I2,packedOpSnippet:k2}),$2={kernelName:o.Elu,backendName:"webgl",kernelFunc:T2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N2="return (b >= 0.0) ? a : a * (b + 1.0);",R2=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,A2=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=o.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ln(R2,s.shape,r.shape):new rn(N2,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},D2={kernelName:o.EluGrad,backendName:"webgl",kernelFunc:A2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E2=`
  return vec4(equal(a, b));
`,F2="return float(a == b);",O2=De({opSnippet:F2,packedOpSnippet:E2,dtype:"bool",cpuKernelImpl:d$}),L2={kernelName:o.Equal,backendName:"webgl",kernelFunc:O2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P2=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Rr};
  float a1 = ${Ar};
  float a2 = ${Dr};
  float a3 = ${Er};
  float a4 = ${Fr};
  float a5 = ${Or};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,M2=se({opSnippet:P2}),z2={kernelName:o.Erf,backendName:"webgl",kernelFunc:M2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2=Pn+`
  return exp(x);
`,B2=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Xp=se({opSnippet:_2,packedOpSnippet:B2,cpuKernelImpl:h$,dtype:"float32"}),V2={kernelName:o.Exp,backendName:"webgl",kernelFunc:Xp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mr(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,a=i.shape.length,l=i.shape.slice();let c=r;return r<0&&(o.assert(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),c=a+r+1),l.splice(c,0,1),G({inputs:{x:i},backend:s,attrs:{shape:l}})}const W2={kernelName:o.ExpandDims,backendName:"webgl",kernelFunc:mr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kl="return exp(x) - 1.0;",G2=se({opSnippet:Kl,packedOpSnippet:Kl,cpuKernelImpl:p$}),U2={kernelName:o.Expm1,backendName:"webgl",kernelFunc:G2};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yl{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let l;if(e==="real")l="return real * expR - imag * expI;";else if(e==="imag")l="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${l}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jp(n,e,t){const s=t.texData.get(n.dataId),r=o.sizeFromShape(n.shape),i=n.shape[n.shape.length-1],a=r/i,l=G({inputs:{x:n},backend:t,attrs:{shape:[a,i]}}),c=l.shape,u=new Yl("real",c,e),d=new Yl("imag",c,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],p=t.runWebGLProgram(u,h,"float32"),f=t.runWebGLProgram(d,h,"float32"),m=Ut({inputs:{real:p,imag:f},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f);const g=G({inputs:{x:m},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(m),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2(n){const{inputs:e,backend:t}=n,{input:s}=e;return jp(s,!1,t)}const q2={kernelName:o.FFT,backendName:"webgl",kernelFunc:H2};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X2{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vs(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||o.inferDtype(r),i==="string"){const a=o.getArrayFromDType(i,o.sizeFromShape(s));return a.fill(r),e.makeTensorInfo(s,i,a)}else{const a=new X2(s,r),l=[[r]];return e.runWebGLProgram(a,[],i,l)}}const j2={kernelName:o.Fill,backendName:"webgl",kernelFunc:vs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K2{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y2={kernelName:o.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new K2(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zl="return floor(x);",Z2=se({opSnippet:Zl,packedOpSnippet:Zl,cpuKernelImpl:f$}),Q2={kernelName:o.Floor,backendName:"webgl",kernelFunc:Z2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J2=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,eD=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,tD=De({opSnippet:J2,packedOpSnippet:eD,dtype:"int32"}),nD={kernelName:o.FloorDiv,backendName:"webgl",kernelFunc:tD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sD{constructor(e){this.variableNames=["A"];const t=Pe(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oD{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Pe(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rD={kernelName:o.FromPixels,backendName:"webgl",kernelFunc:iD};let mn,jo=o.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function iD(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[c,u]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[u,c],h=[u,c,i];if(l||a){const g=o.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(mn==null||g!==jo)&&(jo=g,mn=document.createElement("canvas").getContext("2d",{willReadFrequently:jo})),mn.canvas.width=c,mn.canvas.height=u,mn.drawImage(r,0,0,c,u),r=mn.canvas}const p=t.makeTensorInfo(d,"int32");t.texData.get(p.dataId).usage=He.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),r);const f=o.env().getBool("WEBGL_PACK")?new oD(h):new sD(h),m=t.runWebGLProgram(f,[p],"int32");return t.disposeData(p.dataId),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:l}=e,{strides:c,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s,g=o.convertConv2DDataFormat(d),x=o.computeConv2DInfo(r.shape,i.shape,c,h,u,p,!1,g);let b;const y=[],w=a!=null,C=l!=null,v=f==="leakyrelu",S=()=>{const k=[r,i],$=(N,R)=>{if(R==="NCHW"&&N.shape.length===1&&N.shape[0]!==1){const F=G({inputs:{x:N},backend:t,attrs:{shape:[N.shape[0],1,1]}});return y.push(F),F}return N};if(w&&k.push($(a,d)),C&&k.push($(l,d)),v){const N=t.makeTensorInfo([],"float32",o.createScalarValue(m,"float32"));k.push(N),y.push(N)}return k};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))b=Wp({x:r,filter:i,convInfo:x,backend:t,bias:a,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else if(x.strideWidth<=2&&g==="channelsLast"&&o.env().getBool("WEBGL_EXP_CONV")){const k=f?ts(f,!0):null,$=new Vp(x,w,k,C,v),N=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],R=S();b=t.runWebGLProgram($,R,"float32",N)}else if(o.env().getBool("WEBGL_CONV_IM2COL"))b=Gp({x:r,filter:i,convInfo:x,backend:t,bias:a,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{const k=f?ts(f,!1):null,$=new Bp(x,w,k,C,v),N=S();b=t.runWebGLProgram($,N,"float32")}const I=G({inputs:{x:b},backend:t,attrs:{shape:x.outShape}});return y.push(b),y.forEach(k=>t.disposeIntermediateTensorInfo(k)),I}const lD={kernelName:o.FusedConv2D,backendName:"webgl",kernelFunc:aD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:l}=e,{strides:c,pad:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s,m=[];let g=d;g==null&&(g=[1,1]),o.assert(o.eitherStridesOrDilationsAreOne(c,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${g}'`);const x=o.computeConv2DInfo(r.shape,i.shape,c,g,u,h,!0),b=o.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels===1,y=p?ts(p,b):null,w=[r,i],C=a!=null,v=l!=null,S=p==="leakyrelu";if(C&&w.push(a),v&&w.push(l),S){const N=t.makeTensorInfo([],"float32",o.createScalarValue(f,"float32"));w.push(N),m.push(N)}let I;b?I=new qp(x,C,y,v,S):I=new Hp(x,C,y,v,S);const k=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],$=t.runWebGLProgram(I,w,"float32",k);return m.forEach(N=>t.disposeIntermediateTensorInfo(N)),$}const uD={kernelName:o.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:cD};class dD{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=ce(s.length);let a=`
    int index;`;for(let l=0;l<this.sliceDim;l++)a+=`
          index = round(getIndices(coords[0], ${l}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[l]};
          flattenIndex += index * ${this.strides[l]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,a=i[i.length-1],l=o.sizeFromShape(s.shape),[c,u,d,h]=io(s,r),p=G({inputs:{x:r},backend:t,attrs:{shape:[u,a]}}),f=G({inputs:{x:s},backend:t,attrs:{shape:[o.sizeFromShape(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const b=t.readSync(r.dataId),y=t.bufferSync(s),w=m$(b,y,s.dtype,u,a,d,h,s.shape,l);return t.makeTensorInfo(c,s.dtype,w.values)}const m=new dD(a,h,[u,d],s.shape),g=t.runWebGLProgram(m,[f,p],f.dtype),x=G({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),x}const pD={kernelName:o.GatherNd,backendName:"webgl",kernelFunc:hD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fD{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=ce(this.rank),r=mD(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function mD(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kp(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:l}=s,c=o.parseAxisParam(a,r.shape)[0];if(o.env().get("DEBUG")){const y=t.readSync(i.dataId),w=r.shape[c];for(let C=0;C<y.length;++C){const v=y[C];o.assert(v<=w-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${w-1}]`)}}const u=Wr(r,i,c,l),d=o.sizeFromShape(i.shape),h=[],p=G({inputs:{x:r},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=G({inputs:{x:i},backend:t,attrs:{shape:[u.batchSize,d/u.batchSize]}});h.push(p),h.push(f);const m=[u.batchSize,u.outerSize,d/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const y=t.bufferSync(f),w=t.bufferSync(p),C=g$(w,y,m);return h.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(u.outputShape,C.dtype,C.values)}const g=new fD(p.shape,m),x=t.runWebGLProgram(g,[p,f],p.dtype);h.push(x);const b=G({inputs:{x},backend:t,attrs:{shape:u.outputShape}});return h.forEach(y=>t.disposeIntermediateTensorInfo(y)),b}const gD={kernelName:o.GatherV2,backendName:"webgl",kernelFunc:Kp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xD="return float(a > b);",bD=`
  return vec4(greaterThan(a, b));
`,yD=De({opSnippet:xD,packedOpSnippet:bD,cpuKernelImpl:x$,dtype:"bool"}),CD={kernelName:o.Greater,backendName:"webgl",kernelFunc:yD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wD="return float(a >= b);",vD=`
  return vec4(greaterThanEqual(a, b));
`,SD=De({opSnippet:wD,packedOpSnippet:vD,dtype:"bool",cpuKernelImpl:b$}),ID={kernelName:o.GreaterEqual,backendName:"webgl",kernelFunc:SD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kD(n){const{inputs:e,backend:t}=n,{input:s}=e;return jp(s,!0,t)}const TD={kernelName:o.IFFT,backendName:"webgl",kernelFunc:kD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $D="return float(!isnan(x) && !isinf(x));",ND=se({opSnippet:$D,dtype:"bool"}),RD={kernelName:o.IsFinite,backendName:"webgl",kernelFunc:ND};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AD="return float(isinf(x));",DD=se({opSnippet:AD,dtype:"bool"}),ED={kernelName:o.IsInf,backendName:"webgl",kernelFunc:DD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FD="return float(isnan(x));",OD=se({opSnippet:FD,dtype:"bool"}),LD={kernelName:o.IsNan,backendName:"webgl",kernelFunc:OD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PD="return float(a < b);",MD=`
  return vec4(lessThan(a, b));
`,zD=De({opSnippet:PD,packedOpSnippet:MD,cpuKernelImpl:y$,dtype:"bool"}),_D={kernelName:o.Less,backendName:"webgl",kernelFunc:zD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BD="return float(a <= b);",VD=`
  return vec4(lessThanEqual(a, b));
`,WD=De({opSnippet:BD,packedOpSnippet:VD,cpuKernelImpl:C$,dtype:"bool"}),GD={kernelName:o.LessEqual,backendName:"webgl",kernelFunc:WD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UD(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=w$(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const HD={kernelName:o.LinSpace,backendName:"webgl",kernelFunc:UD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qD=Pn+`
  return x < 0.0 ? 0./0. : log(x);
`,XD=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,jD=se({opSnippet:qD,packedOpSnippet:XD,cpuKernelImpl:v$}),KD={kernelName:o.Log,backendName:"webgl",kernelFunc:jD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YD=Pn+`
  return log(1.0 + x);
`,ZD=se({opSnippet:YD}),QD={kernelName:o.Log1p,backendName:"webgl",kernelFunc:ZD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JD="return float(a >= 1.0 && b >= 1.0);",eE=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,tE=De({opSnippet:JD,packedOpSnippet:eE,dtype:"bool"}),nE={kernelName:o.LogicalAnd,backendName:"webgl",kernelFunc:tE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sE="return float(!(x >= 1.0));",oE=se({opSnippet:sE}),rE={kernelName:o.LogicalNot,backendName:"webgl",kernelFunc:oE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iE="return float(a >= 1.0 || b >= 1.0);",aE=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,lE=De({opSnippet:iE,packedOpSnippet:aE,dtype:"bool"}),cE={kernelName:o.LogicalOr,backendName:"webgl",kernelFunc:lE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uE{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const a=t,l=e[3]-1;this.outputShape=e;let c;const u=`float(${s}) + float(${r}) * sum`;i===.5?c=`inversesqrt(${u})`:i===1?c=`1.0/(${u})`:c=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${l}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dE{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,l=e[3]-1;this.outputShape=e;let c;const u=`float(${s}) + float(${r}) * sum`;i===.5?c=`inversesqrt(${u})`:i===1?c=`1.0/(${u})`:c=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hE=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:l,beta:c}=s,u=o.env().getBool("WEBGL_PACK_NORMALIZATION")?new dE(r.shape,i,a,l,c):new uE(r.shape,i,a,l,c);return t.runWebGLProgram(u,[r],r.dtype)},pE={kernelName:o.LRN,backendName:"webgl",kernelFunc:hE};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fE{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mE=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:l,bias:c,alpha:u,beta:d}=s,h=new fE(r.shape,l,c,u,d);return t.runWebGLProgram(h,[r,i,a],r.dtype)},gE={kernelName:o.LRNGrad,backendName:"webgl",kernelFunc:mE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xE(n,e,t,s){const r=o.sizeFromShape(e),a=o.sizeFromShape(n.shape)/r,l=G({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),c=pn(l,n.dtype,"max",s),u=G({inputs:{x:c},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yp(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,l=r.shape.length,c=o.parseAxisParam(i,r.shape);let u=c;const d=o.getAxesPermutation(u,l),h=d!=null,p=t.shouldExecuteOnCPU([r]);let f=r;if(h){if(p){const w=t.texData.get(f.dataId).values,C=new Array(l);for(let I=0;I<C.length;I++)C[I]=r.shape[d[I]];const v=Ba(w,r.shape,r.dtype,d,C);f=t.makeTensorInfo(C,r.dtype);const S=t.texData.get(f.dataId);S.values=v}else f=Lo(r,d,t);u=o.getInnerMostAxes(u.length,l)}o.assertAxesAreInnerMostDims("max",u,l);const[m,g]=o.computeOutAndReduceShapes(f.shape,u);let x=m;a&&(x=o.expandShapeToKeepDim(m,c));let b;if(p){const w=t.texData.get(f.dataId).values,C=S$(w,o.sizeFromShape(g),x,r.dtype);b=t.makeTensorInfo(x,r.dtype);const v=t.texData.get(b.dataId);v.values=C}else b=xE(f,g,x,t);return h&&t.disposeIntermediateTensorInfo(f),b}const bE={kernelName:o.Max,backendName:"webgl",kernelFunc:Yp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yE=Va+`
  return max(a, b);
`,CE=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+hn+`
  return result;
`,wE=De({opSnippet:yE,packedOpSnippet:CE,cpuKernelImpl:I$}),vE={kernelName:o.Maximum,backendName:"webgl",kernelFunc:wE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;An(r,"maxPool");const{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=s,u=1;o.assert(o.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const d=o.computePool2DInfo(r.shape,i,a,u,l,c);if(d.filterWidth===1&&d.filterHeight===1&&o.arraysEqual(d.inShape,d.outShape))return We({inputs:{x:r},backend:t});const h=new ns(d,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const IE={kernelName:o.MaxPool,backendName:"webgl",kernelFunc:SE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kE(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s,d=[1,1,1],h=o.computePool3DInfo(r.shape,i,a,d,l,u,c),p=new Ga(h,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const TE={kernelName:o.MaxPool3D,backendName:"webgl",kernelFunc:kE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $E{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,a=e.effectiveFilterWidth,l=i-1-e.padInfo.top,c=a-1-e.padInfo.left,u=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class NE{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=c-1-e.padInfo.front,p=u-1-e.padInfo.top,f=d-1-e.padInfo.left,m=c*u*d-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${p}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RE(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=s,h=[1,1,1],p=o.computePool3DInfo(a.shape,l,c,h,u,d),f=new Ga(p,"max",!0),m=t.runWebGLProgram(f,[a],a.dtype),g=new NE(p),x=t.runWebGLProgram(g,[r,m],a.dtype);return t.disposeIntermediateTensorInfo(m),x}const AE={kernelName:o.MaxPool3DGrad,backendName:"webgl",kernelFunc:RE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DE(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,l=i;An([i,a],"maxPoolGrad");const{filterSize:c,strides:u,pad:d,dimRoundingMode:h}=s,p=o.computePool2DInfo(l.shape,c,u,1,d,h),f=!0,m=new ns(p,"max",f),g=t.runWebGLProgram(m,[l],l.dtype),x=new $E(p),b=t.runWebGLProgram(x,[r,g],l.dtype);return t.disposeIntermediateTensorInfo(g),b}const EE={kernelName:o.MaxPoolGrad,backendName:"webgl",kernelFunc:DE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FE(n,e,t,s){let r=new ns(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new ns(t,"max",!0,!0,e);const a=s.runWebGLProgram(r,[n],"float32");return[i,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OE={kernelName:o.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:l}=e,c=t;o.assert(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];o.assert(o.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const d=o.computePool2DInfo(s.shape,r,i,u,a),[h,p]=FE(s,l,d,c);return[h,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LE(n,e,t,s){const r=o.sizeFromShape(e),a=o.sizeFromShape(n.shape)/r,l=G({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),c=pn(l,"float32","mean",s),u=G({inputs:{x:c},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PE={kernelName:o.Mean,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,a=t,l=s.shape.length,c=o.parseAxisParam(i,s.shape);let u=c;const d=o.getAxesPermutation(u,l),h=d!=null,p=a.shouldExecuteOnCPU([s]),f=[];let m=s;if(h){if(p){const C=a.texData.get(m.dataId).values,v=new Array(l);for(let k=0;k<v.length;k++)v[k]=s.shape[d[k]];const S=Ba(C,s.shape,s.dtype,d,v);m=a.makeTensorInfo(v,s.dtype);const I=a.texData.get(m.dataId);I.values=S}else m=Lo(s,d,a);f.push(m),u=o.getInnerMostAxes(u.length,l)}o.assertAxesAreInnerMostDims("sum",u,l);const[g,x]=o.computeOutAndReduceShapes(m.shape,u);let b=g;r&&(b=o.expandShapeToKeepDim(g,c));const y=LE(m,x,b,a);for(const w of f)a.disposeIntermediateTensorInfo(w);return y}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ME(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,l=r.shape.length,c=o.parseAxisParam(i,r.shape);let u=c;const d=o.getAxesPermutation(u,l);let h=r;d!=null&&(h=Le({inputs:{x:r},backend:t,attrs:{perm:d}}),u=o.getInnerMostAxes(u.length,r.shape.length)),o.assertAxesAreInnerMostDims("min",u,l);const[p,f]=o.computeOutAndReduceShapes(h.shape,u),m=o.sizeFromShape(f),g=G({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),x=pn(g,g.dtype,"min",t);let b;if(a){const y=o.expandShapeToKeepDim(p,c);b=G({inputs:{x},backend:t,attrs:{shape:y}})}else b=G({inputs:{x},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),d!=null&&t.disposeIntermediateTensorInfo(h),b}const zE={kernelName:o.Min,backendName:"webgl",kernelFunc:ME};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _E=Va+`
  return min(a, b);
`,BE=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+hn+`
  return result;
`,VE=De({opSnippet:_E,packedOpSnippet:BE,cpuKernelImpl:k$}),WE={kernelName:o.Minimum,backendName:"webgl",kernelFunc:VE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GE{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((d,h)=>d[0]+e[h]+d[1]);const r=e.length,i=ce(r),a=t.map(d=>d[0]).join(","),l=t.map((d,h)=>d[0]+e[h]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UE{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const r=e.length,i=ce(r),a=t.map(m=>m[0]).join(","),l=t.map((m,g)=>m[0]+e[g]).join(","),c=Oe("rc",r),u=Oe("source",r),d=`${c[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,p=s==="reflect"?0:1;let f="";if(r===1){const m=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;f=`
        ${i} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${c[r-1]} += 1;
        if(${d}) {
          ${m}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const m=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;f=`
        ${i} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${c[r-1]} += 1;
        if(${d}) {
          ${m}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${c[r-2]} += 1;
        if(${c[r-2]} < ${this.outputShape[r-2]}) {
          ${m}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${c[r-1]} += 1;
          if(${d}) {
            ${m}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,a=o.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UE(s.shape,r,i):new GE(s.shape,r,i);return e.runWebGLProgram(a,[s],s.dtype)},qE={kernelName:o.MirrorPad,backendName:"webgl",kernelFunc:HE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XE=`if (b == 0.0) return NAN;
  return mod(a, b);`,jE=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+hn+`
  return result;
`,KE=De({opSnippet:XE,packedOpSnippet:jE}),YE={kernelName:o.Mod,backendName:"webgl",kernelFunc:KE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZE{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QE=`
if (a == b) {
  return 1.0;
};
return a / b;`,JE=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Zp=De({opSnippet:QE,packedOpSnippet:JE,checkOutOfBounds:!0}),eF={kernelName:o.RealDiv,backendName:"webgl",kernelFunc:Zp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ql="return a - b;",Qp=De({opSnippet:Ql,packedOpSnippet:Ql,supportsComplex:!0,cpuKernelImpl:q$}),tF={kernelName:o.Sub,backendName:"webgl",kernelFunc:Qp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jp(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=o.parseAxisParam([i],r.shape),l=Yp({inputs:{x:r},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),c=o.expandShapeToKeepDim(l.shape,a),u=G({inputs:{x:l},backend:t,attrs:{shape:c}}),d=Qp({inputs:{a:r,b:u},backend:t}),h=Xp({inputs:{x:d},backend:t}),p=Po({inputs:{x:h},backend:t,attrs:{axis:a,keepDims:!1}}),f=G({inputs:{x:p},backend:t,attrs:{shape:c}}),m=Zp({inputs:{a:h,b:f},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),m}const nF={kernelName:o.Softmax,backendName:"webgl",kernelFunc:Jp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:l}=s,c=l?r:Jp({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),u=c.shape[0],d=c.shape[1],h=new ZE(u,d,i),p=[[a]],f=t.runWebGLProgram(h,[c],"int32",p);return l||t.disposeIntermediateTensorInfo(c),f}const oF={kernelName:o.Multinomial,backendName:"webgl",kernelFunc:sF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rF=Qe+`
  return -x;
`,iF=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function aF(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[a,l]=$$(i.values,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,a)}let r;return o.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Lt(s.shape,iF):r=new ft(s.shape,rF),t.runWebGLProgram(r,[s],s.dtype)}const lF={kernelName:o.Neg,backendName:"webgl",kernelFunc:aF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF=o.nonMaxSuppressionV3Impl;function uF(n){o.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=s,u=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:h}=cF(u,d,a,l,c);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const dF={kernelName:o.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:uF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hF=o.nonMaxSuppressionV4Impl;function pF(n){o.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:u}=s,d=t.readSync(r.dataId),h=t.readSync(i.dataId),{selectedIndices:p,validOutputs:f}=hF(d,h,a,l,c,u);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}const fF={kernelName:o.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:pF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mF=o.nonMaxSuppressionV5Impl;function gF(n){o.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=s,d=t.readSync(r.dataId),h=t.readSync(i.dataId),p=a,f=l,m=c,g=u,{selectedIndices:x,selectedScores:b}=mF(d,h,p,f,m,g);return[t.makeTensorInfo([x.length],"int32",new Int32Array(x)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const xF={kernelName:o.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:gF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bF{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yF=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:l,offValue:c}=s,u=o.sizeFromShape(r.shape),d=new bF(u,a,l,c),h=G({inputs:{x:r},backend:t,attrs:{shape:[u]}}),p=t.runWebGLProgram(d,[h],i);t.disposeIntermediateTensorInfo(h);const f=[...r.shape,a],m=G({inputs:{x:p},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(p),m},CF={kernelName:o.OneHot,backendName:"webgl",kernelFunc:yF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ro(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=ws({inputs:{input:s},backend:t}),i=ro({inputs:{x:r},backend:t}),a=Mo({inputs:{input:s},backend:t}),l=ro({inputs:{x:a},backend:t}),c=Ut({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}else return vs({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const wF={kernelName:o.ZerosLike,backendName:"webgl",kernelFunc:ro};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ef(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=ws({inputs:{input:s},backend:t}),i=ef({inputs:{x:r},backend:t}),a=Mo({inputs:{input:s},backend:t}),l=ro({inputs:{x:a},backend:t}),c=Ut({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}else return vs({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const vF={kernelName:o.OnesLike,backendName:"webgl",kernelFunc:ef};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return mr({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{o.assertShapesMatch(i,d.shape,"All tensors passed to stack must have matching shapes"),o.assert(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=e.map(d=>{const h=mr({inputs:{input:d},backend:t,attrs:{dim:r}});return l.push(h),h}),u=_p({inputs:c,backend:t,attrs:{axis:r}});return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),u}const IF={kernelName:o.Pack,backendName:"webgl",kernelFunc:SF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kF{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,d)=>u[0]+e[d]+u[1]);const r=e.length,i=ce(r),a=t.map(u=>u[0]).join(","),l=t.map((u,d)=>u[0]+e[d]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TF{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,x)=>g[0]+e[x]+g[1]);const r=e.length,i=ce(r),a=t.map(g=>g[0]).join(","),l=t.map((g,x)=>g[0]+e[x]).join(","),c=Oe("rc",r),u=Oe("source",r),d=`${c[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,p=[`${i} rc = outputLoc;`,`${c[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${c[r-2]} += 1;
       if(${c[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${c[r-1]} += 1;
         if(${d}) {`],f=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let m="";for(let g=0,x=r===1?2:4;g<x;g++)m+=`
        ${p[g]}
        if (${f}) {
          result[${g}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${h});
        }
      `;m+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tf=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;if(o.sizeFromShape(r.shape)===0){const u=i.map((d,h)=>d[0]+r.shape[h]+d[1]);return vs({backend:t,attrs:{shape:u,value:a,dtype:r.dtype}})}const l=o.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TF(r.shape,i,a):new kF(r.shape,i,a),c=[[a]];return t.runWebGLProgram(l,[r],r.dtype,c)},$F={kernelName:o.PadV2,backendName:"webgl",kernelFunc:tf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NF=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,RF=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+hn+`
  return result;
`,AF=De({opSnippet:NF,packedOpSnippet:RF}),DF={kernelName:o.Pow,backendName:"webgl",kernelFunc:AF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,l=r.shape.length,c=[],u=o.parseAxisParam(i,r.shape);let d=u;const h=o.getAxesPermutation(d,l);let p=r;h!=null&&(p=Le({inputs:{x:r},backend:t,attrs:{perm:h}}),d=o.getInnerMostAxes(d.length,l),c.push(p)),o.assertAxesAreInnerMostDims("prod",d,l);let f;if(t.shouldExecuteOnCPU([p])){const m=t.texData.get(p.dataId).values,{outVals:g,outShape:x,outDtype:b}=R$(p.shape,p.dtype,m,d);f=t.makeTensorInfo(x,b,g)}else{const[m,g]=o.computeOutAndReduceShapes(p.shape,d),x=o.sizeFromShape(g),b=G({inputs:{x:p},backend:t,attrs:{shape:[-1,x]}}),y=o.sumOutType(r.dtype),w=pn(b,y,"prod",t);f=G({inputs:{x:w},backend:t,attrs:{shape:m}}),c.push(b),c.push(w)}if(a){c.push(f);const m=o.expandShapeToKeepDim(f.shape,u);f=G({inputs:{x:f},backend:t,attrs:{shape:m}})}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const FF={kernelName:o.Prod,backendName:"webgl",kernelFunc:EF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:l}=s,c=r.map(b=>t.readSync(b.dataId)),u=r.map(b=>b.shape),d=t.readSync(i.dataId),h=t.readSync(a.dataId),[p,f,m]=A$(c,u,d,i.shape,i.dtype,h,a.shape,l),g=p.map(b=>t.makeTensorInfo([b.length],"int32",b)),x=t.makeTensorInfo(m,i.dtype,f);return g.concat([x])}const LF={kernelName:o.RaggedGather,backendName:"webgl",kernelFunc:OF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PF(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),[u,d]=D$(a,s.shape,s.dtype,l,r.shape,c,i.shape),h=t.makeTensorInfo([u.length],"int32",u),p=t.makeTensorInfo([d.length],s.dtype,d);return[h,p]}const MF={kernelName:o.RaggedRange,backendName:"webgl",kernelFunc:PF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:l}=e,{rowPartitionTypes:c}=s,u=t.readSync(r.dataId),d=t.readSync(i.dataId),h=t.readSync(a.dataId),p=l.map(x=>t.readSync(x.dataId)),f=l.map(x=>x.shape),[m,g]=E$(u,r.shape,d,i.shape,i.dtype,h,a.shape,p,f,c);return t.makeTensorInfo(m,i.dtype,g)}const _F={kernelName:o.RaggedTensorToTensor,backendName:"webgl",kernelFunc:zF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nf=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:a}=t,l=F$(s,r,i,a);return e.makeTensorInfo([l.length],a,l)},BF={kernelName:o.Range,backendName:"webgl",kernelFunc:nf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF="return 1.0 / x;",WF=se({opSnippet:VF}),GF={kernelName:o.Reciprocal,backendName:"webgl",kernelFunc:WF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UF=Qe+`
  return (x < 0.0) ? 0.0 : x;
`,HF=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qF=se({opSnippet:UF,packedOpSnippet:HF}),XF={kernelName:o.Relu,backendName:"webgl",kernelFunc:qF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jF=Qe+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,KF=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,YF=se({opSnippet:jF,packedOpSnippet:KF}),ZF={kernelName:o.Relu6,backendName:"webgl",kernelFunc:YF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QF{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,l,c,u]=e;this.outputShape=[a,t,s,u];const d=[r&&t>1?l-1:l,r&&s>1?c-1:c],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;i?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/h[0]},
          ${d[1]/h[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JF{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,l,c,u]=e;this.outputShape=[a,t,s,u];const d=[r&&t>1?l-1:l,r&&s>1?c-1:c],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;i?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/h[0]},
          ${d[1]/h[1]},
          ${d[1]/h[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eO(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:l}=s,[c,u]=l,d=o.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new JF(r.shape,c,u,i,a):new QF(r.shape,c,u,i,a);return t.runWebGLProgram(d,[r],"float32")}const tO={kernelName:o.ResizeBilinear,backendName:"webgl",kernelFunc:eO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nO{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,l]=e,c=[s&&a>1?r-1:r,s&&l>1?i-1:i],u=[s&&a>1?a-1:a,s&&l>1?l-1:l],d=c[0]/u[0],h=c[1]/u[1],p=1/d,f=1/h,m=Math.ceil(p)*2+2,g=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sO(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,l=new nO(i.shape,r.shape,a);return t.runWebGLProgram(l,[i],i.dtype)}const oO={kernelName:o.ResizeBilinearGrad,backendName:"webgl",kernelFunc:sO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rO{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,l,c,u]=e;this.outputShape=[a,t,s,u];const d=[r&&t>1?l-1:l,r&&s>1?c-1:c],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let f;i?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/h[0]},
          ${d[1]/h[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iO{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,l,c,u]=e;this.outputShape=[a,t,s,u];const d=[r&&t>1?l-1:l,r&&s>1?c-1:c],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let f;i?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/h[0]},
          ${d[1]/h[1]},
          ${d[1]/h[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aO(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:l}=s,[c,u]=l,d=o.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new iO(r.shape,c,u,i,a):new rO(r.shape,c,u,i,a);return t.runWebGLProgram(d,[r],r.dtype)}const lO={kernelName:o.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:aO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cO{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,l]=e,c=[s&&a>1?r-1:r,s&&l>1?i-1:i],u=[s&&a>1?a-1:a,s&&l>1?l-1:l],d=c[0]/u[0],h=c[1]/u[1],p=1/d,f=1/h,m=Math.ceil(p)*2+2,g=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,l=new cO(i.shape,r.shape,a);return t.runWebGLProgram(l,[i],i.dtype)}const dO={kernelName:o.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:uO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hO{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=l=>t.indexOf(l)!==-1&&e[l]!==1?`${e[l]} - coords[${l}] - 1`:`coords[${l}]`,i=e.map((l,c)=>r(c)).join(","),a=ce(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pO{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Oe("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,l=ce(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(r.slice())};
          if(${i}){
            result.g = ${u(r.slice())};
          }
          if(${a}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(m){return p(m)}function u(m){return m[s-1]="("+m[s-1]+" + 1)",p(m)}function d(m){return m[s-2]="("+m[s-2]+" + 1)",p(m)}function h(m){return m[s-1]="("+m[s-1]+" + 1)",m[s-2]="("+m[s-2]+" + 1)",p(m)}function p(m){const g=e.map((y,w)=>f(w,m)),x=g.join(","),b=g.slice(-2).join(",");return`getChannel(getX(${x}), vec2(${b}))`}function f(m,g){return t.indexOf(m)!==-1&&e[m]!==1?`${e[m]} - ${g[m]} - 1`:`${g[m]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,a=r.shape.length,l=o.parseAxisParam(i,r.shape);if(a===0)return We({inputs:{x:r},backend:t});const c=o.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pO(r.shape,l):new hO(r.shape,l);return t.runWebGLProgram(c,[r],r.dtype)}const mO={kernelName:o.Reverse,backendName:"webgl",kernelFunc:fO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gO{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xO={kernelName:o.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,l=t,c=new gO(s.shape,i),[u,d]=Tr(a,s.shape[1],s.shape[2]),h=[[u,d,Math.sin(r),Math.cos(r)]];return l.runWebGLProgram(c,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bO=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,yO=se({opSnippet:bO}),CO={kernelName:o.Round,backendName:"webgl",kernelFunc:yO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wO="return inversesqrt(x);",vO=se({opSnippet:wO,cpuKernelImpl:O$}),SO={kernelName:o.Rsqrt,backendName:"webgl",kernelFunc:vO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ua{constructor(e,t,s,r,i,a,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const u=ce(i.length),d=ce(a.length);let h="";s===1?h="i":s===2&&(h="i, j");const p=`getIndices(${h})`;let f="";r===1?f="i":r===2&&(f="i, coords[1]");const m=`getUpdates(${f})`;let g="";c&&(g="coords[0], coords[1]");const x=`getDefaultValue(${g})`,b=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${x}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IO{constructor(e,t,s,r,i,a,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const u=ce(i.length),d=ce(a.length);let h="";s===1?h="i":s===2&&(h="i, j");const p=`getIndices(${h})`;let f="";r===1?f="i":r===2&&(f="i, coords[1]");const m=`getUpdates(${f})`;let g="";c&&(g="coords[0], coords[1]");const x=`getDefaultValue(${g})`,b=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${x}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kO(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=o.calculateShapes(i,r,a),p=[h/u,u];if(h===0)return t.makeTensorInfo(a,r.dtype);const f=G({inputs:{x:r},backend:t,attrs:{shape:[c,l]}}),m=G({inputs:{x:i},backend:t,attrs:{shape:[c,u]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0]));let x;o.env().getBool("WEBGL_PACK")?x=new IO(c,l,f.shape.length,m.shape.length,d,p):x=new Ua(c,l,f.shape.length,m.shape.length,d,p);const b=t.runWebGLProgram(x,[m,f,g],m.dtype),y=G({inputs:{x:b},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(g),y}const TO={kernelName:o.ScatterNd,backendName:"webgl",kernelFunc:kO};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $O{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,l=o.env().getNumber("WEBGL_VERSION")===2?i:a,c=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${l}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NO(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,l=new $O(r.shape[0],r.shape[1],i.shape[1],a),c=[[r.shape[1]]];return t.runWebGLProgram(l,[r,i],"int32",c)}const RO={kernelName:o.SearchSorted,backendName:"webgl",kernelFunc:NO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AO{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const l=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],u=[];for(let d=0;d<t.length;d++)u.push(`${l[d]}`),d<e&&c.push(`${l[d]}`);r=c.join(),i=u.join()}const a=ce(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,a=new AO(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(a,[s,r,i],o.upcastType(r.dtype,i.dtype))}const EO={kernelName:o.Select,backendName:"webgl",kernelFunc:DO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FO=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${co};
  float scale = ${uo};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,OO=se({opSnippet:FO}),LO={kernelName:o.Selu,backendName:"webgl",kernelFunc:OO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PO=Pn+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,MO=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zO=se({opSnippet:PO,packedOpSnippet:MO,cpuKernelImpl:P$}),_O={kernelName:o.Sigmoid,backendName:"webgl",kernelFunc:zO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BO=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,VO=se({opSnippet:BO}),WO={kernelName:o.Sign,backendName:"webgl",kernelFunc:VO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GO=Pn+`
  return sin(x);
`,UO=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${hn}
  return result;
`,HO=se({opSnippet:GO,packedOpSnippet:UO}),qO={kernelName:o.Sin,backendName:"webgl",kernelFunc:HO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XO=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,jO=se({opSnippet:XO}),KO={kernelName:o.Sinh,backendName:"webgl",kernelFunc:jO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YO=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,ZO=se({opSnippet:YO}),QO={kernelName:o.Softplus,backendName:"webgl",kernelFunc:ZO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JO=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;o.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((b,y)=>b*y),c=[[0,0]];c.push(...a);for(let b=1+i.length;b<r.shape.length;++b)c.push([0,0]);const u=[],d=tf({inputs:{x:r},backend:t,attrs:{paddings:c,constantValue:0}}),h=os(d.shape,i,l,!1),p=rs(h.length,i.length,!1),f=is(d.shape,i,l,!1),m=G({inputs:{x:d},backend:t,attrs:{shape:h}}),g=Le({inputs:{x:m},backend:t,attrs:{perm:p}}),x=G({inputs:{x:g},backend:t,attrs:{shape:f}});return u.push(d),u.push(m),u.push(g),u.forEach(b=>t.disposeIntermediateTensorInfo(b)),x},eL={kernelName:o.SpaceToBatchND,backendName:"webgl",kernelFunc:JO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tL(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const l=t.readSync(s.dataId),c=t.readSync(r.dataId),u=t.readSync(i.dataId),d=t.readSync(a.dataId)[0],[h,p,f,m,g]=z$(l,s.shape,s.dtype,c,r.dtype,u,d);return[t.makeTensorInfo(p,s.dtype,h),t.makeTensorInfo([p[0]],r.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(x=>Number(x)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const nL={kernelName:o.SparseFillEmptyRows,backendName:"webgl",kernelFunc:tL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sL(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.readSync(r.dataId)),l=t.readSync(s.dataId),c=Array.from(t.readSync(i.dataId)),[u,d,h]=_$(l,s.shape,s.dtype,a,c);return[t.makeTensorInfo(d,s.dtype,u),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const oL={kernelName:o.SparseReshape,backendName:"webgl",kernelFunc:sL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rL(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),[u,d]=Ip(a,s.shape,s.dtype,l,c,!0);return t.makeTensorInfo(d,s.dtype,u)}const iL={kernelName:o.SparseSegmentMean,backendName:"webgl",kernelFunc:rL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aL(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),[u,d]=Ip(a,s.shape,s.dtype,l,c);return t.makeTensorInfo(d,s.dtype,u)}const lL={kernelName:o.SparseSegmentSum,backendName:"webgl",kernelFunc:aL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cL(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:l}=s,{sliceRank:c,numUpdates:u,sliceSize:d,strides:h,outputSize:p}=o.calculateShapes(i,r,l),f=!1;if(i.dtype==="string"){const b=t.bufferSync(r),y=t.bufferSync(i),w=o.decodeString(t.readSync(a.dataId)[0]),C=L$(b,y,l,p,d,u,c,h,w,f);return t.makeTensorInfo(l,C.dtype,C.values)}const m=new Ua(u,c,r.shape.length,i.shape.length,h,[p,1],f),g=t.runWebGLProgram(m,[i,r,a],i.dtype),x=G({inputs:{x:g},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(g),x}const uL={kernelName:o.SparseToDense,backendName:"webgl",kernelFunc:cL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,l=o.parseAxisParam(a,r.shape)[0],c=Vr(r,i,l),u=r.shape.length,d=new Array(u).fill(0),h=r.shape.slice();return c.map(p=>{const f=[...h];f[l]=p;const m=Mn({inputs:{x:r},backend:t,attrs:{begin:d,size:f}});return d[l]+=p,m})}const hL={kernelName:o.SplitV,backendName:"webgl",kernelFunc:dL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jl="return sqrt(x);",pL=se({opSnippet:Jl,packedOpSnippet:Jl,cpuKernelImpl:B$}),fL={kernelName:o.Sqrt,backendName:"webgl",kernelFunc:pL};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mL="return x * x;",gL=se({opSnippet:mL}),xL={kernelName:o.Square,backendName:"webgl",kernelFunc:gL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ec="return (a - b) * (a - b);",bL=De({opSnippet:ec,packedOpSnippet:ec}),yL={kernelName:o.SquaredDifference,backendName:"webgl",kernelFunc:bL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),a=kt(i),l=V$(a,"string",s);return t.makeTensorInfo(r.shape,"string",l)}const wL={kernelName:o.StaticRegexReplace,backendName:"webgl",kernelFunc:CL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vL({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Qe+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new ft(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const SL={kernelName:o.Step,backendName:"webgl",kernelFunc:vL};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IL{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=ce(s.length),a=ce(s.length);let l="";if(r===1)l="coords * strides + begin";else{let c=0;l=s.map((u,d)=>(c++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${c-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:l,beginMask:c,endMask:u,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=s,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:x,isSimpleSlice:b,begin:y,end:w,strides:C}=vr(r.shape,i,a,l,c,u,d,h,p);let v;if(g)v=G({inputs:{x:r},backend:t,attrs:{shape:m}});else if(x||b){o.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const I=yr(y,w,C),k=Mn({inputs:{x:r},backend:t,attrs:{begin:y,size:I}});v=G({inputs:{x:k},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(k)}else if(t.shouldExecuteOnCPU([r])){const k=t.readSync(r.dataId),$=o.buffer(r.shape,r.dtype,k),N=W$(f,$,C,y);v=t.makeTensorInfo(m,r.dtype,N.values)}else{const k=new IL(y,C,f);v=t.runWebGLProgram(k,[r],r.dtype)}const S=G({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(v),S}const TL={kernelName:o.StridedSlice,backendName:"webgl",kernelFunc:kL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $L(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:l,padWidth:c,preserveShortSequences:u}=s,{data:d,dataSplits:h}=e,p=t.readSync(d.dataId),f=t.readSync(h.dataId),[m,g]=G$(p,f,r,i,a,l,c,u);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(h.shape,"int32",g)]}const NL={kernelName:o.StringNGrams,backendName:"webgl",kernelFunc:$L};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RL(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const l=t.readSync(i.dataId),c=t.readSync(a.dataId)[0],[u,d,h]=U$(l,c,r),p=d.length;return[t.makeTensorInfo([p,2],"int32",u),t.makeTensorInfo([p],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const AL={kernelName:o.StringSplit,backendName:"webgl",kernelFunc:RL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DL(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(i.dataId),l=H$(a,r);return t.makeTensorInfo(i.shape,"int32",l)}const EL={kernelName:o.StringToHashBucketFast,backendName:"webgl",kernelFunc:DL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FL="return tan(x);",OL=se({opSnippet:FL}),LL={kernelName:o.Tan,backendName:"webgl",kernelFunc:OL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PL=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,ML=se({opSnippet:PL}),zL={kernelName:o.Tanh,backendName:"webgl",kernelFunc:ML};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _L(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:a}=e,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=o.calculateShapes(a,i,r.shape),p=[h/u,u];if(h===0)return t.makeTensorInfo(r.shape,i.dtype);const f=G({inputs:{x:i},backend:t,attrs:{shape:[c,l]}}),m=G({inputs:{x:a},backend:t,attrs:{shape:[c,u]}}),g=G({inputs:{x:r},backend:t,attrs:{shape:p}}),x=new Ua(c,l,f.shape.length,m.shape.length,d,p,!1,!0),b=t.runWebGLProgram(x,[m,f,g],g.dtype),y=G({inputs:{x:b},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),y}const BL={kernelName:o.TensorScatterUpdate,backendName:"webgl",kernelFunc:_L};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VL{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const r=ce(this.rank),i=WL(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function WL(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sf(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const c=t.readSync(r.dataId),u=r.dtype==="string"?c.map(p=>o.decodeString(p)):c,d=o.buffer(r.shape,r.dtype,u),h=X$(d,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const a=new VL(r.shape,i);return t.runWebGLProgram(a,[r],r.dtype)}const GL={kernelName:o.Tile,backendName:"webgl",kernelFunc:sf};class UL{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class HL{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qt(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function tc(n){let e=1;for(;e<n;)e*=2;return e}function qL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s,l=o.env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=o.env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,d=u[u.length-1];if(t.shouldExecuteOnCPU([r])||d<l||i>c){const N=t.readSync(r.dataId),[R,F]=j$(N,u,r.dtype,i,a);return[t.makeTensorInfo(R.shape,R.dtype,R.values),t.makeTensorInfo(F.shape,F.dtype,F.values)]}if(i===0)return u[u.length-1]=0,[t.makeTensorInfo(u,r.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(d===1)return[r,vs({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),p=h!==null&&h.isPacked,f=p?t.unpackTensor(r):r,g=o.sizeFromShape(u)/d,x=G({inputs:{x:f},attrs:{shape:[g,d]},backend:t});p&&qt(t,f);const b=tc(i),y=tc(d);let w=null;const C=()=>w===null?[x,x]:[x,w],v=(N,R,F)=>{const O=C(),L=new UL(F),E=[[d],[w===null?1:0],[Number.NEGATIVE_INFINITY],[N],[R]],P=w;w=t.runWebGLProgram(L,O,"int32",E),qt(t,P)};for(let N=1;N<b;N*=2){const R=N*2;for(let F=N;F>=1;F/=2)v(R,F,[g,y])}for(let N=y;N>b;N/=2){const R=C(),F=new HL([g,N/2]),L=[[d],[w===null?1:0],[b]],A=w;w=t.runWebGLProgram(F,R,"int32",L),qt(t,A);const E=b/2,P=E*2;for(let D=E;D>=1;D/=2)v(P,D,w.shape)}let S=w;w=Mn({inputs:{x:w},backend:t,attrs:{begin:0,size:[g,i]}}),qt(t,S);let I=Kp({inputs:{x,indices:w},backend:t,attrs:{axis:1,batchDims:1}});qt(t,x);const k=u.slice(0,-1);k.push(i),S=w,w=G({inputs:{x:w},attrs:{shape:k},backend:t}),qt(t,S);const $=I;return I=G({inputs:{x:I},attrs:{shape:k},backend:t}),qt(t,$),[I,w]}const XL={kernelName:o.TopK,backendName:"webgl",kernelFunc:qL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jL{constructor(e,t,s,r,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const l=s==="nearest"?1:2;let c;switch(r){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${l} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KL(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:l,fillValue:c,outputShape:u}=s,[d,h,p,f]=r.shape,[m,g]=u??[h,p],x=[d,m,g,f],b=new jL(h,p,a,l,c,x);return t.runWebGLProgram(b,[r,i],"float32")}const YL={kernelName:o.Transform,backendName:"webgl",kernelFunc:KL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZL(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;An(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:l,outputShape:c,indices:u}=K$(a,r,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,l),s.makeTensorInfo([u.length],"int32",u)]}const QL={kernelName:o.Unique,backendName:"webgl",kernelFunc:ZL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JL(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,l=a.shape.length,c=r.shape[i],u=new Array(l-1);let d=0;for(let g=0;g<l;g++)g!==i&&(u[d++]=a.shape[g]);const h=[],p=new Array(l).fill(0),f=a.shape.slice();f[i]=1;const m=new Array(c);for(let g=0;g<m.length;g++){p[i]=g;const x=Mn({inputs:{x:a},backend:t,attrs:{begin:p,size:f}}),b=G({inputs:{x},backend:t,attrs:{shape:u}});m[g]=b,h.push(x)}return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const eP={kernelName:o.Unpack,backendName:"webgl",kernelFunc:JL};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tP{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,a=e.numSegments,l=a*Math.ceil(i/s);this.outputShape=[r,l];const c="0.0",u="sumValue",d=Math.floor(s/4)*4,h=s%4,p=`
        sumValue += dot(values, segFilter);
    `;let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let m="";i%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s,l=r.shape.length,c=[];let u=0;const d=o.getAxesPermutation([u],l);let h=r;d!=null&&(h=Le({inputs:{x:r},backend:t,attrs:{perm:d}}),c.push(h),u=o.getInnerMostAxes(1,l)[0]);const p=Mc(h.shape,u,a),f=o.sizeFromShape([h.shape[u]]),m=G({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}});c.push(m);const g=o.sumOutType(r.dtype),x=(C,v,S,I,k)=>{const $=C.shape[0],N=C.shape[1],R=Pc(N,k),F={windowSize:R,inSize:N,batchSize:$,numSegments:k},O=new tP(F,v),L=t.compileAndRun(O,[C,S],I);if(c.push(L),L.shape[1]===k)return L;const A=nf({backend:t,attrs:{start:0,stop:k,step:1,dtype:"float32"}}),E=sf({inputs:{x:A},backend:t,attrs:{reps:[N/R]}});return c.push(A),c.push(E),x(L,v,E,I,k)},b=x(m,"unsortedSegmentSum",i,g,a),y=G({inputs:{x:b},backend:t,attrs:{shape:p}});let w=y;if(d!=null){c.push(y);const C=o.getUndoAxesPermutation(d);w=Le({inputs:{x:w},backend:t,attrs:{perm:C}})}return c.forEach(C=>t.disposeIntermediateTensorInfo(C)),w}const sP={kernelName:o.UnsortedSegmentSum,backendName:"webgl",kernelFunc:nP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oP=[VN,GN,qN,KN,ZN,eR,nR,oR,lR,uR,pR,gR,yR,SR,TR,NR,AR,OR,PR,zR,WR,KR,ZR,tA,sA,cA,dA,mA,IN,bA,SA,$A,FA,PA,zA,BA,WA,qA,KA,QA,e2,n2,o2,a2,c2,p2,m2,b2,w2,S2,$2,D2,L2,z2,V2,W2,U2,q2,j2,Y2,Q2,nD,rD,lD,uD,pD,gD,CD,ID,SN,TD,wA,RD,ED,LD,TN,_D,GD,HD,KD,QD,nE,rE,cE,pE,gE,bE,vE,IE,TE,AE,EE,OE,PE,zE,WE,qE,YE,oF,RN,lF,dF,fF,xF,rA,CF,vF,IF,$F,DF,NN,FF,LF,MF,_F,BF,iA,eF,GF,XF,ZF,DN,tO,oO,lO,dO,mO,xO,CO,SO,TO,RO,EO,LO,_O,WO,qO,KO,XR,nF,QO,eL,nL,oL,iL,lL,uL,hL,fL,xL,yL,wL,SL,TL,NL,AL,EL,tF,zN,LL,zL,BL,GL,XL,YL,_N,QL,eP,sP,wF];for(const n of oP)o.registerKernel(n);/** @license See the LICENSE file. */const rP="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iP={"tfjs-core":pc,"tfjs-backend-cpu":ph,"tfjs-backend-webgl":$p,"tfjs-data":xd,"tfjs-layers":Io,"tfjs-converter":Bc,tfjs:rP};exports.Abs=o.Abs;exports.Acos=o.Acos;exports.Acosh=o.Acosh;exports.AdadeltaOptimizer=o.AdadeltaOptimizer;exports.AdagradOptimizer=o.AdagradOptimizer;exports.AdamOptimizer=o.AdamOptimizer;exports.AdamaxOptimizer=o.AdamaxOptimizer;exports.Add=o.Add;exports.AddN=o.AddN;exports.All=o.All;exports.Any=o.Any;exports.ArgMax=o.ArgMax;exports.ArgMin=o.ArgMin;exports.Asin=o.Asin;exports.Asinh=o.Asinh;exports.Atan=o.Atan;exports.Atan2=o.Atan2;exports.Atanh=o.Atanh;exports.AvgPool=o.AvgPool;exports.AvgPool3D=o.AvgPool3D;exports.AvgPool3DGrad=o.AvgPool3DGrad;exports.AvgPoolGrad=o.AvgPoolGrad;exports.BatchMatMul=o.BatchMatMul;exports.BatchToSpaceND=o.BatchToSpaceND;exports.Bincount=o.Bincount;exports.BitwiseAnd=o.BitwiseAnd;exports.BroadcastArgs=o.BroadcastArgs;exports.BroadcastTo=o.BroadcastTo;exports.Cast=o.Cast;exports.Ceil=o.Ceil;exports.ClipByValue=o.ClipByValue;exports.Complex=o.Complex;exports.ComplexAbs=o.ComplexAbs;exports.Concat=o.Concat;exports.Conv2D=o.Conv2D;exports.Conv2DBackpropFilter=o.Conv2DBackpropFilter;exports.Conv2DBackpropInput=o.Conv2DBackpropInput;exports.Conv3D=o.Conv3D;exports.Conv3DBackpropFilterV2=o.Conv3DBackpropFilterV2;exports.Conv3DBackpropInputV2=o.Conv3DBackpropInputV2;exports.Cos=o.Cos;exports.Cosh=o.Cosh;exports.CropAndResize=o.CropAndResize;exports.Cumprod=o.Cumprod;exports.Cumsum=o.Cumsum;exports.DataStorage=o.DataStorage;exports.DenseBincount=o.DenseBincount;exports.DepthToSpace=o.DepthToSpace;exports.DepthwiseConv2dNative=o.DepthwiseConv2dNative;exports.DepthwiseConv2dNativeBackpropFilter=o.DepthwiseConv2dNativeBackpropFilter;exports.DepthwiseConv2dNativeBackpropInput=o.DepthwiseConv2dNativeBackpropInput;exports.Diag=o.Diag;exports.Dilation2D=o.Dilation2D;exports.Dilation2DBackpropFilter=o.Dilation2DBackpropFilter;exports.Dilation2DBackpropInput=o.Dilation2DBackpropInput;exports.Draw=o.Draw;Object.defineProperty(exports,"ENV",{enumerable:!0,get:()=>o.ENV});exports.Einsum=o.Einsum;exports.Elu=o.Elu;exports.EluGrad=o.EluGrad;exports.Environment=o.Environment;exports.Equal=o.Equal;exports.Erf=o.Erf;exports.Exp=o.Exp;exports.ExpandDims=o.ExpandDims;exports.Expm1=o.Expm1;exports.FFT=o.FFT;exports.Fill=o.Fill;exports.FlipLeftRight=o.FlipLeftRight;exports.Floor=o.Floor;exports.FloorDiv=o.FloorDiv;exports.FromPixels=o.FromPixels;exports.FusedBatchNorm=o.FusedBatchNorm;exports.FusedConv2D=o.FusedConv2D;exports.FusedDepthwiseConv2D=o.FusedDepthwiseConv2D;exports.GatherNd=o.GatherNd;exports.GatherV2=o.GatherV2;exports.GraphModel=o.GraphModel;exports.Greater=o.Greater;exports.GreaterEqual=o.GreaterEqual;exports.IFFT=o.IFFT;exports.Identity=o.Identity;exports.Imag=o.Imag;exports.IsFinite=o.IsFinite;exports.IsInf=o.IsInf;exports.IsNan=o.IsNan;exports.KernelBackend=o.KernelBackend;exports.LRN=o.LRN;exports.LRNGrad=o.LRNGrad;exports.LeakyRelu=o.LeakyRelu;exports.Less=o.Less;exports.LessEqual=o.LessEqual;exports.LinSpace=o.LinSpace;exports.Log=o.Log;exports.Log1p=o.Log1p;exports.LogSoftmax=o.LogSoftmax;exports.LogicalAnd=o.LogicalAnd;exports.LogicalNot=o.LogicalNot;exports.LogicalOr=o.LogicalOr;exports.LogicalXor=o.LogicalXor;exports.LowerBound=o.LowerBound;exports.MatrixBandPart=o.MatrixBandPart;exports.Max=o.Max;exports.MaxPool=o.MaxPool;exports.MaxPool3D=o.MaxPool3D;exports.MaxPool3DGrad=o.MaxPool3DGrad;exports.MaxPoolGrad=o.MaxPoolGrad;exports.MaxPoolWithArgmax=o.MaxPoolWithArgmax;exports.Maximum=o.Maximum;exports.Mean=o.Mean;exports.Min=o.Min;exports.Minimum=o.Minimum;exports.MirrorPad=o.MirrorPad;exports.Mod=o.Mod;exports.MomentumOptimizer=o.MomentumOptimizer;exports.Multinomial=o.Multinomial;exports.Multiply=o.Multiply;exports.Neg=o.Neg;exports.NonMaxSuppressionV3=o.NonMaxSuppressionV3;exports.NonMaxSuppressionV4=o.NonMaxSuppressionV4;exports.NonMaxSuppressionV5=o.NonMaxSuppressionV5;exports.NotEqual=o.NotEqual;exports.OP_SCOPE_SUFFIX=o.OP_SCOPE_SUFFIX;exports.OneHot=o.OneHot;exports.OnesLike=o.OnesLike;exports.Optimizer=o.Optimizer;exports.Pack=o.Pack;exports.PadV2=o.PadV2;exports.Pool=o.Pool;exports.Pow=o.Pow;exports.Prelu=o.Prelu;exports.Prod=o.Prod;exports.RMSPropOptimizer=o.RMSPropOptimizer;exports.RaggedGather=o.RaggedGather;exports.RaggedRange=o.RaggedRange;exports.RaggedTensorToTensor=o.RaggedTensorToTensor;exports.Range=o.Range;Object.defineProperty(exports,"Rank",{enumerable:!0,get:()=>o.Rank});exports.Real=o.Real;exports.RealDiv=o.RealDiv;exports.Reciprocal=o.Reciprocal;Object.defineProperty(exports,"Reduction",{enumerable:!0,get:()=>o.Reduction});exports.Relu=o.Relu;exports.Relu6=o.Relu6;exports.Reshape=o.Reshape;exports.ResizeBilinear=o.ResizeBilinear;exports.ResizeBilinearGrad=o.ResizeBilinearGrad;exports.ResizeNearestNeighbor=o.ResizeNearestNeighbor;exports.ResizeNearestNeighborGrad=o.ResizeNearestNeighborGrad;exports.Reverse=o.Reverse;exports.RotateWithOffset=o.RotateWithOffset;exports.Round=o.Round;exports.Rsqrt=o.Rsqrt;exports.SGDOptimizer=o.SGDOptimizer;exports.ScatterNd=o.ScatterNd;exports.SearchSorted=o.SearchSorted;exports.Select=o.Select;exports.Selu=o.Selu;exports.Sigmoid=o.Sigmoid;exports.Sign=o.Sign;exports.Sin=o.Sin;exports.Sinh=o.Sinh;exports.Slice=o.Slice;exports.Softmax=o.Softmax;exports.Softplus=o.Softplus;exports.SpaceToBatchND=o.SpaceToBatchND;exports.SparseFillEmptyRows=o.SparseFillEmptyRows;exports.SparseReshape=o.SparseReshape;exports.SparseSegmentMean=o.SparseSegmentMean;exports.SparseSegmentSum=o.SparseSegmentSum;exports.SparseToDense=o.SparseToDense;exports.SplitV=o.SplitV;exports.Sqrt=o.Sqrt;exports.Square=o.Square;exports.SquaredDifference=o.SquaredDifference;exports.StaticRegexReplace=o.StaticRegexReplace;exports.Step=o.Step;exports.StridedSlice=o.StridedSlice;exports.StringNGrams=o.StringNGrams;exports.StringSplit=o.StringSplit;exports.StringToHashBucketFast=o.StringToHashBucketFast;exports.Sub=o.Sub;exports.Sum=o.Sum;exports.Tan=o.Tan;exports.Tanh=o.Tanh;exports.Tensor=o.Tensor;exports.TensorBuffer=o.TensorBuffer;exports.TensorScatterUpdate=o.TensorScatterUpdate;exports.Tile=o.Tile;exports.TopK=o.TopK;exports.Transform=o.Transform;exports.Transpose=o.Transpose;exports.Unique=o.Unique;exports.Unpack=o.Unpack;exports.UnsortedSegmentSum=o.UnsortedSegmentSum;exports.UpperBound=o.UpperBound;exports.Variable=o.Variable;exports.ZerosLike=o.ZerosLike;exports._FusedMatMul=o._FusedMatMul;exports.abs=o.abs;exports.acos=o.acos;exports.acosh=o.acosh;exports.add=o.add;exports.addN=o.addN;exports.all=o.all;exports.any=o.any;exports.argMax=o.argMax;exports.argMin=o.argMin;exports.asin=o.asin;exports.asinh=o.asinh;exports.atan=o.atan;exports.atan2=o.atan2;exports.atanh=o.atanh;exports.avgPool=o.avgPool;exports.avgPool3d=o.avgPool3d;exports.backend=o.backend;exports.basicLSTMCell=o.basicLSTMCell;exports.batchNorm=o.batchNorm;exports.batchNorm2d=o.batchNorm2d;exports.batchNorm3d=o.batchNorm3d;exports.batchNorm4d=o.batchNorm4d;exports.batchToSpaceND=o.batchToSpaceND;exports.bincount=o.bincount;exports.bitwiseAnd=o.bitwiseAnd;exports.booleanMaskAsync=o.booleanMaskAsync;exports.broadcastArgs=o.broadcastArgs;exports.broadcastTo=o.broadcastTo;exports.broadcast_util=o.broadcast_util;exports.browser=o.browser;exports.buffer=o.buffer;exports.cast=o.cast;exports.ceil=o.ceil;exports.clipByValue=o.clipByValue;exports.clone=o.clone;exports.complex=o.complex;exports.concat=o.concat;exports.concat1d=o.concat1d;exports.concat2d=o.concat2d;exports.concat3d=o.concat3d;exports.concat4d=o.concat4d;exports.conv1d=o.conv1d;exports.conv2d=o.conv2d;exports.conv2dTranspose=o.conv2dTranspose;exports.conv3d=o.conv3d;exports.conv3dTranspose=o.conv3dTranspose;exports.copyRegisteredKernels=o.copyRegisteredKernels;exports.cos=o.cos;exports.cosh=o.cosh;exports.cosineWindow=o.cosineWindow;exports.cumprod=o.cumprod;exports.cumsum=o.cumsum;exports.customGrad=o.customGrad;exports.denseBincount=o.denseBincount;exports.deprecationWarn=o.deprecationWarn;exports.depthToSpace=o.depthToSpace;exports.depthwiseConv2d=o.depthwiseConv2d;exports.deregisterOp=o.deregisterOp;exports.device_util=o.device_util;exports.diag=o.diag;exports.dilation2d=o.dilation2d;exports.disableDeprecationWarnings=o.disableDeprecationWarnings;exports.dispose=o.dispose;exports.disposeVariables=o.disposeVariables;exports.div=o.div;exports.divNoNan=o.divNoNan;exports.dot=o.dot;exports.dropout=o.dropout;exports.einsum=o.einsum;exports.elu=o.elu;exports.enableDebugMode=o.enableDebugMode;exports.enableProdMode=o.enableProdMode;exports.enclosingPowerOfTwo=o.enclosingPowerOfTwo;exports.engine=o.engine;exports.ensureShape=o.ensureShape;exports.env=o.env;exports.equal=o.equal;exports.erf=o.erf;exports.euclideanNorm=o.euclideanNorm;exports.exp=o.exp;exports.expandDims=o.expandDims;exports.expm1=o.expm1;exports.eye=o.eye;exports.fft=o.fft;exports.fill=o.fill;exports.findBackend=o.findBackend;exports.findBackendFactory=o.findBackendFactory;exports.floor=o.floor;exports.floorDiv=o.floorDiv;exports.fused=o.fused_ops;exports.gather=o.gather;exports.gatherND=o.gatherND;exports.getBackend=o.getBackend;exports.getGradient=o.getGradient;exports.getKernel=o.getKernel;exports.getKernelsForBackend=o.getKernelsForBackend;exports.grad=o.grad;exports.grads=o.grads;exports.greater=o.greater;exports.greaterEqual=o.greaterEqual;exports.ifft=o.ifft;exports.imag=o.imag;exports.image=o.image;exports.inTopKAsync=o.inTopKAsync;exports.io=o.io;exports.irfft=o.irfft;exports.isFinite=o.isFinite;exports.isInf=o.isInf;exports.isNaN=o.isNaN;exports.keep=o.keep;exports.leakyRelu=o.leakyRelu;exports.less=o.less;exports.lessEqual=o.lessEqual;exports.linalg=o.linalg;exports.linspace=o.linspace;exports.loadGraphModel=o.loadGraphModel;exports.loadGraphModelSync=o.loadGraphModelSync;exports.localResponseNormalization=o.localResponseNormalization;exports.log=o.log$1;exports.log1p=o.log1p;exports.logSigmoid=o.logSigmoid;exports.logSoftmax=o.logSoftmax;exports.logSumExp=o.logSumExp;exports.logicalAnd=o.logicalAnd;exports.logicalNot=o.logicalNot;exports.logicalOr=o.logicalOr;exports.logicalXor=o.logicalXor;exports.losses=o.losses;exports.lowerBound=o.lowerBound;exports.matMul=o.matMul;exports.max=o.max;exports.maxPool=o.maxPool;exports.maxPool3d=o.maxPool3d;exports.maxPoolWithArgmax=o.maxPoolWithArgmax;exports.maximum=o.maximum;exports.mean=o.mean;exports.memory=o.memory;exports.meshgrid=o.meshgrid;exports.min=o.min;exports.minimum=o.minimum;exports.mirrorPad=o.mirrorPad;exports.mod=o.mod;exports.moments=o.moments;exports.movingAverage=o.movingAverage;exports.mul=o.mul;exports.multiRNNCell=o.multiRNNCell;exports.multinomial=o.multinomial;exports.neg=o.neg;exports.norm=o.norm;exports.notEqual=o.notEqual;exports.oneHot=o.oneHot;exports.ones=o.ones;exports.onesLike=o.onesLike;exports.op=o.op;exports.outerProduct=o.outerProduct;exports.pad=o.pad;exports.pad1d=o.pad1d;exports.pad2d=o.pad2d;exports.pad3d=o.pad3d;exports.pad4d=o.pad4d;exports.pool=o.pool;exports.pow=o.pow;exports.prelu=o.prelu;exports.print=o.print;exports.prod=o.prod;exports.profile=o.profile;exports.raggedGather=o.raggedGather;exports.raggedRange=o.raggedRange;exports.raggedTensorToTensor=o.raggedTensorToTensor;exports.rand=o.rand;exports.randomGamma=o.randomGamma;exports.randomNormal=o.randomNormal;exports.randomStandardNormal=o.randomStandardNormal;exports.randomUniform=o.randomUniform;exports.randomUniformInt=o.randomUniformInt;exports.range=o.range;exports.ready=o.ready;exports.real=o.real;exports.reciprocal=o.reciprocal;exports.registerBackend=o.registerBackend;exports.registerGradient=o.registerGradient;exports.registerKernel=o.registerKernel;exports.registerOp=o.registerOp;exports.relu=o.relu;exports.relu6=o.relu6;exports.removeBackend=o.removeBackend;exports.reshape=o.reshape;exports.reverse=o.reverse;exports.reverse1d=o.reverse1d;exports.reverse2d=o.reverse2d;exports.reverse3d=o.reverse3d;exports.reverse4d=o.reverse4d;exports.rfft=o.rfft;exports.round=o.round;exports.rsqrt=o.rsqrt;exports.scalar=o.scalar;exports.scatterND=o.scatterND;exports.scatter_util=o.scatter_nd_util;exports.searchSorted=o.searchSorted;exports.selu=o.selu;exports.separableConv2d=o.separableConv2d;exports.serialization=o.serialization;exports.setBackend=o.setBackend;exports.setPlatform=o.setPlatform;exports.setdiff1dAsync=o.setdiff1dAsync;exports.sigmoid=o.sigmoid;exports.sign=o.sign;exports.signal=o.signal;exports.sin=o.sin;exports.sinh=o.sinh;exports.slice=o.slice;exports.slice1d=o.slice1d;exports.slice2d=o.slice2d;exports.slice3d=o.slice3d;exports.slice4d=o.slice4d;exports.softmax=o.softmax;exports.softplus=o.softplus;exports.spaceToBatchND=o.spaceToBatchND;exports.sparse=o.sparse;exports.sparseToDense=o.sparseToDense;exports.spectral=o.spectral;exports.split=o.split;exports.sqrt=o.sqrt;exports.square=o.square;exports.squaredDifference=o.squaredDifference;exports.squeeze=o.squeeze;exports.stack=o.stack;exports.step=o.step;exports.stridedSlice=o.stridedSlice;exports.string=o.string;exports.sub=o.sub;exports.sum=o.sum;exports.sumOutType=o.sumOutType;exports.tan=o.tan;exports.tanh=o.tanh;exports.tensor=o.tensor;exports.tensor1d=o.tensor1d;exports.tensor2d=o.tensor2d;exports.tensor3d=o.tensor3d;exports.tensor4d=o.tensor4d;exports.tensor5d=o.tensor5d;exports.tensor6d=o.tensor6d;exports.tensorScatterUpdate=o.tensorScatterUpdate;exports.tensor_util=o.tensor_util;exports.tidy=o.tidy;exports.tile=o.tile;exports.time=o.time;exports.topk=o.topk;exports.transpose=o.transpose;exports.truncatedNormal=o.truncatedNormal;exports.unique=o.unique;exports.unregisterGradient=o.unregisterGradient;exports.unregisterKernel=o.unregisterKernel;exports.unsortedSegmentSum=o.unsortedSegmentSum;exports.unstack=o.unstack;exports.upcastType=o.upcastType;exports.upperBound=o.upperBound;exports.util=o.util;exports.valueAndGrad=o.valueAndGrad;exports.valueAndGrads=o.valueAndGrads;exports.variable=o.variable;exports.variableGrads=o.variableGrads;exports.where=o.where;exports.whereAsync=o.whereAsync;exports.zeros=o.zeros;exports.zerosLike=o.zerosLike;exports.Callback=ed;exports.CallbackList=su;exports.CustomCallback=ru;exports.EarlyStopping=td;exports.GPGPUContext=Bs;exports.History=ou;exports.InputSpec=ve;exports.LayerVariable=Jc;exports.LayersModel=St;exports.MathBackendCPU=gs;exports.MathBackendWebGL=Cs;exports.OptimizerConstructors=fc;exports.RNN=ut;exports.Sequential=en;exports.SymbolicTensor=at;exports.backend_util=_c;exports.callbacks=MC;exports.constraints=vx;exports.data=Cw;exports.forceHalfFloat=Np;exports.gather_util=wf;exports.gpgpu_util=s$;exports.initializers=zx;exports.input=yu;exports.kernel_impls=Af;exports.layers=pC;exports.loadLayersModel=Nb;exports.math=Cf;exports.metrics=AC;exports.model=Db;exports.models=DC;exports.nextFrame=Sr;exports.registerCallbackConstructor=Fb;exports.regularizers=LC;exports.sequential=Eb;exports.setWebGLContext=Ah;exports.shared=hh;exports.slice_util=hc;exports.test_util=xf;exports.train=Xt;exports.version=iP;exports.version_converter=Bc;exports.version_core=pc;exports.version_cpu=ph;exports.version_layers=Io;exports.version_webgl=$p;exports.webgl=vN;exports.webgl_util=cT;
